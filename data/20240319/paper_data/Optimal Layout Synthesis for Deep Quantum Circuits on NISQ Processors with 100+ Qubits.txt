Optimal Layout Synthesis for Deep Quantum
Circuits on NISQ Processors with 100+ Qubits
Irfansha Shaik #
Department of Computer Science, Aarhus University, Denmark
Kvantify Aps, DK-2300 Copenhagen S, Denmark
Jaco van de Pol #
Department of Computer Science, Aarhus University, Denmark
Abstract
Layout synthesis is mapping a quantum circuit to a quantum processor. SWAP gate insertions are
needed for scheduling 2-qubit gates only on connected physical qubits. With the ever-increasing
number of qubits in NISQ processors, scalable layout synthesis is of utmost importance. With large
optimality gaps observed in heuristic approaches, scalable exact methods are needed. While recent
exact and near-optimal approaches scale to moderate circuits, large deep circuits are still out of
scope. In this work, we propose a SAT encoding based on parallel plans that apply 1 SWAP and
a group of CNOTs at each time step. Using domain-specific information, we maintain optimality
in parallel plans while scaling to large and deep circuits. From our results, we show the scalability
of our approach which significantly outperforms leading exact and near-optimal approaches (up
to 100x). For the first time, we can optimally map several 8, 14, and 16 qubit circuits onto 54,
80, and 127 qubit platforms with up to 17 SWAPs. While adding optimal SWAPs, we also report
near-optimal depth in our mapped circuits.
2012 ACM Subject Classification Hardware → Quantum computation; Computing methodologies
→ Planning for deterministic actions
Keywords and phrases Layout Synthesis, Transpiling, Qubit Mapping and Routing, Quantum
Circuits, Propositional Satisfiability, Parallel Plans
1 Introduction
The Quantum Layout Mapping problem takes as input a quantum circuit (logical design)
and a coupling map (connectedness between physical qubits). The result is an “equivalent”
quantum circuit mapped to the physical qubits, such that any binary operation only happens
on connected qubits. Besides an initial mapping of logical qubits to physical qubits, this also
involves the insertion of SWAP gates. Noise is inherent to qubits in Noisy Intermediate-Scale
Quantum (NISQ) processors. Additional SWAP gates increase both the 2-qubit gate count
and the circuit depth. In the current NISQ era, minimizing error is of utmost importance
for any practical quantum computing. The error rate depends on the number of gates, the
fidelity of gates, and the depth of the circuit. The Optimal Quantum Layout Synthesis is to
synthesize a mapping that optimizes one of the above metrics.
Optimal Layout Synthesis has been studied before. A nice overview is provided in [24].
Several heuristic approaches exist which optimize various metrics. The classical algorithm
for heuristic mapping is SABRE (in Qiskit) [15]. [23] use the MQT benchmarks for mapping
and swapping, using a heuristic search space reduction with an O(nlogn) algorithm. Other
approaches used include A* with cost metrics [29], MAXSAT [18], temporal planning [26],
and constraint programming [3] (minimizing circuit depth).
While heuristic approaches are fast and scalable, their suboptimal mappings may result
in high error rates [27, 24]. Optimizing fidelity with exact approaches can result in circuits
with the lowest error rate. However, as shown in [25], optimizing fidelity is extremely hard
and does not scale beyond small circuits. Circuit depth and 2-qubit gate count optimization
4202
raM
81
]hp-tnauq[
1v89511.3042:viXra2 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
are better alternatives for scalability. The OLSQ tool1 optimizes circuit depth and is built
on [25]. A scalable variant OLSQ2 based on Z3 appeared in [16]. The QMAP tool2 optimizes
the number of SWAP gates and is based on [28, 27]. The same authors introduced the use of
subarchitectures [20]. Other ideas to improve quantum layout use quantum teleportation [9].
In [4], measurements are placed early so qubits can be reused.
In[22],weproposedatool,Q-Synthv13,forSWAPgateoptimizationwhichoutperformed
both QMAP and OLSQ tools. Q-Synth v1 reduces optimal quantum layout synthesis to
classical planning. For maintaining the optimality of the SWAP gates added, Q-Synth v1
adds exactly 1 CNOT or 1 SWAP gate at each time step. In such an approach, the hardness
increases with the plan length i.e., the number of CNOTs + SWAPs. Despite the recent
progress in Q-Synth v1 and OLSQ2, deep circuits that require many SWAPs are still out of
reach.
Contribution
In this paper, we provide a SAT encoding based on parallel plans with domain-specific
information. In particular, at each time step, we map one SWAP gate and a group of CNOT
gates. This reduces the make-span, and using domain-specific information we maintain the
optimality. We propose two-way constraints for CNOT dependencies for better dependency
propagation. Inaddition, wealsoprovidevariationsofourencodingwithbridgesandrelaxed
dependencies (via commutation). In all variations, we only add provably optimal number of
bridges+SWAPs.
For experimental evaluation, we consider two benchmark sets: 1) Standard benchmarks
from previous papers; and 2) Deep VQE benchmarks. For comparison, we consider leading
near-optimal tool TB-OLSQ2 [16] and heuristic SABRE [15]. For mapping, we consider
4 NISQ processors Melbourne (14 qubits), Sycamore (54 qubits), Rigetti (80 qubits), and
Eagle (127 qubits). We propose three experiments: in the first two experiments we map
both benchmark sets to the Sycamore, Rigetti, and Eagle platforms. In the first experiment,
we compare the number of SWAPs added by all three tools. In the second experiment, we
compare SWAP additions and circuit depth of the mapped circuits with TB-OLSQ2. In the
third experiment, we compare the effectiveness of bridges and relaxed dependencies in our
tool by mapping onto the Melbourne platform. Here we report the additional number of
(optimal) SWAPs+bridges.
We demonstrate that our encoding can optimally map deep circuits onto large platforms
with up to 127 qubits. Our tool outperforms the leading near-optimal tool TB-OLSQ2 up
to 100x while always adding the optimal number of SWAPs. We show that while adding
optimal SWAPs, we also report near-optimal depth in the mapped circuits. We also confirm
that heuristic approaches like SABRE add too many SWAPs.
2 Preliminaries
2.1 Layout Synthesis for Quantum Circuits
A quantum circuit consists of a fixed number of (logical) qubits, and a number of quantum
gates(operations)thatareappliedtosomequbitsinaparticularorder. Iftheoutputqubitof
1 OLSQtoolhttps://github.com/tbcdebug/OLSQ
2 MunichQuantumToolkitQMAPhttps://github.com/cda-tum/qmap
3 Q-Synthv1toolhttps://github.com/irfansha/Q-Synth/releases/tag/Q-Synth-v1.0-ICCAD23Irfansha Shaik and Jaco van de Pol 3
gate g is used as an input qubit of gate g , we say g depends on g . The dependencies form
1 2 2 1
a DAG (directed acyclic graph) between the gates. Gates that are (transitively) independent
are called parallel, and can be applied in any order.
Any quantum circuit can be decomposed to an intermediate representation with only
singlequbitgatesandCNOTgates[7]. Viewedclassically,thebinaryCNOTgate(controlled-
NOT, also known as CX) takes two qubits (a,b) as input and transforms them into (a,a⊕b),
i.e., the control qubit a determines whether the data qubit b is negated. We will also use the
SWAP gate, which transforms a qubit pair (a,b) into (b,a). A SWAP gate can be expressed
as a sequence of 3 CNOT gates.
Mostphysicalquantumplatformshavelimitedconnectivity,inwhichtheCNOToperations
can only be applied on physical qubits that are neighbors in the so-called coupling graph.
Given such a circuit and a coupling graph, Layout Synthesis consists of two phases: Initial
Mapping and Qubit Routing. In Initial Mapping, the logical qubits of the given circuit are
mapped to some physical qubits of the platform bijectively. In Qubit Routing, the following
constraints must be satisfied:
Every gate must be scheduled in an order that respects all dependencies;
Every gate must be applied to the correct qubits (taken the mapping into account);
The 2-qubit CNOT gates can only be mapped on connected physical qubits.
Additional SWAP gates may be required, to swap the values of connected physical qubits to
ensure all CNOT gates can be mapped. In this paper, we use gate count as an optimization
metric. In Layout Synthesis, the number of single qubit gates and CNOT gates remain
unchanged. Optimal Layout Synthesis is then minimizing the additional SWAP gates.
c c
2 6
l
0
: X T† • T •
l
1
: T† T T T†
l
2
: H • T† S† • • • H
c c c c
1 3 4 5
Figure 1 3-qubit Or circuit with 6 CNOT gates.
Forexample,Figure1showsanOr-circuitwith3logicalqubits(horizontallines{l ,l ,l }).
0 1 2
Thecircuithas11singlequbitgates(boxeswithnames)and6,CNOTgates(thedotindicates
the control qubit, while the ⊕ indicates the data qubit). Let us suppose we want to map
this circuit onto the linear 3-qubit platform as in Figure 2b. Regardless of physical qubit
connections, single qubit gates can always be scheduled. Only the 2-qubit CNOT gates are
relevant for our optimal synthesis problem. Thus, we first remove the single qubit gates and
only consider CNOT gates for the mapping. Figure 2a shows the reduced Or-circuit with
only CNOT gates. In any valid mapping, the dependencies must be respected, for example,
c c
2 6
p
l : • • 1
0
l :
1
l : • • • • p p
2 0 2
c c c c
1 3 4 5
(a) Or-circuitwithonlyCNOTgates. (b) Couplinggraph.
Figure 2 Reduced Or circuit and a 3-qubit linear platform.4 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
gates c and c can only be mapped before and after gate c , respectively. In this example,
1 3 2
the dependency graph is a total order, but note that with 4 qubits, parallel CNOT gates are
possible, which can be scheduled in any order. One can observe that the connections of c ,c
1 2
and c CNOT gates form a triangle (l ,l ),(l ,l ),(l ,l ). Since the coupling graph does not
3 0 1 1 2 2 0
have a triangle, one cannot map our example circuit to the linear platform. At least two
SWAP gates are needed for any valid mapping. Figure 3 shows such a mapped Or-circuit
where l ,l ,l are mapped to p ,p ,p respectively. Intuitively, the SWAP gates slice the
0 1 2 0 1 2
t t t
0 1 2
c c c
2 3 5
l →p : • × l
0 0 2
l →p : × • • • × • l
1 1 0
l →p : • × l
2 2 1
c c c
1 4 6
Figure 3 Mapped Or-circuit with 2 additional SWAPs (optimal).
circuit such that the sub-circuits do not have any triangles by CNOT connections. Finally,
singlequbitgatescanbeinsertedbackrespectingoriginalDAGdependencies. Figure4shows
c c c
2 3 5
l 0 →p 0 : X T† • T × H l 2
l 1 →p 1 : T† T × T† S† • • • × • l 0
l 2 →p 2 : H • × T T† l 1
c c c
1 4 6
Figure 4 Final Mapped Or-circuit after inserting back single qubit gates.
the final mapped circuit with optimal SWAP gates. Note that the number of physical qubits
can be more than logical qubits. In such cases, one can use so-called ancillary qubits to
avoid unnecessary swaps. Similar to Q-Synth v1, we allow ancillary swapping i.e., a mapped
physical qubit can be swapped with an empty physical qubit.
2.2 Optimal Layout Synthesis as Planning
In Q-Synth v1, we encoded optimal layout synthesis as a planning problem in the Planning
Domain Definition (PDDL) Specification. As discussed above, the reduced circuit with only
CNOT gates is mapped using additional SWAPs. Later single qubit gates are inserted back
to reconstruct the final mapped circuit. In such a planning problem, either exactly one
CNOT gate or one SWAP gate is scheduled at each time step. A plan with the optimal
number of actions corresponds to the optimal number of SWAP additions.
Planning as SAT
Given a boolean formula, a Satisfiability (SAT) problem is finding an assignment to the
boolean variables that makes it a true formula. A planning problem can be encoded as a
bounded reachability problem. Sequential encoding [14] is a standard SAT encoding where
each time step encodes a single action. Using a sequential encoding, one can obtain optimalIrfansha Shaik and Jaco van de Pol 5
plans by incrementing the plan length by 1. For instance, one could use Q-Synth v1 with
Madagascar (a SAT-based planner) to find an optimal mapping. Since the optimal plan
length for the example, Or-circuit is 8 (6 CNOTs + 2 SWAPs), the SAT instance has a
makespan of 8. As shown in [22], sequential encoding scales well for moderate circuits
however deep circuits are still out of reach. It is consensus that a long optimal plan length
can severely impact the performance of SAT-based planners.
Parallel Plans
Inliterature,alternativeparallelplanencodingslike∀-step[13]and∃-step[21]wereproposed
for scaling heuristic SAT-based planning. The key idea in a parallel plan is to group two or
more actions whose preconditions and effects do not conflict. While encodings like ∃-step
scale well, the optimality is not guaranteed. For a scalable optimal layout synthesis, one
needs a way to group CNOTs while still maintaining the optimality.
2.3 Parallel Plans in Optimal Layout Synthesis
Madagascar implements both ∀-step and ∃-step parallel plans. Directly using Q-Synth v1
with parallel plan encodings in Madagascar does not preserve optimality. In particular, there
are three main challenges:
More than one SWAP gate can be applied at each parallel step;
Planner needs to find a partial order in each parallel step satisfying dependencies;
RelaxingCNOTdependencieswithinaparallelstepisnottrivialinaPDDLspecification.
In this paper, we directly encode Layout Synthesis as a SAT problem to circumvent the
encoding challenges in a PDDL specification. In our encoding, we allow exactly one SWAP
gate at each parallel step. Thus, the number of parallel steps corresponds to the optimal
SWAP additions. Further, we use domain-specific information from Layout Synthesis to
relax CNOT dependencies within a parallel step. In particular, we make two observations:
The qubit mappings do not change between two consecutive SWAP gates;
GivenasetofCNOTs,onecanalwaysreconstructapartialorderwithDAGdependencies.
We take advantage of the partial order reconstruction and drop dependency constraints
within a parallel step. The SAT solver can now choose exactly one SWAP and a group of
CNOTs in each parallel step. CNOT gates in different time steps still need to respect the
original DAG dependencies. The full SAT encoding is later discussed in detail in Section 3.
For our example, a parallel plan with a makespan of 3 is sufficient (see Figure 3) instead
of8. Attimestep0, alongwiththeinitialmapping, agroupofCNOTgatesarealsomapped.
From time step 1, exactly one SWAP gate and a group of CNOT gates are mapped. Note
that the satisfying assignment returned by a SAT solver only specifies that:
Logical qubits l ,l ,l are mapped to p ,p ,p , respectively;
0 1 2 0 1 2
SWAP gates on p ,p and p ,p are applied at time steps t ,t respectively;
1 2 0 1 1 2
c ,c gates are applied at t ;
1 2 0
c ,c ,c gates are applied at t ;
3 4 5 1
c gate is applied at t ;
6 2
Inmappedcircuitreconstruction,weusetheDAGdependenciestoorderthegroupofCNOTs
ineachtimestep. Intheliterature,anSMTbasedencodingisappliedinTB-OLSQ(2)[25,16]
which also groups CNOT gates between consecutive SWAP gates. They optimize makespan
of their defined problem. However, longer makespan may result in better SWAP count and
circuit depth. In our experiments, we indeed observe suboptimal solutions by TB-OLSQ2 in
both metrics.6 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
2.4 Incremental SAT Solving
Conflict Driven Clause Learning (CDCL) is a key part of state-of-the-art SAT solving. When
solving similar instances, one can reuse the learned clauses. Incremental SAT solving allows
solving a SAT instance given an assumption of a partial assignment. Essentially by using
different assumptions, multiple instances can be solved while reusing the learned clauses.
In problems like planning, one needs to refute up to k-1 plan length for optimal plans. By
adding assumptions encoding that the goal is reached in the current iteration, one can solve
a planning instance incrementally.
3 Two-Way Parallel SAT encoding
In this section, we implement the ideas discussed above. We provide an incremental SAT
encoding that applies the idea of parallel plans in Layout Synthesis. Table 1 describes the
main variables used in the encoding. Algorithm 1 describes the structure of our encoding. In
every time step, a group of CNOTs are applied. From time step 1, each incremental step
adds one extra SWAP. We generate a set of variables for CNOT and SWAP constraints at
each time step.
Table 1 Encoding variables and descriptions
Variable Description
CL/CP set of all/connected logical/physical qubit pairs
m mapping var for logical l and physical p qubits
l,p
mp if physical qubit p is mapped to some logical qubit
p
s p,p′ SWAP variable for physical qubits p,p′
S set of all SWAP variables
st SWAP-touched variable for physical qubit p
p
c /ac /dc current/advanced/delayed CNOT var for ith CNOT
i i i
lp logic qubit pair variables for logical qubits l,l′
l,l′
In addition to specifying which CNOT gates are chosen in each time step, we also need
to specify the CNOT dependencies. We use the DAG generated from the original circuit
for computing the CNOT dependencies. We adapt the CNOT dependency constraints by
specifying that for every CNOT gate in time step t its predecessors (successors) can be
applied at time step t′, where t′ ≤t (t′ ≥t). We use two extra CNOT blocks, advanced and
delayed CNOTs, which specify if a CNOT gate is mapped in an earlier or later time step.
We call this Two-way SAT encoding to emphasize the bidirectional propagation of CNOT
dependencies. In the following paragraphs, we describe the main parts of the Algorithm and
provide the constraints.
Initial Mapping
Let L (P) be a set of logical (physical) qubits in the circuit. Let nl (np) be the number of
logical (physical) qubits. In time step 0, we add requirements on the Initial Mapping for
logicalandphysicalqubits. Lines1to4inthePseudocodeaddconstraintsformappingevery
logical qubit to a unique physical qubit. We use one-hot encoding for specifying the mapping.
WeapplyExactlyOne(AtmostOne)constraintsforlogical(physical)qubitmappingvariables.
Adding these constraints only at the 0th time step is sufficient for correctness. However,Irfansha Shaik and Jaco van de Pol 7
Algorithm 1 Incremental SAT Solving, starting with t=0
1: for all l∈[1...nl] do
2: ExactlyOne(mt ,...,mt )
l,1 l,np
3: for all p∈[1...np] do
4: AtmostOne(mt ,...,mt )
1,p nl,p
5: MappedPQubits
6: if t != 0 then
7: SwapConstraints and Ancillaries
8: CNOTConnections and CNOTDependencies
9: Assumptions
10: Solve instance with assumption asmt
11: if Instance not satisfied then
12: repeat from step 1 with t = t + 1
adding these constraints at every time step significantly improved the performance of SAT
solvers.
SwapConstraints
From time step 1, we use the same mapping variables for handling SWAPs. Adding a SWAP
gate changes the mapping between logical and physical qubits. The following constraints
must ensure that a SWAP gate is only applied on a connected physical qubit pair. The
logicalqubitsmappedonthephysicalqubitpairmustbeswappedinthenexttimestep. The
qubit mappings for the untouched physical qubits must be propagated. We define two sets
of variables to satisfy such constraints. For choosing a SWAP, we define one SWAP variable
s for each connected physical qubit pair (p,p′). For propagation, we define SWAP-touch
p,p′
variables st to specify if the physical qubit p is touched by the SWAP. We specify that 1)
p
Each SWAP variable forces the SWAP-touched physical variables to True; 2) Exactly one
of the SWAP variables is set to True; 3) Every SWAP forces exactly two SWAP-touched
variables to True. The corresponding boolean constraints are:
^
(st →stt ∧stt )∧ExactlyOne(St)∧ExactlyTwo(stt,...,stt )
p,p′ p p′ 1 np
(p,p′)∈CP
Based on the chosen SWAP variables, we update the mapping variables. For each SWAP
variable s , we swap the p and p′ mapped variables from the previous step to the current
p,p′
step.
^ ^
st →((mt−1 ↔mt )∧(mt−1 ↔mt ))
p,p′ l,p l,p′ l,p′ l,p
(p,p′)∈CPl∈L
If a SWAP-touch variable is False, we propagate the corresponding mapping variables.
^ ^
¬stt →(mt−1 ↔mt )
p l,p l,p
p∈Pl∈L
MappedPQubits and Ancillaries
Using ancillary qubits can reduce the minimal number of SWAPs needed. For ancillary
SWAPs, we need to keep track of mapped qubits (including at time step 0). We specify that8 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
a physical qubit p is mapped to some logical qubit if and only if its mapped variable mp is
p
True.
^ _
mpt ↔( mt )
p l,p
p∈P l∈L
We restrict that at least one of the swapped physical qubits is a mapped qubit. With similar
constraints, we also provide an option for only non-ancillary SWAPs.
^
st →(mpt ∨mpt )
p,p′ p p′
(p,p′)∈CP
CNOTConnections
We require CNOT gates to be applied only on connected physical qubits. Since CNOT gates
must be applied to specific logical qubits, we require that the corresponding logical qubits be
mapped to connected physical qubits. First, we specify that logical qubit pair variables are
true if and only if the physical qubits they are mapped are connected.
^ (cid:0) ^ ((mt ∧mt )∨(mt ∧mt ))→lpt ∧
l,p l′,p′ l,p′ l′,p l,l′
(l,l′)∈CL (p,p′)∈CP
^ ((mt ∧mt )∨(mt ∧mt ))→¬lpt (cid:1)
l,p l′,p′ l,p′ l′,p l,l′
(p,p′)∈CP
Usinglogicalqubitpairvariables,wespecifythatifaCNOTismappedthenitscorresponding
logical qubits are connected. We define D as a dictionary of CNOT indices to logical qubit
pairs. The corresponding boolean constraint is:
i=1
^
ct →lpt
i D[i]
nc
CNOTDependencies
For a correct mapping, we need to respect the DAG dependencies of the CNOT gates in a
circuit. As discussed earlier, we use advanced and delayed CNOT blocks in each time step
to propagate local information globally. Every CNOT is mapped, advanced, or delayed in
all time steps, depending on the status of its predecessors (pre) and successors (suc) in the
dependency DAG. If at time step t a CNOT is:
Mapped: Its predecessors (successors) are either advanced (delayed) or mapped in the
same time step.
Advanced: 1) It is applied or advanced in t−1; 2) Its predecessors are also advanced in t.
Delayed: 1) It is either applied or delayed in t+1; 2) Its successors are also delayed in t;
3) In t, either its logical qubits are not connected or one of its predecessors is delayed.Irfansha Shaik and Jaco van de Pol 9
The corresponding boolean constraints are:
i=1
^(cid:0)
ExactlyOne(ct,act,dct)∧
i i i
nc
^ ^
ct →(act∨ct)∧ ct →(ct∨dct)∧
i j j i j j
j∈pre(i) j∈suc(i)
^
act →(ct−1∨act−1)∧ act →act∧
i i i i j
j∈pre(i)
dct−1 →(ct∨dct)∧ ^ dct →dct∧ dct →(¬lpt ∨ _ dct)(cid:1)
i i i i j i D[i] i
j∈suc(i) j∈pre(i)
Assumptions for Incremental solving
We specify that CNOT gates cannot be advanced at time step 0 i.e.,
Vi=1¬ac0.
For using
nc i
incremental solving in SAT, we use an assumption variable asmt. At every time step, if the
assumption variable is true then CNOT gates cannot be delayed i.e., asmt ↔Vi=1¬dct. For
nc i
each time step, we call the SAT solver with the assumption variable asmt as True.
3.1 Additional Functionality
Sofar, wehavenotusedthesemanticsoftheunaryorbinarygates(excepttheSWAPgates).
The previous encoding could also be used to map circuits with for instance binary CZ gates
instead of CNOT gates. If we take the semantics of the gates into account, there are more
opportunities to optimize the circuits. While a complete re-synthesis of the circuit is beyond
the scope of this paper, we want to illustrate some known techniques that can further reduce
the number of SWAP gates. We emphasize that we now change the optimization problem
(by allowing more solutions), and that the extension are specific for CNOT gates. Our main
purpose is to show that our proposed encoding can be easily extended to incorporate these
techniques, known as "bridges" and "relaxed dependencies". We also note that the encoding
can be easily restricted to disallow the use of "ancillary qubits".
Bridges
t t t
0 1 2
c 3 b 1 b 3 c 5
l →p : × • • • • l
c c 0 0 2
3 5
l →p : • • l →p : • × • • • • l
0 0 2 1 0
l →p : • • • •
2 1 l →p : l
l →p : 1 2 1
1 2
c 1 c 2 c 4 c 6 c 1 c 2 b 2 b 4 c 6
(a) CNOTgatesafterinitialmapping. (b) CNOTgatesafteraddingaSWAPandabridgegate.
Figure 5 Mapping reduced circuit using a SWAP and a bridge gate.
Using a bridge, one can apply a CNOT on disconnected physical qubits. For instance, the
bridge b -b in Fig. 5 together implements a CNOT between p and p (which implements c
1 4 0 2 4
after the preceding SWAP). We limit ourselves to bridges of distance 2. Observe that the
bridge introduces 3 extra CNOT gates, so the cost is the same as a SWAP gate. However,
the result is different, since a bridge does not swap the qubits. This might be an advantage,10 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
depending on the rest of the circuit. In [12], it was shown that using bridges can reduce the
overall CNOT count.
We adapted our optimal Two-Way SAT encoding, by allowing to add either a single
bridge or a single SWAP gate at each time step. If a bridge was added, the corresponding
CNOT gate is regarded as scheduled. So both options cost exactly 3 CNOT gates. The SAT
solver will find a solution with the minimal sum of bridge or SWAP gates. Our experiments
will show that we indeed find better solutions with bridges.
Relaxed Dependencies
t t
0 1
c c c
4 3 5
l →p : • • • • l
c c c c 2 0 2
1 3 4 5
l →p : • • • • l →p : × • l
2 0 1 1 0
l →p :
1 1 l →p : • × l
l →p : • • 0 2 1
0 2
c c c c c
2 6 1 2 6
(a) CNOTgatesafterinitialmapping. (b) CNOTgatesafteraddingaSWAPwithcommutation.
Figure 6 Mapping reduced circuit using a SWAP and relaxed dependencies.
The authors of [11] consider gate commutation rules for quantum layout mapping.
Commutation and cancellation rules on R and CNOT gates are also used in [19], to reduce
Z
the number of H-gates. For instance, two subsequent CNOT gates on the same control qubit,
or on the same data qubit, can be commuted without changing the semantics. Also, single
Z-like gates (like the Z-, S-, T- and R -gates) commute with the control bit of a CNOT,
Z
while X-like gates (like the X- and R -gates) commute with its data bit.
X
Thisaddedfreedomcanbeexploited: bypermutingtheCNOTgates,theycanbegrouped
in a convenient manner, so less SWAP gates are needed. For instance, in Fig. 6a, c and c
3 4
can be commuted, since they share their control bit. As a result, we can now find a solution
that requires only 1 SWAP gate (Fig. 6b), while still respecting the linear coupling graph.
The gate commutation rules can be incorporated in our optimal Two-way SAT encoding
by computing a “relaxed” dependency graph. In the example above, we consider c as a
2
dependency for c and c , but c and c are considered independent. We stress that the
3 4 3 4
relaxed dependencies must also take the unary gates into account (for instance c and c
2 4
cannot be commuted, since there is a T-gate in between, cf. Fig. 1).
In our tool, we compute the relaxed dependency graph before removing the unary gates.
We then generate the encoding as presented before, replacing the dependency graph with the
relaxed dependency graph. This guarantees an optimal Layout Mapping (minimal number
of SWAPS) given the specified commutation rules. Our experiments show that relaxed
dependencies can indeed provide better solutions.
Non-Ancillary Mapping
The actual cost of ancillary qubits in practical quantum computing depends on the context.
We provide optimal layout synthesis without any ancillary SWAPs as an option. Note that
the resulting encoding may require more SWAP gates than when allowing ancillary qubits.
This option can be encoded in our Two-Way SAT encoding, by simply restricting the SWAP
gates to cases where both the physical qubits are already mapped.Irfansha Shaik and Jaco van de Pol 11
4 Experimental Evaluation
4.1 Experiment Design
We have extended our tool Q-Synth v1 (Quantum Synthesizer) to include the Two-Way
Parallel SAT encoding. We provide an open-source tool Q-Synth24 that implements the
SAT encoding and the additional options. For any option chosen, our tool synthesizes
a mapped circuit with the (provably) optimal number of additional SWAP+bridge gates.
We use pysat [10] for generating and solving SAT instances incrementally. For cardinality
constraints, we use the sequential counter from pysat. As a backend for our experiments, we
use Cadical-1.53 [2], a state-of-the-art SAT solver. One can easily experiment with other
SAT solvers in our tool using the pysat interface. When optimizing the SWAP count, our
tool refutes all k−1 SWAP+bridge additions if k is optimal. We report a timeout if an
optimal solution is not found within the time limit. We check equivalence between the
original circuits and our mapped circuits with QCEC5 [5] for correctness.
We design 3 experiments. Our goal is to investigate the effectiveness of our SAT encoding
compared to the current leading tools. We also compare various additional techniques
discussed in 3.1. For comparison, we consider state-of-the-art tools TB-OLSQ2 (near-
optimal) [16] and Qiskit’s SABRE (heuristic). For TB-OLSQ2, we enable the best options
i.e., SWAP optimization and upper bound computation by SABRE, with z3 (v4.12.1.0) [8]
as the backend. TB-OLSQ2 can provide intermediate non-optimal results. We only report
the final (near-optimal) solution when it terminates. If the tool does not terminate within
the time limit, we report it as a timeout. For SABRE, we use the first 1000 seeds for the
SABRE layout and take the minimum SWAPs generated by any seed. We also compare our
results with other leading tools in Section 1.
Experiment 1: Standard Benchmarks on Large Platforms
We consider the standard benchmarks from papers [16, 22, 25] with 23 instances in total.
The benchmark set contains circuits of up to 54 qubits and 270 CNOT gates. The circuits
are mapped to the current NISQ processors, Sycamore with 54 qubits [1], Rigetti with 80
qubits6 and Eagle with 127 qubits [6]. We compare with the tools TB-OLSQ2 and SABRE,
with a time limit of 12000 seconds (3hr 20 minutes) for each instance and an 8 GB memory
limit.
Experiment 2: Deep VQE Benchmarks on Large Platforms
From our experiments and also consistent with the literature [16], most of the benchmarks
from Experiment 1 need at most 10 SWAPs on standard platforms. To investigate the
performance on deep circuits that need many SWAPs, we use a set of 10 random circuits
composed using operators from the Variational Quantum Eigensolver (VQE) algorithm
presented in [17]. Our second benchmark set consists of 10 (8 qubit) circuits with up to 79
CNOT gates. Due to many interactions between the qubits, the number of SWAPs needed
to map onto the standard quantum platforms is high. We use the same time and memory
limits as in Experiment 1. Here we focus on comparison with TB-OLSQ2 and report both
SWAP count and circuit depth.
4 Q-Synthv2toolwithsourcecode,benchmarks,andscriptshttps://github.com/irfansha/Q-Synth
5 MunichQuantumToolkitQCEChttps://github.com/cda-tum/mqt-qcec
6 RigettiComputinghttps://www.rigetti.com12 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
Experiment 3: Effectiveness of Additional Functionality
In this experiment, we compare 4 combinations of SWAPs (S), bridges (B), and relaxed
dependencies(R):1)S2)S+B3)S+R4)S+B+R.Fromourtwobenchmarksets,weconsider
all the circuits with 14 or fewer qubits and map them onto the standard Melbourne platform
of 14 qubits. We give a time limit of 600 seconds (or 10 minutes) and an 8 GB of memory.
Of the 24 instances generated, we drop qft_8 which times out in all 4 combinations. For the
rest of the 23 instances, we report SWAPs+bridges for each combination. Note that every
additional SWAP or bridge adds exactly 3 extra CNOTs to the mapped circuit.
4.2 Results
Table 2 Experiment 1: Number of SWAPs required for mapping circuits with QS2: Q-Synth2
(SWAP-optimal), TO2: TB-OLSQ2 (near optimal), and SB: SABRE (heuristic) tools on different
platforms. Syc: Sycamore (54), Rig: Rigetti (80), Eagle (127) and label or(3/6) represents a circuit
"or" with 3 qubits and 6 CNOT gates
platform (qubits): Sycamore (54) Rigetti (80) Eagle (127)
Circuit(q/cx) / Tool QS2 TO2 SB QS2 TO2 SB QS2 TO2 SB
or(3/6) 2 2 3 2 2 2 2 2 2
adder(4/10) 0 0 0 0 0 0 2 2 2
qaoa5(5/8) 0 0 1 0 0 0 0 0 1
4mod5-v1_22(5/11) 3 3 4 3 3 5 3 3 6
mod5mils_65(5/16) 6 6 7 6 6 7 6 6 8
4gt13_92(5/30) 10 10 15 10 10 15 13 TO 15
tof_4(7/22) 1 1 3 1 1 11 3 3 5
barenco_tof4(7/34) 5 5 18 6 6 17 8 8 17
qft_8(8/56) 9 TO 15 TO TO 12 TO TO 23
tof_5(9/30) 1 1 3 1 1 5 3 3 12
mod_mult55(9/40) 6 6 9 7 8 16 12 TO 20
barenco_tof5(9/50) 6 6 10 8 8 19 12 TO 20
vbe_adder3(10/50) 7 7 8 8 8 14 10 10 33
rc_adder6(14/71) TO 8 16 8 8 35 TO TO 51
ising_model10(16/90) 0 0 0 0 0 0 0 0 0
queko(16/15) 0 0 1 0 0 2 0 0 0
queko(16/29) 0 0 5 0 1 12 2 2 14
queko(16/44) 0 0 7 0 1 25 2 2 37
queko(16/58) 0 0 12 0 1 20 4 TO 41
queko(16/87) 0 1 10 0 1 30 4 TO 36
queko(16/101) 0 0 18 0 1 43 TO TO 36
queko(54/54) 0 1 12 1 1 31 TO TO 47
queko(54/270) 0 1 183 TO TO 302 TO TO 428
Total solved of 23 22 22 23 21 21 23 18 13 23
Experiment 1
Table 2 reports the number of SWAPs added. Both on Sycamore and Rigetti, TB-OLSQ2
mostly reports optimal SWAP count (while not proving optimality). There are 10 instancesIrfansha Shaik and Jaco van de Pol 13
where it reports near-optimal solutions i.e., only 1 extra SWAP gate or times out. The
difference is more significant on the larger 127-qubit Eagle platform. Q-Synth2 solved 5 more
instances optimally where TB-OLSQ2 times out. Figure 7a provides the scatter plot of the
time taken by Q-Synth2 and TB-OLSQ2. Except for two instances with rcadder6 (14 qubits)
on Sycamore and Rigetti, we significantly outperform TB-OLSQ2 on all three platforms. In
several instances, Q-Synth2 is one or two orders of magnitude faster while proving optimality.
In the case of two instances with rcadder6, being a 14 qubit circuit, our tool takes time to
refute the k-1 number of optimal SWAPs. While the heuristic tool SABRE always returns a
mapping within 2 minutes, it also adds too many additional SWAPs. This observation is
consistent with the literature [16].
Table 3 Experiment 2: Additional SWAPs (s.) and Depth (d.) of mapped VQE circuits on
different platforms with QS2: Q-Synth2 (SWAP-optimal) and TO2: TB-OLSQ2 (near optimal)
platform Syc (54) Rig (80) Eagle (127)
QS2 TO2 QS2 TO2 QS2 TO2
Circuit(q/cx) s. d. s. d. s. d. s. d. s. d. s. d.
vqe(8/18) 2 34 2 33 2 36 2 33 3 38 3 35
vqe(8/39) 4 65 5 62 6 68 7 63 7 65 9 64
vqe(8/40) 6 70 7 67 7 67 7 69 10 76 12 68
vqe(8/47) 8 85 10 83 10 84 10 83 14 92 17 86
vqe(8/48) 6 90 6 84 8 94 8 89 12 94 TO TO
vqe(8/52) 9 90 11 87 11 90 TO TO TO TO TO TO
vqe(8/63) 10 101 11 99 13 102 13 102 TO TO TO TO
vqe(8/71) TO TO 16 111 15 112 18 113 TO TO TO TO
vqe(8/78) 14 129 TO TO 17 136 TO TO TO TO TO TO
vqe(8/79) 11 149 11 146 16 151 TO TO TO TO TO TO
Solved (10) 9 9 10 7 5 4
(a) Experiment1 (b) Experiment2
Figure 7 Scatter plots of time taken by TB-OLSQ2 and Q-Synth2.14 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
Experiment 2
Table 3 reports the number of SWAPs added and circuit depth for the mapped VQE circuits.
On all platforms, Q-Synth2 solves 15 more instances SWAP-optimally out of the 24 instances
solved by either of the tools. TB-OLSQ2 in general reports better circuit depth compared to
Q-Synth2. Interestingly in two instances, vqe(8/40) and vqe(8/71), Q-Synth2 reports better
circuit depth. This shows that TB-OLSQ2 is near optimal in both SWAP additions and
circuit depth. Overall Q-Synth2 also reports near-optimal depth while optimizing additional
SWAPs. Figure 7b shows the scatter plot of time for Experiment 2. Except for two instances
with vqe(8/71) on Sycamore and Rigetti, Q-Synth2 significantly outperforms TB-OLSQ2.
Table 4 Experiment 3: Number of SWAPs+bridges required for mapping deep VQE circuits on
Melbourne platform (14-qubits) in 600 seconds with Q-Synth2 with combinations of S: Swaps, B:
bridges, and R: relaxed dependencies
Circuit(q/cx) S SB SR SBR Circuit(q/cx) S SB SR SBR
or(3/6) 2 2 1 1 vqe(8/18) 2 2 2 2
adder(4/10) 0 0 0 0 vqe(8/39) 6 6 6 6
qaoa5(5/8) 0 0 0 0 vqe(8/40) 7 7 7 6
4mod5_22(5/11) 3 2 2 2 vqe(8/47) 8 8 8 8
mod5mils65(5/16) 6 4 4 4 vqe(8/48) 7 6 7 6
4gt13_92(5/30) 10 8 8 8 vqe(8/52) 10 10 10 10
tof_4(7/22) 1 1 1 1 vqe(8/63) 12 12 12 12
barencof4(7/34) 5 5 5 5 vqe(8/71) 13 12 13 12
tof_5(9/30) 1 1 1 1 vqe(8/78) 17 15 16 14
modmult55(9/40) 7 7 7 7 vqe(8/79) 15 13 14 13
barencof5(9/50) 6 6 6 6
vbe_adder(10/50) 8 8 6 6
rcadder6(14/71) 9 8 9 8
Experiment 3
Table 4 reports the number of SWAPs+bridges on the Melbourne platform, with a time out
of 10 minutes. Both bridges and relaxed dependencies can reduce the optimal SWAP+bridge
additions. We observe that both techniques together can reduce CNOT count further. For
instance, vqe(8/78) only needs 14 SWAPs+bridges i.e., 9 fewer CNOTs compared to only
adding SWAPs. If we drop any of the options, the optimal CNOT count is higher.
4.3 Discussion
Comparison to OLSQ, OLSQ2 and TB-OLSQ2
In [16], authors showed that TB-OLSQ2 significantly outperforms both OLSQ and OLSQ2.
Because of the lack of grouping in OLSQ and OLSQ2, the makespan of SMT instances
generated is very large. Since our tool outperforms TB-OLSQ2, we do not report results
from the other two directly. TB-OLSQ2 optimization routines can also be used in our tool
to avoid hard unsatisfiable instances when optimality is not needed.Irfansha Shaik and Jaco van de Pol 15
Comparison to Q-Synth v1 with Classical Planning
In [22], we showed that Q-Synth v1 based on Classical Planning outperformed both OLSQ
and QMAP. While the approach scales well for mapping circuits up to 9 qubits onto 14
qubits platforms, larger circuits are out of reach. For instance, Q-Synth v1 timed out on
rcadder6 (Table 4) with 3 hours. Q-Synth2 maps the same instance optimally within 5
minutes onto the 14-qubit Melbourne platform. Q-Synth v1 does not scale well to the other
larger quantum platforms. Mapping individual CNOTs in Q-Synth v1 results in long plan
length. As discussed in the same paper, long plan lengths increase the difficulty of planning.
Comparison to QMAP and SATMAP
QMAP [28, 27] employs an SMT encoding that grows exponentially with the number of
physical qubits. Even using subarchitectures, QMAP is unable to map circuits greater than
7 qubits. SATMAP [18] on the other hand, encodes the Layout Synthesis as a MAXSAT
problemtominimizethenumberofSWAPs. ItallowstheadditionofoneSWAPbeforeevery
CNOT and uses MAXSAT solvers to minimize the number of SWAPS. As shown in [16], it
produces suboptimal solutions and runs out of time even for moderate circuits.
Comparison with Dynamic Programming Approach
In [12], the authors provided an exact and a heuristic approach for adding SWAPs and
bridge gates. With commutation rules, they showed that using bridges can further reduce
the optimal CNOT additions. Our experiments are consistent with the authors’ observations.
Their exact approach already takes 12 minutes to map a 6-qubit circuit to 6-qubit platforms
and grows exponentially with the number of qubits.
Comparison to SABRE
As observed in Experiment 1, it is clear that heuristic approaches such as SABRE add too
many SWAPs. Adding many SWAPs not only increases the 2-qubit gate count but also
increases circuit depth. However, heuristic approaches have their place in the quantum
compilationpipeline. Asthenumberofqubitsonquantumprocessorsincreases,itisnecessary
to employ a hybrid strategy with heuristic and exact approaches. For instance, one could
use SABRE to quickly find a reasonable initial mapping. Given such a mapping, one can
synthesize a SWAP-optimal mapped circuit using Q-Synth2. As in TB-OLSQ2, we could use
heuristic approaches to get quick upper bounds for near-optimal solving.
5 Conclusion
In this paper, we showed that parallel plans can be adapted to preserve SWAP optimality in
layoutsynthesis. WehaveencodedtheparallelplanningproblemdirectlyinSAT.Wepropose
a Two-Way encoding, in which information is propagated both forward and backward, for
efficiency. We also demonstrated that our Two-Way SAT encoding is compatible with other
techniques, like bridges and gate commutation rules.
The technique is implemented in the open-source tool Q-Synth2 for scalable and optimal
layout synthesis of deep circuits. We can optimally map 8-qubit circuits that require up to
14 SWAPs onto a 127-qubit platform. We significantly outperform leading near-optimal tools
while still guaranteeing that the resulting mapping is optimal.16 OptimalLayoutSynthesisforDeepQuantumCircuitsonNISQProcessorswith100+Qubits
References
1 Frank Arute et al. Quantum supremacy using a programmable superconducting processor.
Nature, 574(7779):505–510, 2019.
2 Armin Biere et al. CaDiCaL, Kissat, Paracooba, Plingeling and Treengeling entering the SAT
Competition 2020. In Proc. of SAT Competition 2020 – Solver and Benchmark Descriptions,
volume B-2020-1, pages 51–53. University of Helsinki, 2020.
3 Kyle E. C. Booth. Constraint programming models for depth-optimal qubit assignment and
SWAP-based routing, 2023. arXiv:2306.08629.
4 Sebastian Brandhofer et al. Optimal qubit reuse for near-term quantum computers. CoRR,
2023. arXiv:2308.00194.
5 LukasBurgholzerandRobertWille.Advancedequivalencecheckingforquantumcircuits.IEEE
TCAD, 40(9):1810–1824, 2021. URL: http://dx.doi.org/10.1109/TCAD.2020.3032630.
6 Jerry Chow, Oliver Dial, and Jay Gambetta. Ibm quantum breaks the 100-qubit processor
barrier. IBM Research Blog, 2, 2021.
7 Andrew W. Cross, Lev S. Bishop, John A. Smolin, and Jay M. Gambetta. Open quantum
assembly language, 2017. arXiv:1707.03429.
8 LeonardoMendonçadeMouraandNikolajS.Bjørner. Z3: anefficientSMTsolver. InTACAS
Proceedings, LNCS 4963, pages 337–340. Springer, 2008.
9 Stefan Hillmich et al. Exploiting quantum teleportation in quantum circuit mapping. In
ASPDAC ’21, pages 792–797. ACM, 2021. doi:10.1145/3394885.3431604.
10 Alexey Ignatiev et al. PySAT: A Python toolkit for prototyping with SAT oracles. In SAT,
pages 428–437, 2018. doi:10.1007/978-3-319-94144-8_26.
11 Toshinari Itoko et al. Quantum circuit compilers using gate commutation rules. In ASPDAC,
pages 191–196. ACM, 2019. doi:10.1145/3287624.3287701.
12 Toshinari Itoko, Rudy Raymond, Takashi Imamichi, and Atsushi Matsuo. Optimization of
quantum circuit mapping using gate transformation and commutation. Integration, 70:43–50,
2020. URL: https://arxiv.org/abs/1907.02686, doi:10.1016/j.vlsi.2019.10.004.
13 Henry A. Kautz, David A. McAllester, and Bart Selman. Encoding plans in propositional
logic. In Proceedings of KR-96, pages 374–384, November 1996.
14 HenryAKautzandBartSelman.Planningassatisfiability.InECAI,volume92,pages359–363,
1992. URL: http://www.cs.cornell.edu/selman/papers/pdf/92.ecai.satplan.pdf.
15 Gushu Li et al. Tackling the qubit mapping problem for NISQ-era quantum devices. In
ASPLOS, pages 1001–1014. ACM, 2019. doi:10.1145/3297858.3304023.
16 W-H. Lin et al. Scalable optimal layout synthesis for NISQ quantum processors. In DAC,
2023. URL: https://doi.org/10.1109/DAC56929.2023.10247760.
17 Marco Majland, Patrick Ettenhuber, and Nikolaj Thomas Zinner. Physical Review A, 108,
nov 2023. doi:10.1103/PhysRevA.108.052422.
18 Abtin Molavi et al. Qubit mapping and routing via MaxSAT. In MICRO, pages 1078–1091.
IEEE, 2022. doi:10.1109/MICRO56248.2022.00077.
19 Yunseong Nam et al. Automated optimization of large quantum circuits with continuous
parameters. npj Quantum Information, 4(1), may 2018.
20 TomPehametal. Onoptimalsubarchitecturesforquantumcircuitmapping. ACM Trans. on
Quant. Computing,2023. URL:https://arxiv.org/abs/2210.09321,doi:10.1145/3593594.
21 Jussi Rintanen et al. Planning as satisfiability: parallel plans and algorithms for plan search.
Artif. Intell., 170(12-13):1031–1080, 2006.
22 IrfanshaShaikandJacovandePol. Optimallayoutsynthesisforquantumcircuitsasclassical
planning. In ICCAD’23, California, USA, 2023. IEEE/ACM.
23 Amisha Srivastava et al. Search space reduction for efficient quantum compilation. In
Proceedings of GLSVLSI-23, pages 109–114. ACM, 2023.
24 BochenTanandJasonCong. Optimalitystudyofexistingquantumcomputinglayoutsynthesis
tools. IEEE Trans. Computers, 70(9):1363–1373, 2021.Irfansha Shaik and Jaco van de Pol 17
25 Bochen Tan et al. Optimal layout synthesis for quantum computing. In IEEE/ACM ICCAD,
pages 137:1–137:9. IEEE, 2020. doi:10.1145/3400302.3415620.
26 DavideVenturelli etal. Temporalplanningforcompilationofquantum approximate optimiza-
tion circuits. In Proceedings of IJCAI-17, pages 4440–4446, 2017.
27 Robert Wille et al. Mapping quantum circuits to IBM QX architectures using the minimal
number of SWAP and H operations. In DAC-19, page 142. ACM, 2019.
28 Alwin Zulehner et al. An efficient methodology for mapping quantum circuits to the IBM QX
architectures. IEEE TCAD ICS, 38(7):1226–1236, 2019.
29 Alwin Zulehner et al. Evaluating the flexibility of a* for mapping quantum circuits. In
Proceedings of RC-19, volume 11497 of LNCS, pages 171–190. Springer, 2019.