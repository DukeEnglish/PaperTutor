Verification of Population Protocols with
Unordered Data
Steffen van Bergerem #
Humboldt-Universität zu Berlin, Germany
Roland Guttenberg #
Technische Universität München, Germany
Sandra Kiefer #
University of Oxford, United Kingdom
Corto Mascle #
LaBRI, Université de Bordeaux, France
Nicolas Waldburger #
IRISA, Université de Rennes, France
Chana Weil-Kennedy #
IMDEA Software Institute, Spain
Abstract
Population protocols are a well-studied model of distributed computation in which a group of
anonymousfinite-stateagentscommunicatesviapairwiseinteractions. Togethertheydecidewhether
theirinitialconfiguration,i.e.,theinitialdistributionofagentsinthestates,satisfiesaproperty. As
an extension in order to express properties of multisets over an infinite data domain, Blondin and
Ladouceur (ICALP’23) introduced population protocols with unordered data (PPUD). In PPUD,
each agent carries a fixed data value, and the interactions between agents depend on whether their
data are equal or not. Blondin and Ladouceur also identified the interesting subclass of immediate
observation PPUD (IOPPUD), where in every transition one of the two agents remains passive and
does not move, and they characterised its expressive power.
We study the decidability and complexity of formally verifying these protocols. The main
verification problem for population protocols is well-specification, that is, checking whether the
given PPUD computes some function. We show that well-specification is undecidable in general.
By contrast, for IOPPUD, we exhibit a large yet natural class of problems, which includes well-
specification among other classic problems, and establish that these problems are in ExpSpace. We
also provide a lower complexity bound, namely coNExpTime-hardness.
2012 ACM Subject Classification Theoryofcomputation→Verificationbymodelchecking;Theory
of computation → Distributed computing models
Keywords and phrases Population protocols, Parameterized verification, Distributed computing,
Well-specification
Funding Steffen van Bergerem: This work was funded by the Deutsche Forschungsgemeinschaft
(DFG, German Research Foundation) — project number 431183758 (gefördert durch die Deutsche
Forschungsgemeinschaft (DFG) — Projektnummer 431183758).
Sandra Kiefer: This research was supported by the Glasstone Benefaction, University of Oxford
[Violette and Samuel Glasstone Research Fellowships in Science 2022] as well as Jesus College in
Oxford, UK.
Chana Weil-Kennedy: This work was supported by the grant PID2022-138072OB-I00, funded by
MCIN,FEDER,UEandpartiallysupportedbyPRODIGYProject(TED2021-132464B-I00)funded
by MCIN and the European Union NextGeneration.
Acknowledgements This project started at and has benefitted substantially from the research camp
Autobóz 2023 in Kassel, Germany. We would like to thank the host, sponsors, and organisers of the
research camp for bringing us together.
4202
yaM
2
]CD.sc[
1v12900.5042:viXra2 Verification of Population Protocols with Unordered Data
1 Introduction
Population protocols (PP) model distributed computation and have received a lot of at-
tention [1,2,8,11,13,17] since their introduction in 2004 [3]. In a PP, a collection of
indistinguishable mobile agents with constant-size memory communicate via pairwise interac-
tions. When two agents meet, they exchange information about their states and update their
states accordingly. The agents collectively compute whether their input configuration, i.e.,
the initial distribution of agents in each state, satisfies a certain predicate. For a PP to com-
pute a predicate, the protocol must be well-specified, i.e., for every initial configuration, all
fair runs starting in this configuration must converge to the same answer. It was shown that
PP compute exactly the predicates of Presburger arithmetic [4]. Moreover, well-specification
is known to be decidable but as hard as the reachability problem for Petri nets [16]. Note
that deciding well-specification is a problem that concerns parameterised verification in the
sense of [7,14], i.e., one must decide that something holds with respect to every value of
the parameter. Here the parameter is the number of agents that are present – the PP must
converge to one answer for every initial configuration, no matter the number of agents.
Population protocols with unordered data (PPUD) were introduced by Blondin and
Ladouceur as a means to compute predicates over arbitrarily large domains [9]. In this
setting, each agent holds a read-only datum from an infinite set D. When interacting, agents
may check (dis)equality of their data. While PP can compute properties like “there are
more than 5 agents in state q ”, PPUD can express, e.g., “there are more than 2 data with
1
5 agents each in state q ”. In [9], the authors construct a PPUD computing the absolute
1
majority predicate, i.e., whether a datum is held by more than half of the agents. They also
characterise the expressive power of immediate observation PPUD (IOPPUD), a subclass of
interest in which interactions are restricted to observations. That is, in every interaction, one
ofthe two agents ispassiveand doesnot change itsstate. Thedecidabilityand complexity of
the main verification question for PPUD, namely well-specification, is left open in Blondin’s
and Ladouceur’s article [9]. It is the subject of this paper.
Contributions We start by showing that well-specification is undecidable for PPUD. This
follows from a reduction from 2-counter machines; in fact, the presence of data allows
us to encode zero-tests. Contrasting this, we show that deciding well-specification is in
ExpSpace for IOPPUD. To this end, we define generalised reachability expressions (GRE)
and establish that, for IOPPUD, deciding whether the set of configurations that satisfy
a given GRE is empty is in ExpSpace. This decidability result is powerful; indeed, this
emptiness problem subsumes classic verification problems like reachability and coverability,
as well as parameterised verification problems such as well-specification and correctness,
wherethelatteraskswhetheragivenprotocolcomputesagiven predicate. Lastly, weexhibit
a coNExpTime lower bound for deciding emptiness of GRE for IOPPUD.
Related work For a recent survey of the research on verification of PP (without data),
see [15]. In particular, the well-specification problem for PP is known to be decidable, but as
hard as Petri net reachability [16] and therefore Ackermann-complete [12,23,24]. In their
seminal paper on the computational power of PP, Angluin, Aspnes, Eisenstat, and Ruppert
also introduced five subclasses of PP that model one-way communication [4]. One of these is
immediate observation population protocols (IOPP), which correspond to IOPPUD without
data. The complexity of well-specification for all five subclasses is determined in [17]. In
particular, the paper shows that well-specification for IOPP is PSpace-complete. IOPPS.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 3
were modelled by immediate observation Petri nets, where classic parameterised problems
can be decided in polynomial space. The notion of generalised reachability expression was
first phrased in this setting, and one of the consequences is that the emptiness problem of
GRE for IOPP is PSpace-complete [28]. Our result shows that adding data to the model as
in [8] (and extending GRE naturally) pushes the emptiness problem between coNExpTime
and ExpSpace.
While the introduction of data in the PP model happened recently [9], a similar approach
has been studied in the related model of Petri nets, under the name of data nets. In this
setting, the classic problem of coverability (or control-state reachability) is decidable but
non-primitive recursive [22] and in fact F -complete [26]. While PPUD can be encoded
ωω
into data nets, our results show that the problems that we study cannot be reduced to
coverability. Another related model is formed by broadcast networks of register automata
(BNRA) [19], an extension of reconfigurable broadcast networks (RBN) with data. RBN
subsume IOPP [6], and consequently BNRA subsume IOPPUD. However, the complexity
of coverability in BNRA is known to be F -complete, hence non-primitive recursive, and
ωω
more complex problems quickly become undecidable [19]. These hardness results contrast
with the ExpSpace membership.
Organisation In Section 2, we introduce the models of PPUD and IOPPUD, the notion of
GRE, and we state our main results. We prove undecidability of well-specification for PPUD
in Section 3. The next sections are dedicated to the study of IOPPUD. In Section 4, we
establish bounds on the number of observed agents. In Section 5, we introduce the technical
notions of boxes and containers and use the bounds from the previous section to translate
GRE into containers. We present the complexity bounds for emptiness of GRE in Section 6.
2 Population Protocols and Main Results
We use the notation [m,n] := {ℓ ∈ N | m ≤ ℓ ≤ n} for m,n ∈ N and [m,+∞) := {ℓ ∈ N |
m≤ℓ} .
2.1 Population Protocols with Unordered Data
We fix an infinite data domain D, an infinite set of agents A, and a function dat: A→D
such that dat−1(d) is infinite for all d ∈ D. For d ∈ D, a d-agent is an agent a ∈ A with
dat(a)=d.
▶ Definition 1. A population protocol with unordered data (PPUD) is a tuple (Q,∆,I,O)
where Q is a finite set of states, ∆⊆Q2×{=,̸=}×Q2 the set of transitions, I ⊆Q the set
of initial states, and O: Q→{⊤,⊥} the output function.
The size of a PPUD P, written |P|, is its number of states. We fix a PPUD (Q,∆,I,O).
A configuration is a function γ: A→Q∪{∗} such that γ(a)∈Q only holds for finitely
many agents a∈A (the agents appearing in γ). We denote by Γ the set of all configurations,
and by Γ :={γ ∈Γ|∀a∈A, γ(a)∈/ Q\I} the set of initial configurations. Given γ ∈Γ
init
and d ∈ D, we let γ#: Q → N be the function that maps each state q to the number of
d
d-agents in q in γ.
Given γ,γ′ ∈Γ, we write γ →γ′, and call it a step from γ to γ′, when there are states
q ,q ,q ,q ∈ Q and two distinct agents a ,a ∈ A such that ((q ,q ), ▷◁, (q ,q )) ∈ ∆,
1 2 3 4 1 2 1 2 3 4
γ(a ) = q , γ(a ) = q , γ′(a ) = q , γ′(a ) = q , γ(a) = γ′(a) for all a ∈ A\{a ,a }, and,
1 1 2 2 1 3 2 4 1 2
additionally, if ▷◁ is an equality (resp. disequality), then dat(a )=dat(a ) (resp. dat(a )̸=
1 2 14 Verification of Population Protocols with Unordered Data
dat(a )). Arunρisa(finiteorinfinite)sequenceofconsecutivestepsρ: γ →γ →γ →....
2 1 2 3
We write ρ: γ −→∗ γ′ to denote that ρ is a finite run from γ to γ′, and simply γ −→∗ γ′ to
denote the existence of such a run. For every γ ∈Γ, let Post∗(γ):={γ′ ∈Γ|γ −→∗ γ′} and
Pre∗(γ):={γ′ ∈Γ|γ′ −→∗ γ}. A run ρ covers a state q ∈Q if there is a configuration γ in ρ
such that γ(a)=q for some agent a.
In accordance with [3] and [9], we consider a run γ →γ →... fair if it is infinite1 and
1 2
for every configuration γ with (cid:12) (cid:12){i∈N|γ
i
−→∗ γ}(cid:12) (cid:12)=∞, it holds that (cid:12) (cid:12){i∈N|γ
i
=γ}(cid:12) (cid:12)=∞.
Thatis,everyinfinitelyoftenreachableconfigurationalsooccursinfinitelyoftenalongtherun.
For b∈{⊤,⊥}, a b-consensus is a configuration γ in which, for all agents a∈A appearing
in γ, it holds that O(γ(a))=b. A fair run ρ: γ →γ →··· stabilises to b∈{⊤,⊥} if there
1 2
is an n∈N such that for every i≥n, γ is a b-consensus. A protocol is well-specified if, for
i
every initial configuration γ ∈Γ , there is b∈{⊤,⊥} such that all fair runs starting in γ
0 init 0
stabilise to b. The well-specification problem for PPUD asks, given a PPUD P, whether P
is well-specified. Given a PPUD P and a function Π: Γ →{⊤,⊥}, P computes Π if, for
init
every γ ∈Γ , every fair run of P starting in γ stabilises to Π(γ ).
0 init 0 0
▶ Example 2. Consider the following PPUD P. Its set of states is Q={ℓ ,ℓ ,f ,f ,dead},
0 1 0 1
with I ={ℓ }, O(ℓ )=O(f )=⊤, O(ℓ )=O(f )=O(dead)=⊥ and its transitions are:
1 0 0 1 1
∀b,b′ ∈{0,1}, (ℓ ,ℓ )7→(ℓ ,f ) ∀b,b′ ∈{0,1}, (ℓ ,f )7→(ℓ ,f )
b b′ b⊕b′ b⊕b′ b b′ b b
∀q,q′ ∈Q, (q,q′)7→ (dead,dead) ∀q ∈Q, (q,dead)7→(dead,dead)
=
where 7→ denotes that the data of the agents must be equal, 7→ without subscript means
=
no condition on data (or equivalently, the transition exists both for equality and disequality),
and ⊕ denotes the XOR operator. P is well-specified and computes the function Π that is
equal to ⊤ whenever there is an even number of appearing data and they all have exactly
one corresponding agent. To see this, if there are two agents of equal datum, then all fair
runs eventually have all agents on dead and stabilise to ⊥. Otherwise, there will eventually
be a single agent in {ℓ ,ℓ }, and it will be on ℓ if and only if the number of agents has
0 1 b
parity b, in which case all other agents will eventually go to f and the run stabilises to ⊥ if
b
b=1 (odd number of agents) and to ⊤ if b=0 (even number of agents).
A more interesting but also more complex example is the majority protocol described
in [9, Section 3]; it computes whether a datum has the absolute majority, i.e., strictly more
agents than all other data combined.
Well-specification is the fundamental verification problem for population protocols. How-
ever, as we will see in Section 3, this problem is undecidable for PPUD.
▶ Theorem 3. The well-specification problem for PPUD is undecidable.
This motivates the study of the restricted class of immediate observation PPUD.
2.2 Immediate Observation Protocols
Immediate observation protocols [4] are a restriction of population protocols where, when
two agents interact, one of the two agents does not change its state. The restriction of the
model with data to immediate observation was first considered in [9].
1 One often considers that a finite run γ −→∗ γ is fair when there is no γ such that γ → γ. In the
f ℓ ℓ
following,weruleoutthispossibilitybyimplicitlyassumingthat,forallq1,q2∈Qand▷◁ ∈{=,̸=},it
holdsthat((q1,q2),▷◁,(q1,q2))∈∆,andignoringthetrivialcasesofrunswithatmostoneagent.S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 5
▶ Definition 4. An immediate observation population protocol with unordered data (or
IOPPUD) is a PPUD P =(Q,∆,I,O) where every transition δ ∈∆ is of the form (q ,q ,▷◁
1 2
,q ,q ), with q ,q ,q ∈Q and ▷◁ ∈{=,̸=}, i.e., the first agent does not change its state.
1 3 1 2 3
For IOPPUD, we denote a transition (q ,q ,▷◁,q ,q ) by q −▷◁ −q →1 q . If we have a step
1 2 1 3 2 3
γ →γ′ with transition q −▷◁ −q →1 q that involves agents a,a ∈A where a is the agent moving
2 3 o
from q to q and a is the agent in q , we denote it by γ−▷ −◁ −a →o γ′. We say that agent a
2 3 o 1 a
observes agent a , and call a the observed agent. Intuitively, a “observes” a and reacts,
o o o
whereas a may not even know it has been observed.
o
▶ Example 5. Consider the following IOPPUD P =(Q,∆,I,O), with Q:={q ,q ,q ,q },
0 1 2 3
I :={q ,q }, O(q )=⊤, O(q)=⊥ for all q ̸=q , and transitions in ∆ as follows:
0 1 3 3
q −= −q →1 q q −= −q →0 q q −̸= −q →2 q ∀q ∈{q ,q },∀▷◁ ∈{=,̸=},q −▷◁ −q →3 q
0 2 1 2 2 3 1 2 3
This protocol is well-specified: from γ ∈Γ , all fair runs stabilise to ⊤ if two data have
0 init
agents on both q and q , and all fair runs stabilise to ⊥ otherwise. Indeed, if there is a
0 1
datum with agents on both q and q , by fairness eventually an agent with this datum is sent
0 1
to q ; if there are two such data, then eventually some agent covers q , and then all agents
2 3
are sent to q and the run stabilises to ⊤. Conversely, if it is not the case, then q cannot be
3 3
covered and all fair runs stabilise to ⊥.
∗
Let ρ: γ −→γ be a run. Agent a is internally observed (resp. externally observed)
start end o
in ρ if ρ contains a step of the form γ −= −a →o γ (resp. γ −̸= −a →o γ ); it is observed if one of
1 a 2 1 a 2
the two cases holds. Similarly, a datum d is observed in ρ if an agent a with dat(a)=d is
observed in ρ; we define similarly a datum being internally or externally observed.
While the set of functions that can be computed by PPUD remains an open ques-
tion, it is known that IOPPUD exactly compute interval predicates [9], defined as follows.
Let S be a finite set. A simple interval predicate over S is a formula ψ of the form
∃˙d ,...,d , V Vm #(q,d ) ∈ [A ,B ] where, for all q ∈ S and j ∈ [1,m], we have
1 m q∈S j=1 j q,j q,j
A ∈N and B ∈N∪{+∞}. The dotted quantifiers quantify over pairwise distinct data.
q,j q,j
Formally, given a protocol P with set of states Q such that S ⊆ Q and given γ ∈ Γ, the
predicate ψ is satisfied by γ if there exist pairwise distinct data d ,...,d ∈D such that for
1 m
all q ∈S and j ∈[1,m], it holds that γ#(q)∈[A ,B ] (resp. γ#(q)∈[A ,B ) in the
dj q,j q,j dj q,j q,j
case that B =+∞). An interval predicate over S is a Boolean combination φ of simple
q,j
interval predicates over S; we define that φ is satisfied by a configuration γ if the simple
interval predicates satisfied by γ satisfy the Boolean combination.
▶Theorem6([9],Theorem18andCorollary29). Given a finite set I, the functions computed
by IOPPUD with set of initial states2 I are exactly the interval predicates over I.
▶Example7. TheprotocoldescribedinExample2andthemajorityprotocolof[9,Section3]
cannotbeturnedintoimmediateobservationprotocols,astheycomputefunctionsthatcannot
be expressed as interval predicates. The immediate observation protocol from Example 5
computes the following interval predicate, which is actually a simple interval predicate:
∃˙d ,d , (#(q ,d )≥1)∧(#(q ,d )≥1)∧(#(q ,d )≥1)∧(#(q ,d )≥1).
1 2 0 1 1 1 0 2 1 2
2 Thisdoesnotlimitthenumberofstatesofsaidprotocols,astheirsetofstatesQmaybelargerthanI.6 Verification of Population Protocols with Unordered Data
Given a simple interval predicate ψ =∃˙d ,...,d , V Vm #(q,d )∈[A ,B ], we
1 m q∈I j=1 j q,j q,j
define its width as m, its height h as the maximum of all finite A and B , and its size as
q,j q,j
|I|·m·log(h). Wealsodefinethewidth(resp.height)ofanintervalpredicateasthemaximum
of the widths (resp. heights) of its simple interval predicates, and its size, measuring the
space taken by its encoding, as the sum of their sizes plus its number of Boolean operators.
▶ Remark 8. In [9], predicates refer to an input alphabet Σ, which is converted into initial
states using an input mapping. For convenience, we have not included the input alphabet in
our model, which is why we arbitrarily fix a set of initial states I in Theorem 6.
2.3 Generalised Reachability Expressions
We define a general class of specifications, called generalised reachability expressions, which
are formulas constructed using interval predicates as atoms and using union, complement,
Post∗, and Pre∗ as operators. This concept is inspired by [28, Section 2.4], although our
choice of atoms is more general and adapted to the data setting.
▶ Definition 9. Let P =(Q,∆,I,O) be a protocol.
Generalised Reachability Expressions (GRE) over P are produced by the grammar
E ::=φ|E∪E |E |Post∗(E)|Pre∗(E),
where φ ranges over interval predicates over Q.
Given a GRE E, we define the set of configurations defined by E, denoted E , as
P
(cid:74) (cid:75)
the set containing all configurations of P that satisfy the formula, where the predicates are
interpreted as above and the other operators are interpreted naturally (the overline denotes
set complementation). This set is denoted E when P is clear from context.
(cid:74) (cid:75)
The length |E| of a GRE E is its number of operators. Letting φ ,...,φ be the interval
1 k
predicatesusedasatomsinE, thenorm||E||ofE isthemaximumoftheheightsandwidths
of the φ . Its size is the sum of the sizes of the φ plus |E|. The emptiness problem for GRE
i i
asks, given as input a protocol P and a GRE E over P, whether E =∅. We will show in
P
(cid:74) (cid:75)
Section 6 that, for IOPPUD, this problem is decidable.
▶ Theorem 10. The emptiness problem for GRE over IOPPUD is in ExpSpace.
We now argue that this decidability result is powerful, as it implies decidability of
many classic problems on IOPPUD. We start with well-specification. We use the nota-
tion ∀˙d,φ as a short form for ¬∃˙d,¬φ. Given a PPUD P and b ∈ {⊤,⊥}, let Out :=
b
∀˙d,V
#(q,d) = 0 be the GRE for b-consensus configurations; moreover, let
q∈/O−1({b})
Stable :=Pre∗(Out ) be the GRE for stable b-consensus, i.e., configurations from which all
b b
runs lead to a b-consensus.
▶Proposition11. LetP beaPPUD,E :=Γ ∩Pre∗(Pre∗(Stable ))∩Pre∗(Pre∗(Stable )).
ws init ⊤ ⊥
P is well-specified if and only if E =∅.
ws P
(cid:74) (cid:75)
Proof. First, Γ = ∀˙d, V #(q,d) = 0 and E is indeed a GRE over P. For every
init q∈/I ws
γ ∈ Γ, Post∗(γ) is fin(cid:74) ite as all configuratio(cid:75) ns reachable from γ have the same number of
agents. Therefore, a fair run ρ that visits Pre∗(S) infinitely often for S ⊆ Γ must visit S
infinitely often. Let γ ∈ Γ and b ∈ {⊤,⊥}; it suffices to prove that there is a fair run
0 init
from γ that does not stabilise to b if and only if γ ∈ Pre∗(Pre∗(Stable )) . If, from γ , one
0 0 b 0
can reach γ ∈/ Pre∗(Stable ) , then one can build a fai(cid:74) r run from γ that fi(cid:75) rst goes to γ, and
b 0
(cid:74) (cid:75)S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 7
then forever performs arbitrary steps in a fair way; since γ ∈/ Pre∗(Stable ) , it will stay
b
in Pre∗(Out ) , so by fairness it visits Out infinitely often a(cid:74) nd does not(cid:75) stabilise to b.
b b
(cid:74) (cid:75) (cid:74) (cid:75)
Conversely,ifthereisafairrunthatdoesnotstabilisetob,thenitnevervisits Stable ,hence
b
byfairnessiteventuallystopsvisiting Pre∗(Stable ) ;thisprovesthatitvisits(cid:74) aconfig(cid:75) uration
b
γ ∈ Pre∗(Stable ) , and γ is reachab(cid:74) le from γ hen(cid:75) ce γ ∈ Pre∗(Pre∗(Stable )) . ◀
b 0 0 b
(cid:74) (cid:75) (cid:74) (cid:75)
Many other problems can be expressed as emptiness problems for GRE; we list a few.
The correctness problem for IOPPUD asks, given an IOPPUD P =(Q,I,O,∆) and an
interval predicate φ over I, whether P computes φ. This can be equivalently phrased as
φ−1(b)∩Pre∗(Pre∗(Stable )) = ∅ for all b ∈ {⊤,⊥}, where φ−1(b) is the set of initial
b
(cid:74) (cid:75)
configurations that φ maps to b. Note that the previous expression is a GRE because, in
Definition 9, we chose as atoms interval predicates such as φ.
The set-reachability problem (called cube-reachability in [5]) asks, given two sets of
configurations S ,S , whether S is reachable from S ; this typically expresses safety
1 2 2 1
problemswhereS represents“badconfigurations”thatmustnotbereached. IfS = E
2 1 1
and S = E , then this amounts to checking whether E ∩Pre∗(E ) is empty. (cid:74) (cid:75)
2 2 1 2
(cid:74) (cid:75) (cid:74) (cid:75)
The home-space problem asks, given a protocol P and a set of configurations H, whether
H can be reached from every configuration reachable from an initial configuration. If H
canbeexpressedasaGREE,thenitsufficestocheckwhether Post∗(Γ ) ⊆ Pre∗(E) .
init
(cid:74) (cid:75) (cid:74) (cid:75)
This problem has been studied in Petri nets [21], but also in probabilistic settings, for
examplein[10]forasynchronousshared-memorysystems;indeed,insystemswithuniform
probabilistic schedulers where Post∗(γ ) is finite for every initial configuration γ , this
0 0
problem is equivalent to asking whether the probability of reaching H is equal to 1.
Theorem 10 entails that, for IOPPUD, all these problems are decidable and in ExpSpace.
3 Undecidability of Verification of Population Protocols with
Unordered Data
In this section, we establish that the most fundamental verification problem for PPUD, i.e.,
the well-specification problem, is already undecidable.
▶ Theorem 3. The well-specification problem for PPUD is undecidable.
We proceed by reduction from the halting problem for 2-counter machines with zero-tests,
a famously undecidable problem [25]. Here, we give a proof sketch. The detailed reduction
can be found in Appendix A.
We fix a 2-counter machine and build a protocol P which is not well-specified if and only
if the counter machine halts. A 2-counter machine performs increments, decrements and
zero-tests on two counters. The main difficulty are the zero-tests. Let us first recall how
increments and decrements are simulated in many prior undecidability results for population
protocols and Petri nets [20,26]. The protocol has a control part Q := {q | i ∈ [1,n]}
CM i
whereasingleinstruction agentevolves;thisparthasonestateperinstructionofthemachine.
Increments and decrements are simulated as follows: The instruction agent interacts with
states of {R}∪{x,y}, where R is a reservoir state and x and y are states in which the
number of agents represents the value of the counters. For example an increment on counter
x moves one agent from the reservoir R to x and advances the instruction agent to the next
instruction. The reservoir is hence implicitly assumed to start with arbitrarily many agents.
The main difficulty is that one does not want to take the =0 branch of a zero-test when
the value of the counter is non-zero. Actually, similar to [20,26], we will not prevent the8 Verification of Population Protocols with Unordered Data
U
x¯ q
ℓ
q
ℓ x=0 x¯
dec(x) x q
k
q
ℓ+1 R
R
(b)Gadgetforx=0branchof“if x=0 then goto k”.
(a)Gadgetforperformingdec(x). Agentsofthe Thesameagenttakesthetwobluedashededgesand
bluedashededgesmusthavethesamedatum. thesameagenttakestheorangedottededges.
Figure 1 For simplicity, we use Petri net notation: circles are states, rectangles are Petri net
transitions. To encode this into our protocols, we split each transition into pairwise interactions.
existence of such runs. Instead, our protocol will have “violating” runs which take the wrong
branch of a zero-test, but our well-specification check will consider only violation-free runs.
The correctness of the reduction is then established in two steps: The CM halts if and only if
some violation-free run to the halting state exists, and this is true if and only if our protocol
is not well-specified. We establish the connection between non-well-specification and the
existence of a violation-free run in our protocol.
In the first place, we guarantee that every initial configuration of our protocol has a
fair run stabilising to ⊥, so that P is not well-specified if and only if there exists a fair
run which does not stabilise to ⊥3. Second, we introduce violation detection, a mechanism
which guarantees that fair runs which contain a violation stabilise to ⊥, hence preserving
well-specification. To do so, we add a sink state q , which has output ⊥ and is attracting,
⊥
i.e., all other states have a transition to q available when observing that q is non-empty.
⊥ ⊥
Violation detection then entails adding transitions into q that will be available infinitely
⊥
often if the run (or its initial configuration) contained a violation. By fairness, any run
containing a violation will then eventually put an agent into q , and hence, because q is
⊥ ⊥
attracting, the run ends in a deadlock with all agents in q . In particular, any fair run
⊥
containing a violation will output ⊥ as claimed. There are two types of violation detection.
First, wewanttoonlymarkthoserunsasviolation-freethatstartininitialconfigurations
where U ∈ Q has at most one agent of each datum. To do so, we make agents remember
whether their initial state was U or not (by encoding it into the state space), and, from
every state, we add a transition to q such that this transition is enabled when an agent
⊥
who started in U observes another agent of same datum that also started in U.
Second, we want to detect violations which consist in falsely simulating a zero-test, as
discussed above. Here our technique shares some similarities with [26]. Let c∈{x,y} be a
counter; for every zero-test of the counter machine, we add two types of transitions to the
protocol. The first type simulates the c ̸= 0 branch and can be taken by the instruction
agent upon interacting with some agent on state c; by contrast, the c=0 branch can always
be taken. However, if it was taken with c̸=0, then violation detection will eventually detect
this. For this mechanism, we introduce a counter control state c¯∈Q. At any point in time,
c¯ contains one agent, similar to the instruction agent. The crux of our violation detection is
that only agents which share the datum with the agent in c¯ will be allowed to move in and
out of state c, as illustrated in Figure 1a.
The =0 branch of a zero-test is depicted in Figure 1b. It replaces the agent on c¯ with an
3 Thiscanbedonewiththeadditionofafreshstatethatistheonlyinitialstateandthathasinternal
transitionstoallformerinitialstatesandaninternaltransitiontoasinkstatethathasoutput⊥.S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 9
agent with fresh datum from state U. Thus, when the c=0 branch is taken, any remaining
agent in c is stuck in c as it will never again share datum with the agent in c¯. Violation
detection then sends an agent in c to q upon observing an agent in c¯ with different datum.
⊥
Now that we have violation detection in place, it only remains to explain the connection
to halting. The halting instruction q in Q is the only state with output ⊤. Hence, any
n CM
run not outputting ⊥ must contain an agent in the halting instruction at some point, and be
violation-free by the above. That is, the counter machine reached the halting state without
violations. Conversely, if the machine halts, one can build a finite run that puts an agent
into the halting state without any violation occurring. The corresponding configuration is
then a deadlock, and hence the extension to an infinite run (by staying there forever) is a fair
run not outputting ⊥. This proves that well-specification is undecidable for PPUD, which
motivates restricting ourselves to immediate observation PPUD.
4 An Analysis of Immediate Observation Protocols with Data
To obtain our complexity bounds on the emptiness problem for GRE, we first show some
transformations on runs that allow us to bound the number of observed agents. All runs
that we consider in this section are finite, and we therefore write them as γ →···→γ or
1 m
∗
γ −→γ . In the rest of this section, we fix an IOPPUD P =(Q,∆,I,O).
start end
We introduce some notation for agents in runs. Let ρ: γ −→∗ γ and d∈D. We let A
1 m ρ
be the set of agents appearing in ρ, and set Ad :={a∈A |dat(a)=d}. We let Ad be the
ρ ρ ρ,o
set of agents with datum d that are observed in ρ, i.e., the a ∈Ad such that there exists
o ρ
a step γ−▷ −◁ −a →o γ′ in ρ. For all q ,q ∈ Q, we let Ad be the set of agents with datum
a 1 m ρ,q1,qm
d that start in q and end in q , i.e., the a ∈ Ad such that γ (a) = q and γ (a) = q .
1 m ρ 1 1 m m
Moreover, we let D :={d∈D|Ad ̸=∅} be the set of data appearing in ρ. We may omit ρ
ρ ρ
in the subscript if the run is clear from the context.
4.1 Bounds on the Number of Observed Agents per Datum
Let ρ: γ → ··· → γ be a run. For i ∈ [1,m], we call γ → γ the i-th step in ρ. Let
1 m i i+1
ρ[→i] (resp. ρ[i→]) denote the prefix of ρ ending on its i-th configuration (resp. the suffix
of ρ starting on its i-th configuration). Let a,b ∈ A . Agent a is active in the i-th step if
ρ
γ −▷ −◁ −a →o γ for some agent a . Otherwise, a is idle in that step. We say b copies a in ρ if
i a i+1 o
after every step γ −▷ −◁ −a →o γ in ρ via some transition t, there is a step γ −▷ −◁ −a →o γ via t
i a i+1 i+1 b i+2
and, additionally, b is idle in every step not immediately following an active step of a.
The following lemma allows us to add agents to a run that copy an agent of the same
datum.
▶ Lemma 12 (Agents copycat). Let ρ: γ −→∗ γ be a run. Let a∈A and a˜∈A\A
start end ρ ρ
∗
with dat(a)=dat(a˜). Then there exist configurations γ˜ ,γ˜ and a run ρ˜: γ˜ −→γ˜
start end start end
such that:
(i) A =A ⊎{a˜}, and for all a′ ∈A , γ˜ (a′)=γ (a′) and γ˜ (a′)=γ (a′);
ρ˜ ρ ρ start start end end
(ii) γ˜ (a˜)=γ (a) and γ˜ (a˜)=γ (a);
start start end end
(iii) a˜ is not observed in ρ˜.
Proof. We let γ˜ be such that γ˜ (a˜) = γ (a) and γ˜ (a′) = γ (a′) for all
start start start start start
a′ ̸=a˜. We construct ρ˜by going through ρ step by step, making a˜ copy a: whenever ρ takes
a step −▷ −◁ −a →o , then we take this step followed by step −▷ −◁ −a →o to ρ˜. We can do so because
a a˜
dat(a˜)=dat(a) and because agent a ̸=a has not moved and thus can be observed again.
o
These are the only steps where a˜ is involved, hence it is never observed. ◀10 Verification of Population Protocols with Unordered Data
c c c c c c = c
q 1 ab = b b d ab d ̸= a d a ed b ab ed
b
a ̸= d a ̸= e
q 2 ed a ed a e ̸= e b e b
Figure2Anexampleofarunwithsixstepsonaprotocolwithtwostatesq ,q . a,b,c,d,edenote
1 2
agents; a,b,c have the same datum and d,e have the same datum. Dashed lines are observations.
The following result shows that, given a run ρ, we can construct a new run with a small
subset of the agents of A such that, for all d ∈ D and all states q and q , if there is a
ρ 1 2
d-agent starting in q and ending in q in ρ, then this is also true in the new run. The full
1 2
proof can be found in Appendix B.
▶ Lemma 13 (Agents core). Let ρ: γ −→∗ γ be a run. Then there exist configurations
start end
γ′ , γ′ and a run ρ′: γ′ −→∗ γ′ with A ⊆A such that:
start end start end ρ′ ρ
(i) for all a∈A , γ′ (a)=γ (a) and γ′ (a)=γ (a);
ρ′ start start end end
(ii) for all d∈D and q ,q ∈Q, if Ad ̸=∅, then Ad ̸=∅;
s e ρ,qs,qe ρ′,qs,qe
(iii) for all d∈D, we have |Ad |≤|Q|3.
ρ′
Proof sketch. WeadaptthebunchargumentfromthecaseofIOprotocolswithoutdata[18].
Suppose there is d∈D and q ,q ∈Q such that |Ad |>|Q|. Let R be the set of states
s e ρ,qs,qe
visited by agents of Ad in ρ. Notice that |R| ≤ |Q|. We define a family (a ) of
ρ,qs,qe q q∈R
pairwise distinct agents such that reducing Ad in ρ to (a ) still yields a valid run.
ρ,qs,qe q q∈R
We iterate through R as follows. Let q ∈R and let f be the first moment q is reached in
ρ, i.e., the minimal index such that there exists an a∈Ad with γ (a)=q. Let ℓ be the
ρ,qs,qe f
last moment q is occupied in ρ, i.e., the maximal index such that there exists an a∈Ad
ρ,qs,qe
with γ (a)=q. Let α be the agent in Ad that reaches q first, i.e., γ (α )=q, and let
ℓ q ρ,qs,qe f q
β be the agent in Ad that leaves q last, i.e., γ (β )=q. Note that these agents do not
q ρ,qs,qe l q
have to be distinct. We pick a fresh agent a ∈/ A with dat(a )=d and modify ρ as follows.
q ρ q
We let a copy α in ρ[→f], then a stays idle until β leaves q (for the last time) and then
q q q q
a copies β in ρ[ℓ→]. We do this for every q ∈R.
q q
Then, for every step in which an a in Ad is observed in state q, let a be observed
o ρ,qs,qe q
instead, i.e., replace steps −▷ −◁ −a →o with −▷ −◁ −a →q . Finally, remove all the agents of Ad
a a ρ,qs,qe
from the run, and identify (or substitute) each a with a distinct agent in Ad , so that
q ρ,qs,qe
(a ) ⊆Ad . We do this for every d∈D and q ,q ∈Q such that |Ad |>|Q|. ◀
q q∈R ρ,qs,qe s e ρ,qs,qe
▶ Example 14. Consider the run ρ depicted in Figure 2. Applying Lemma 13 on ρ yields a
new run ρ′ with 4 agents instead of 5. Indeed, let d denote the datum of a, b and c; we have
|Ad |=|{a,b,c}|=3 whereas |Q|=2. In ρ, agents a and b successively go from q to
ρ,q1,q1 1
q and back to q . In ρ′, these two agents are replaced by a single agent (named b again)
2 1
who goes to q on the first step and only leaves q on the last step. In ρ′, the new agent b is
2 2
observed by d in the second step, and by e in the penultimate step.
4.2 Bounds on the Number of Observed Data
Given a run and a datum d appearing in it, we define the trace of d in ρ as the function
trd: Q2 →N such that for all q ,q ∈Q, it holds that trd(q ,q )=|Ad |. For each pair
ρ 1 2 ρ 1 2 ρ,q1,q2S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 11
of states q ,q , the trace counts the number of d-agents starting in q and ending in q . For
1 2 1 2
example, the trace of the run ρ of Example 14, with d the datum of agents a,b and c, is such
that trd(q ,q )=3 and trd(q,q′)=0 for all (q,q′)̸=(q ,q ). The trace is the information
ρ 1 1 ρ 1 1
we need to copy data: if there is a datum d with trace tr in a run, then we can add data to
the run that mimic d and have the same trace. The following lemma echoes Lemma 12.
▶ Lemma 15 (Data copycat). Let ρ: γ −→∗ γ be a run. Let d ∈ D and d˜∈ D\D .
start end ρ ρ
∗
Then there exist configurations γ˜ , γ˜ and a run ρ˜: γ˜ −→γ˜ such that:
start end start end
(i) A =A ⊎Ad˜ , and for all a∈A , γ˜ (a)=γ (a) and γ˜ (a)=γ (a),
ρ˜ ρ ρ˜ ρ init init end end
(ii) trd˜ =trd and trd′ =trd′ for all d′ ̸=d˜,
ρ˜ ρ ρ˜ ρ
(iii) d˜is not externally observed in ρ˜.
Proof. For all q ,q ∈ Q and all a ∈ Ad , we add an agent a˜ with datum d˜in q at the
s e qs,qe s
start. We do this in a way similar to Lemma 12: after every step −̸= −a →o in ρ, we insert a
a
step −̸= −a →o , and after every step −= −a →o in ρ, we insert a step −= −a˜ →o . We thus maintain the
a˜ a a˜
fact that each added agent a˜ is in the same state as its counterpart a. In particular, they are
in the same state at the end of the run. This yields a run ρ˜with trd˜ =trd, and such that
ρ˜ ρ
for all d′ ̸=d˜, trd′ =trd′. Since d˜∈/ D , it is not externally observed in ρ˜. ◀
ρ˜ ρ ρ
Like we showed for the agents, we show that we can reduce the number of data in a run.
We lift the proof strategy of Lemma 13 from agents to data, exploiting the sets of data with
equal traces. The full proof is in Appendix B.
▶ Lemma 16 (Data core). Let ρ: γ −→∗ γ be a run and let K be a number such that
start end
there are at most K agents of each datum in ρ. Then there exist configurations γ′ , γ′ ,
start end
a run ρ′: γ′ −→∗ γ′ , and a subset of data D ⊆D such that:
start end ρ′ ρ
(i) foralld∈D andallagentsaofdatumd, γ (a)=γ′ (a)andγ (a)=γ′ (a),
ρ′ start start end end
(ii) for all d∈D , there exists d′ ∈D such that trd′ =trd,
ρ ρ′ ρ′ ρ
(iii) |D |≤(K+1)|Q|3+|Q|2.
ρ′
Proof sketch. We define the notion of split trace. The split trace of a datum d at the i-th
configuration of a run ρ maps every triple of states (q ,q ,q ) to the number of d-agents that
1 2 3
are in q at the start of ρ, then in q in the i-th configuration, and finally in q at the end.
1 2 3
Since there are at most K agents per datum, there are at most (K+1)|Q2| possible traces
and M =(K+1)|Q3| possible split traces.
For every trace tr, if there are more than M data that have trace tr in ρ, we apply a
similar argument to Lemma 13: we select one datum for each possible split trace, and use it
tocoverallexternalobservationsofagentswhosedatummatchesthatsplittrace. Weremove
the other data, and show that this is still a valid run. The bound on the total number of
data comes from the number of traces and split traces. ◀
▶ Corollary 17. For every run ρ: γ −→∗ γ , there exists a run ρ˜: γ −→∗ γ such
start end start end
that for all d∈D, it holds that |Ad |≤|Q|3 and that agents of at most (|Q|3+1)|Q|3+|Q|2
ρ˜,o
different data are externally observed.
Proof. We first apply Lemma 13 to ρ to obtain ρ(1): γ(1) −→∗ γ(1) over the same data
start end
such that for all d ∈ D, it holds that |Ad | ≤ |Q|3. Then we apply Lemma 16 to obtain
ρ(1)
ρ(2): γ(2) −→∗ γ(2) withatmost(|Q|3+1)|Q|3+|Q|2 data. ByLemma13-(i)andLemma16-(i),
start end
the remaining agents have the same initial and final states in ρ and ρ(2). It remains to put12 Verification of Population Protocols with Unordered Data
back the agents and data we removed, without increasing the number of externally observed
data or observed agents per datum.
By Lemma 16-(ii), every trace of a datum in ρ(1) appears as the trace of a datum in ρ(2).
Thus, it is possible to re-add data of D to D using repeated applications of Lemma 15.
ρ(1) ρ(2)
By Lemma 15-(iii), this does not add any external observation. So we obtain a run ρ˜(1) from
γ(1) toγ(1) suchthatatmost(|Q|3+1)|Q|3+|Q|2 dataareexternallyobservedbyLemma15-
start end
(iii). Recall that there are at most |Q|3 agents per datum in γ(1) by Lemma 13-(iii); in
start
particular there are at most |Q|3 observed agents per datum in ρ˜(1).
By Lemma 13-(ii), for each datum d and states q ,q , if there is a d-agent a such that
s e
γ (a) = q and γ (a) = q then there is an agent a′ such that γ(1) (a′) = q and
start s end e start s
γ(1)(a′)=q in ρ. Therefore, due to Lemma 13-(ii), we can apply Lemma 12 repeatedly to
end e
addbackthemissingagentsinρ˜(1) andobtainarunρ˜fromγ toγ . ByLemma12-(iii),
start end
this does not add any observation. As a result, we obtain a run from γ to γ in which
start end
at most (|Q|3+1)|Q|3+|Q|2 data are externally observed and for all datum d, at most |Q|3
d-agents are observed. ◀
5 From Expressions to Containers
In this section, we define the technical notions of boxes and containers, which are meant to
represent sets of configurations defined by counting agents and data up to some thresholds.
In Proposition 21, we will prove that the set of configurations defined by a generalised
reachability expression E can be described as a union of containers whose thresholds are
exponential in the length of E and polynomial in its norm. To do so, we will leverage the
bounds on the number of observed agents from Section 4 to bound the description of the
GRE Post∗(F) with respect to the one of GRE F. The key result of Proposition 21 will be
used in Section 6 to obtain the decidability of the emptiness problem for GRE.
5.1 Equivalence of Predicates and Containers
In this subsection, we fix an IOPPUD P =(Q,∆,I,O).
Let n,M ∈ N. An n-box is a vector b: Q → [0,n]. Given a configuration γ and a
datum d ∈ D, we define the n-box of d in γ as ⌈γ,d⌉n: Q → [0,n] such that for all q ∈ Q,
⌈γ,d⌉n(q)=min{n,γ#(q)}; in words, the n-box of d truncates the number of agents of d if
d
it exceeds n. We write Boxes for the set of all n-boxes. We define the equivalence relation
n
≡ over Γ×D by (γ ,d )≡ (γ ,d ) whenever ⌈γ ,d ⌉n =⌈γ ,d ⌉n. An equivalence class of
n 1 1 n 2 2 1 1 2 2
≡ is a set of the form {(γ,d)∈Γ×D|⌈γ,d⌉n =b} for b∈Boxes ; we represent such an
n n
equivalence class for ≡ by the associated n-box b.
n
Toliftthisconcepttodata,wecountthenumberofdatawiththesamen-boxuptobound
M. The (n,M)-container of a configuration γ is the function ⌈γ⌉n,M: Boxes → [0,M]
n
such that ⌈γ⌉n,M(b) = min(cid:8) M,(cid:12) (cid:12){d ∈ D | ⌈γ,d⌉n = b}(cid:12) (cid:12)(cid:9) for all b ∈ Boxes n. We define
the equivalence relation ≡ over Γ by γ ≡ γ whenever ⌈γ ⌉n,M = ⌈γ ⌉n,M. An
n,M 1 n,M 2 1 2
equivalence relation for ≡ is the preimage of some (n,M)-container by the previously
n,M
describedfunction; werepresentsuchanequivalenceclassbytheassociated(n,M)-container.
Figure 3 illustrates the function mapping a given configuration to its container.
In all the following, we use the terms n-boxes and (n,M)-containers to designate both
the vectors and the equivalence classes of ≡ and ≡ that they represent. For instance,
n n,M
we write union of n-boxes for the union of the corresponding equivalence classes of ≡ .
nS.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 13
q
q0 •• q0 •• q0 ••
0 q1 •••• • q1 •••• q1 •••• •
M =2 q2 • q2 • q2 •
q3 •• q3 •• q3 ••
q
q4 •••• q4 •••• •• q4 •••• •
1
q0 ••
q1 •
q 2 q2 •••• ••
q3 •
q4 •
q
3
q0 •••• •
q1 •
container
q2 ••
q q3 •••
4
q4
n=4
configuration boxes
Figure 3 How a configuration is mapped to a (4,2)-container. Here, the protocol has five states
q ,...,q . Five distinct data appear in the configuration, and they are represented using symbols.
0 4
The partition of Γ into (n,M)-containers becomes finer as n and M grow.
▶ Lemma 18. Let n ,n ,M ,M ∈ N. If n ≤ n and M ≤ M , then every (n ,M )-
1 2 1 2 1 2 1 2 1 1
container is a union of (n ,M )-containers.
2 2
Algorithmically, we represent an n-box as a list of appearing states with associated
numbers from [1,n] encoded in binary. Similarly, we represent an (n,M)-container as a list
of appearing n-boxes with associated numbers from [1,M] encoded in binary.
In fact, interval predicates exactly describe finite unions of containers.
▶ Proposition 19. The sets of configurations defined by interval predicates of height at most
n and width at most M are exactly the sets formed by unions of (n,M)-containers.
Proof sketch. For the translation from predicates to containers, consider a simple interval
predicate ∃˙d ,...,d , V VM #(q,d )∈[A ,B ] of height n. This predicate cannot
1 M q∈Q j=1 j q,j q,j
distinguish data mapped to the same n-box, hence cannot distinguish configurations in
the same equivalence class for ≡ , i.e., (n,M)-containers. The same directly extends to
n,M
interval predicates.
For the other direction, we prove that a given (n,M)-container can be expressed as an
intervalpredicateofheightatmostnandwidthatmostM. Todoso,givenaboxb∈Boxes
n
and m≤M, we define the simple interval predicate φ expressing that at least m data
b,≥m
aremappedtoboxb. Formally,φ :=∃˙d ,...,d , V Vm #(q,d )∈[A ,B ],where,
b,≥m 1 m q∈Q j=1 j q q
for all q ∈Q, A :=b(q), B :=b(q) if b(q)<n and B :=+∞ if b(q)=n. This predicate
q q q
hasheightatmostnandwidthatmostM. ABooleancombinationofsuchpredicatesallows
us to express an (n,M)-container. The full proof can be found in Appendix C.1. ◀
We therefore have two equivalent representations. Both are useful: interval predicates
allow us to express properties more naturally, but containers are more convenient for the14 Verification of Population Protocols with Unordered Data
proofs in the remainder of this section. While they are equally expressive, each can be much
more succinct than the other, as stated below. We refer to Appendix C.1 for details.
▶ Remark 20. Containers can be exponentially more succinct than interval predicates, while
interval predicates can be doubly exponentially more succinct than unions of containers.
5.2 A Translation from Expressions to Containers
Based on the translation from interval predicates to containers from Proposition 19, we can
now show that for all generalised reachability expressions E over an IOPPUD P, the set
E is a union of (n,M)-containers with n and M bounded in terms of E and P.
P
(cid:74) (cid:75)
▶Proposition 21. There is a polynomial function poly: N→N such that for all IOPPUD P
and GRE E, the set E is a union of
(cid:16) ||E||·(cid:0) poly(|P|)(cid:1)|E| ,||E||poly(|P|)·|E|2(cid:17)
-containers.
P
(cid:74) (cid:75)
The detailed proof of Proposition 21 can be found in Appendix C.3. We prove the result
by structural induction on E. The base case, when E is an interval predicate, is provided by
Proposition 19. For the induction step, handling Boolean operators is straightforward; the
difficulty lies in operators Pre∗ and Post∗. This is handled by the following lemma, which
relies on the bounds from Section 4.
Equivalence classes for fixed values of n and M do not behave well with respect to the
∗
reachabilityrelation,inthesensethatitcanhappenthatγ −→γ andγ ≡ χ ,
start end start n,M start
∗
but there is no χ ≡ γ such that χ −→ χ . However, this will hold if we
end n,M end start end
take some margin on the equivalence relation of configurations at the start; the following
two functions express this margin. For all n,M ∈ N, let f(n) := (n + |P|3) · |P| and
g(n,M):=(cid:0) M +(|P|3+1)|P|3+|P|2(cid:1) (n+1)|P|.
The following lemma states that, if a set of configurations C cannot distinguish ≡ -
n,M
equivalent configurations, then Pre∗(C) cannot distinguish ≡ -equivalent configura-
f(n),g(n,M)
tions. Inotherwords, ifC isaunionof≡ -equivalenceclasses, (i.e., of(n,M)-containers),
n,M
then Pre∗(C) is a union of ≡ -equivalence classes.
f(n),g(n,M)
▶ Lemma 22. For all n,M ∈ N and all configurations γ ,γ ,χ ∈ Γ, if there is
start end start
∗
a run ρ: γ −→ γ and γ ≡ χ , then there is a configuration χ ∈ Γ
start end start f(n),g(n,M) start end
∗
with γ ≡ χ and a run π: χ −→χ .
end n,M end start end
Proof sketch. We first apply Corollary 17 to ρ, so that we can assume that ρ has a limited
number of externally observed data and of observed agents per datum.
In this proof sketch, we first handle the case with only one datum. Then, we explain how
to generalise this. The full proof can be found in Appendix C.2.
Suppose that all agents in γ and χ share a single datum d, and suppose
start start
(γ ,d)≡ (χ ,d). Let A and A be the agents in γ and χ , respectively.
start f(n) start γ χ start start
For all q,q′ ∈ Q, we set Aq→ := {a ∈ A | γ (a) = q}, Aq→ := {a ∈ A | χ (a) = q},
γ γ start χ χ start
A→q′ :={a∈A |γ (a)=q′}, and Aq→q′ :=Aq→∩A→q′.
γ γ end γ γ γ
Our aim is to assign to each agent in χ an agent in γ to mimic. To do so, we
start start
construct a mapping ν: A →A such that
χ γ
(A) for all a∈A , we have χ (a)=γ (cid:0) ν(a)(cid:1) ,
χ start start
(B) for all a′ ∈A observed in ρ, we have ν−1(a′)̸=∅, and
γ
(C) for all q′ ∈Q, we have |ν−1(A→q′ )|=|A→q′ |, or |ν−1(A→q′ )|≥n and |A→q′ |≥n.
γ,d γ,d γ,d γ,dS.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 15
Webuildν separatelyoneachsetAq→ bydefining,foreachq ∈Q,amappingν : Aq→ →
χ q χ
Aq→. Let q ∈ Q. As (χ ,d) ≡ (γ ,d), either |Aq→| = |Aq→|, or both |Aq→| and
γ start f(n) start γ χ γ
|Aq→| are at least f(n). If |Aq→| = |Aq→|, we let ν form a bijection between Aq→ and
χ γ χ q χ
Aq→. Consider now the second case, where |Aq→| and |Aq→| are at least f(n). We aim
γ γ χ
at selecting, for every q′ ∈ Q, a set A ⊆ Aq→q′ of agents that must be copied in π. If
q→q′ γ
|Aq→q′| ≤ n, then we let A := Aq→q′. Otherwise, we first put in A all agents in
γ q→q′ γ q→q′
Aq→q′ that are observed in ρ, at most |P|3 in total by Corollary 17. If |A |<n, we add
γ q→q′
arbitrary agents from Aq→q′ to A until |A |≥n. Either way, we have selected A
γ q→q′ q→q′ q→q′
of size at most |P|3+n for each q′, hence at most f(n) agents in total. For every q′, we have
|A |≤|Aq→q′|, and either |A |=|Aq→q′| or the two sets have size more than n.
q→q′ γ q→q′ γ
We now build ν such that its image over Aq→ is S A . We build this in two
q χ q′∈Q q→q′
steps. First, we assign to each S A one antecedent by ν in Aq→. This is possible
q′∈Q q→q′ q χ
because |S A | ≤ f(n) ≤ |Aq→|. We then identify some q′′ such that |A | > n
q′∈Q q→q′ χ q→q′′
and map all remaining agents of Aq→ to an arbitrary agent in A . Such a q′′ exists
χ q→q′′
because|Aq→|≥f(n)≥n·|P|,sothereisaq′ suchthat|Aq→q′|≥n,andhence|A |≥n
γ γ q→q′
by construction.
This concludes the construction of ν. It remains to prove that ν fulfils Items (A)–(C).
Items (A) and (B) are immediate from the definition. We prove Item (C). Let q′ ∈Q. We
distinguish two cases:
if |Aq→q′| < n for all q ∈ Q, then for all q, we have |ν−1(Aq→q′)| = |ν−1(A )| =
γ γ q→q′
|A |=|Aq→q′|, so |ν−1(A→q′)|=|A→q′|;
q→q′ γ γ γ
if |Aq→q′| ≥ n for some q ∈ Q, then |A | ≥ n, so |ν−1(Aq→q′)| ≥ n, and thus both
γ q→q′ γ
|ν−1(A→q′)| and |A→q′| are at least n.
γ γ
We construct a run π from χ by copying ρ as follows. For each step of ρ where an
start
agent a performs some transition t, we make |ν−1(a)| steps in π so that all agents in ν−1(a)
perform transition t one by one. If a observed some agent a′, there is a′′ in π that can be
observed because ν−1(a′)̸=∅: we made sure to map an agent to each observed agent in ρ.
For the general case with more data, we similarly construct two mappings µ and
ν. First we define µ, which maps each datum d of χ to one of γ such that
start start
(γ ,µ(d))≡ (χ ,d). Then, for each datum d, ν maps each agent a with datum
start f(n) start
d of χ to one with datum µ(d) of γ .
start start
Onceµandν aredefined,webuildarunfromχ toaconfigurationχ inwhicheach
start end
agent a mimics the behaviour of ν(a) in ρ. We make sure that agents (resp. data) observed
in ρ have agents (resp. data) mapped to them, so that we can take the same transitions in ρ
and π. The construction of ν ensures that, for all data d, we have (γ ,µ(d))≡ (χ ,d).
end f(n) end
The construction of µ ensures that γ ≡ χ . ◀
end f(n),g(n,M) end
6 Decidability and Complexity Bounds
6.1 Decidability in Exponential Space
In this section, we use the results on GRE from Section 5 to provide an ExpSpace upper
boundfortheemptinessproblemforGRE.Inthefollowing,weassumethattherepresentation
of a GRE E takes |E|+log(||E||) space.
We first prove that we can decide membership of a configuration (encoded in a naive
way) in a GRE in PSpace. A configuration is represented data-explicitly if it is represented16 Verification of Population Protocols with Unordered Data
as a list of vectors of NQ, one vector for each datum. The size of this representation is
k·|P|·log(m) where k is the number of data and m is the number of agents appearing in γ.
▶ Proposition 23. The following problem is decidable in PSpace: given a PPUD P, a GRE
E, and a configuration γ described data-explicitly, decide if γ ∈ E .
P
(cid:74) (cid:75)
The proof is given in Appendix D. It uses a relatively straightforward induction on E
to show that this problem can be decided in polynomial space using a recursive algorithm
(with a polynomial whose degree does not depend on E). For the case where E =Post∗(F),
we rely on the fact that the numbers of agents and data remain the same throughout a run;
we therefore can guess the configuration γ′ such that γ′ ∈ F (which can be checked with
P
a recursive call) and γ −→∗ γ′ (which can be checked by exp(cid:74) lo(cid:75) ration of the graph containing
configurations with as many agents and data as γ). The case E =Pre∗(F) is similar.
Proposition 23 allows us to check if a given configuration of a PPUD is in the set
described by a GRE4. In the case of IOPPUD, Proposition 21 allows us to search for a
witness configuration within some bounded set, yielding decidability.
▶ Theorem 10. The emptiness problem for GRE over IOPPUD is in ExpSpace.
Proof. Suppose E is not empty. By Proposition 21, it contains an (n,M)-container
P
cont with n:=||E(cid:74) ||(cid:75) ·poly(|P|)|E| and M :=||E||poly(|P|)·|E|2. We construct a configuration
γ ∈contasfollows. Foreachn-boxb, weselectcont(b)manydatasuchthatoveralln-boxes,
the selected data are pairwise distinct. Then, for each n-box b, each state q ∈Q of P, and
each datum d selected for b, we put b(q) many agents with datum d in q. Note that the
b b
configurationγ isincont,andthenumberofagentsitcontainsitatmostn·|P|·|Boxes |·M.
n
We have |Boxes | = (n+1)|P| = ||E||·poly(|P|)|E||P|. We assumed at the beginning of
n
Section 6 that the encoding of E uses memory |E|+log(||E||). As a result, n, M, |P| and
|Boxes |areallatmostexponentialinthesizeoftheinput. Therefore,if E isnotempty,
n P
(cid:74) (cid:75)
then it contains a configuration with at most exponentially many agents. We can guess the
data-explicit description of such a configuration in non-deterministic exponential space, and
then check that the guessed configuration is in E in exponential space by Proposition 23
P
(we apply the PSpace algorithm on an expone(cid:74) nti(cid:75) al input). As a result, deciding emptiness
of E is in NExpSpace, which is identical with ExpSpace. ◀
P
(cid:74) (cid:75)
6.2 A Lower Complexity Bound
We now provide the following lower complexity bound.
▶ Theorem 24. The emptiness problem for GRE over IOPPUD is coNExpTime-hard.
Proof sketch. We proceed by reduction from the problem of tiling an exponentially large
grid, a NExpTime-complete problem [27], to the complement of the emptiness problem for
GRE. The full proof can be found in Appendix E.
A tiling instance is a tuple (2n,C,T), with n≥1, C a finite set of colours with special
colour white, and T ={t ,...,t }⊆C4 a finite set of tiles. We can view a tile as a square
1 m
whose four edges are coloured. The tiling problem asks whether there is a tiling, that is, a
mapping τ: [0,2n−1]×[0,2n−1]→T such that the colours of neighbouring tiles match and
the borders of the grid are white.
4 ThisimpliesthattheemptinessproblemforGREoverPPUD,whileundecidableduetoTheorem3,is
semi-decidable: onecansimplyenumerateallconfigurationsandtestmembershipforeachofthem.S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 17
Horizontal verifier
Tiling gadget Duplication gadget
colour white
x,y(cid:0) 0
colour white
(cid:0)
x (cid:0)0 q(h) colour right(T)
Tiletypechoice q≥3 y (cid:0)(cid:0)y+1
T
i
Ti
x (cid:0)(cid:0)x+1
t1 ... tm q ≥2,= q≥2q ≥2,̸= w ph oe pr u(cid:0)e laT ti( eh d)
q ≥1,= q ≥1,̸=
Horizontalcoordinate ifx=2n−1 ifx<2n−1
q≥1
andy<2n−1
ifx=2n−1
andy<2n−1,
bit 1 h1(0) h1(1) checkthat andy=2n−1 checkthat
. left(T)=colour left(T)=colour
. . qdup andright(T)=white
checkthat
q f(h)
bit n hn(0) hn(1)
right(T)=white
Twoagents
testwhether Synchronization gadget
Verticalcoordinate theirdata
aredinstinctand T(h)
bit 1 v1(0) v1(1)
enc co od oe rdt ih ne ats ea sme
first
t1,= 1
second
. . . S(h)sync. test t2,= T 2(h) sync. test F(h)
t ...
bit n vn(0) vn(1) m,
Da sink Db = T m(h)
Figure 4 Partial depiction of the protocol constructed in Theorem 24.
Given a tiling instance (2n,C,T), we build an instance (P,E) of the emptiness problem
for GRE. In P, witness tilings can be encoded in the configurations, and we construct (P,E)
such that E contains exactly the configurations that correspond to a correctly encoded
(cid:74) (cid:75)
witness tiling. More precisely, γ ∈ E when:
(cid:74) (cid:75)
(Cond1) for all (i,j)∈[0,2n−1]2, some datum encodes coordinates (i,j) and a tile type;
(Cond2) for all (i,j)∈[0,2n−1]2, there is at most one datum encoding (i,j);
(Cond3) the mapping [0,2n−1]2 →C defined by the data is a tiling.
The GRE E will be of the form of a conjunction, i.e., a list of constraints that the
configuration must satisfy. Our first constraint is Pre∗(Pres(q )) where q is a special error
⊥ ⊥
state and Pres(q) is the GRE expressing that some agent is in q. This forbids, in E ,
(cid:74) (cid:75)
configurations from which q can be covered.
⊥
(Cond1) is obtained using the tiling gadget in Figure 4. States t ,...,t represent the
1 m
available tiles of T, and coordinate states allow for a binary representation of the horizontal
and vertical coordinates of a square in the grid. For a datum d, the agents of datum d in
the coordinate states encode the position of the square corresponding to d, and an agent
of datum d in state t indicates that the square in the grid corresponding to d should be
i
coloured according to tile t . Configurations in E are not allowed to have two agents of
i
(cid:74) (cid:75)
same datum playing the same role; otherwise, one of them may observe the other and go to
q . In particular, each datum has at most 2n+1 agents in the tiling gadget.
⊥
To obtain (Cond2), we use a duplication gadget, partially represented in Figure 4. We
enforce that any configuration in E has one agent of each datum in D , one in D and
a b
(cid:74) (cid:75)
none in the rest of the duplication gadget. The blue part implements a test (depicted in
Figure 5b in Appendix E) where two agents of distinct data, one from D and one from D ,
a b
may test that their data encode the same coordinates; if this is the case, they may go to q .
dup
If there are more than two agents in the blue part, this test is not reliable but q can be
≥318 Verification of Population Protocols with Unordered Data
covered. Item (Cond2) can therefore be achieved by enforcing that configurations in E are
not in Pre∗(Pres(q )∩Pre∗(Pres(q ))). (cid:74) (cid:75)
dup ≥3
Finally, we explain how (Cond3) is achieved; we describe only how the horizontal (left-
right) borders are verified. We use a gadget, named horizontal verifier in Figure 4. In
this gadget, a single agent, called verifier, is in charge of verifying that colours of left-right
borders match. The verifier uses 2n auxiliary agents to encode two variables x,y ∈[0,2n−1]
in binary. Again, transitions to q detect when two agents play the same role, so that
⊥
there is only one verifier and so that variables x and y can be implemented faithfully. The
initialisation x = y = 0 is enforced as a constraint in E. We now sketch how the verifier
reads the encoded tiling; to do that, it must synchronise with the datum encoding (x,y).
This is done using the synchronisation gadget of Figure 4. In E , all agents in the
synchronisation gadget are in S(h). Moreover, we add a constraint(cid:74) in(cid:75) E so that γ ∈ E
requires that there is a run from γ where all agents in the synchronisation gadget end in
F(cid:74)(h(cid:75))
and where the verifier ends in q(h). The synchronisation tests guarantee that, whenever there
f
is an agent in T(h), this agent’s datum encodes square (i,j) where i is equal to the current
i
value of x and j is equal to the current value of y. The synchronisation is challenging to
design because the values of x and y may change throughout a run and only one bit can be
tested at a time. However, as proved in Lemma 37 of Appendix E, this can be achieved by
having a first synchronisation test that checks equality of bits from most to least significant,
and a second test that checks equality from least to most significant. ◀
6.3 Discussion on Complexity Gaps
We now discuss some complexity gaps left open by this paper. First, there remains a com-
plexitygapfortheemptinessproblemforGRE,whichisknowntobebetweencoNExpTime
(Theorem 24) and ExpSpace (Theorem 10). Closing the gap appears challenging. On one
hand, if the problem is below ExpSpace, then this probably requires developing new tech-
niques. On the other hand, proving ExpSpace-hardness does not seem easy. In particular,
the synchronisation techniques from Theorem 24 assumes that each datum synchronises only
once with the verifier. This synchronisation technique would not suitable for, e.g., multiple
interactions between the head and the cells of a Turing machine.
Another, arguably more important open question is the exact complexity of well-
specification, which is only known to be between PSpace (model without data, [18]) and
ExpSpace (Theorem 10). On the one hand, it is unclear whether relevant configurations
can be stored in polynomial space:
▷Claim25. Thenumberofdatatoconsiderforwell-specificationmayhavetobeexponential.
The claim is formalised and proven in Appendix E.5. As a consequence, proving that the
problemisinPSpacecannotbeachievedwithaprocedurethatexplicitlystoresconfigurations.
On the other hand, in order to build a reduction from the tiling problem as in Theorem 24,
we need a new idea to enforce that at most one datum encodes each tile. In Theorem 24, we
had states q and q and duplication meant being able to cover q and, at the same,
dup ≥3 dup
forbid that q can ever be covered in the future. We do not know how to encode this
≥3
constraint when working with an instance of well-specification.
7 Conclusion
Wehavestudiedtheverificationofpopulationprotocolswithunordereddata[9],anextension
of population protocols where agents carry data from an infinite unordered set. We firstS.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 19
proved that the well-specification problem is undecidable (Theorem 3), which then led us to
consider the restriction to protocols with immediate observation. This subclass was defined
in [9], where the authors proved that these protocols compute exactly the interval predicates.
Wedefinedageneralclassofproblemsonthismodel, whichconsistsindecidingtheexistence
of a configuration satisfying a so-called generalised reachability expression; this class of
problems subsumes many classic problems, one of which is well-specification. Despite its
generality,weshowedtheproblemtobedecidableinexponentialspace(Theorem10);wealso
provided a coNExpTime lower bound. A remaining open question is the exact complexity
of well-specification for immediate observation population protocols with unordered data,
which is located between PSpace (model without data, [18]) and ExpSpace (Theorem 10).
References
1 Dan Alistarh, James Aspnes, David Eisenstat, Rati Gelashvili, and Ronald L. Rivest. Time-
space trade-offs in population protocols. In 28th Annual ACM-SIAM Symposium on Discrete
Algorithms, SODA 2017, pages 2560–2579, 2017. doi:10.1137/1.9781611974782.169.
2 Dan Alistarh and Rati Gelashvili. Recent algorithmic advances in population protocols.
SIGACT News, 49(3):63–73, 2018. doi:10.1145/3289137.3289150.
3 DanaAngluin,JamesAspnes,ZoëDiamadi,MichaelJ.Fischer,andRenéPeralta.Computation
in networks of passively mobile finite-state sensors. In 33rd Annual ACM Symposium on
Principles of Distributed Computing, PODC 2004, pages 290–299. ACM, 2004. doi:10.1145/
1011767.1011810.
4 Dana Angluin, James Aspnes, David Eisenstat, and Eric Ruppert. The computational
power of population protocols. Distributed Comput., 20(4):279–304, 2007. doi:10.1007/
S00446-007-0040-2.
5 A. R. Balasubramanian, Lucie Guillou, and Chana Weil-Kennedy. Parameterized analysis
of reconfigurable broadcast networks. In Foundations of Software Science and Computation
Structures - 25th International Conference, FoSSaCS 2022, pages 61–80, 2022. doi:10.1007/
978-3-030-99253-8\_4.
6 A. R. Balasubramanian and Chana Weil-Kennedy. Reconfigurable broadcast networks and
asynchronous shared-memory systems are equivalent. In 12th International Symposium on
Games, Automata, Logics, and Formal Verification, GandALF 2021, pages 18–34, 2021.
doi:10.4204/EPTCS.346.2.
7 Roderick Bloem, Swen Jacobs, Ayrat Khalimov, Igor Konnov, Sasha Rubin, Helmut
Veith, and Josef Widder. Decidability of Parameterized Verification. Synthesis Lectures
on Distributed Computing Theory. Morgan & Claypool Publishers, 2015. doi:10.2200/
S00658ED1V01Y201508DCT013.
8 Michael Blondin, Javier Esparza, Stefan Jaax, and Philipp J. Meyer. Towards efficient
verification of population protocols. Formal Methods Syst. Des., 57(3):305–342, 2021. doi:
10.1007/S10703-021-00367-3.
9 Michael Blondin and François Ladouceur. Population protocols with unordered data. In 50th
International Colloquium on Automata, Languages, and Programming, ICALP 2023, pages
115:1–115:20, 2023. doi:10.4230/LIPICS.ICALP.2023.115.
10 Patricia Bouyer, Nicolas Markey, Mickael Randour, Arnaud Sangnier, and Daniel Stan.
Reachabilityinnetworksofregisterprotocolsunderstochasticschedulers. In43rdInternational
Colloquium on Automata, Languages, and Programming, ICALP 2016, pages 106:1–106:14,
2016. doi:10.4230/LIPICS.ICALP.2016.106.
11 Philipp Czerner, Roland Guttenberg, Martin Helfrich, and Javier Esparza. Fast and succinct
population protocols for Presburger arithmetic. J. Comput. Syst. Sci., 140:103481, 2024.
doi:10.1016/J.JCSS.2023.103481.20 Verification of Population Protocols with Unordered Data
12 Wojciech Czerwinski and Lukasz Orlikowski. Reachability in vector addition systems is
Ackermann-complete. In62nd IEEE Annual Symposium on Foundations of Computer Science,
FOCS 2021, pages 1229–1240, 2021. doi:10.1109/FOCS52979.2021.00120.
13 RobertElsässerandTomaszRadzik. Recentresultsinpopulationprotocolsforexactmajority
andleaderelection. Bull.EATCS,126,2018. URL:http://bulletin.eatcs.org/index.php/
beatcs/article/view/549/546.
14 JavierEsparza. Keepingacrowdsafe: Onthecomplexityofparameterizedverification(invited
talk). In 31st International Symposium on Theoretical Aspects of Computer Science (STACS
2014), STACS 2014, March 5-8, 2014, Lyon, France, pages 1–10, 2014. doi:10.4230/LIPICS.
STACS.2014.1.
15 JavierEsparza.Populationprotocols: Beyondruntimeanalysis.InReachabilityProblems-15th
International Conference, RP 2021,pages28–51,2021. doi:10.1007/978-3-030-89716-1\_3.
16 JavierEsparza,PierreGanty,JérômeLeroux,andRupakMajumdar. Verificationofpopulation
protocols. Acta Informatica, 54(2):191–215, 2017. doi:10.1007/S00236-016-0272-3.
17 Javier Esparza, Stefan Jaax, Mikhail A. Raskin, and Chana Weil-Kennedy. The complexity
of verifying population protocols. Distributed Comput., 34(2):133–177, 2021. doi:10.1007/
S00446-021-00390-X.
18 Javier Esparza, Mikhail A. Raskin, and Chana Weil-Kennedy. Parameterized analysis of
immediate observation Petri nets. In Application and Theory of Petri Nets and Concurrency
- 40th International Conference, PETRI NETS 2019, pages 365–385, 2019. doi:10.1007/
978-3-030-21571-2\_20.
19 LucieGuillou,CortoMascle,andNicolasWaldburger. Parameterizedbroadcastnetworkswith
registers: from NP to the frontiers of decidability. In Foundations of Software Science and
Computation Structures - 27th International Conference, FoSSaCS 2024, pages 250–270, 2024.
doi:10.1007/978-3-031-57231-9\_12.
20 Petr Jancar. Undecidability of bisimilarity for Petri nets and some related problems. Theor.
Comput. Sci., 148(2):281–301, 1995. doi:10.1016/0304-3975(95)00037-W.
21 Petr Jancar and Jérôme Leroux. The semilinear home-space problem is Ackermann-complete
for Petri nets. In 34th International Conference on Concurrency Theory, CONCUR 2023,
pages 36:1–36:17, 2023. doi:10.4230/LIPICS.CONCUR.2023.36.
22 RankoLazic,ThomasChristopherNewcomb,JoëlOuaknine,A.W.Roscoe,andJamesWorrell.
Nets with tokens which carry data. In 28th International Conference on Applications and
Theory of Petri Nets and Other Models of Concurrency, ICATPN 2007, pages 301–320, 2007.
doi:10.1007/978-3-540-73094-1\_19.
23 Jérôme Leroux. The reachability problem for Petri nets is not primitive recursive. In 62nd
IEEE Annual Symposium on Foundations of Computer Science, FOCS 2021,pages1241–1252,
2021. doi:10.1109/FOCS52979.2021.00121.
24 Jérôme Leroux and Sylvain Schmitz. Reachability in vector addition systems is primitive-
recursive in fixed dimension. In 34th Annual ACM/IEEE Symposium on Logic in Computer
Science, LICS 2019, pages 1–13, 2019. doi:10.1109/LICS.2019.8785796.
25 Marvin L. Minsky. Computation: Finite and Infinite Machines. Prentice-Hall, Inc., 1967.
26 FernandoRosa-VelardoandDaviddeFrutos-Escrig. DecidabilityandcomplexityofPetrinets
with unordered data. Theor. Comput. Sci., 412(34):4439–4451, 2011. doi:10.1016/J.TCS.
2011.05.007.
27 François Schwarzentruber. The complexity of tiling problems. CoRR, abs/1907.00102, 2019.
arXiv:1907.00102.
28 Chana Weil-Kennedy. Observation Petri Nets. PhD thesis, Technical Univer-
sity of Munich, Germany, 2023. URL: https://nbn-resolving.org/urn:nbn:de:bvb:
91-diss-20230320-1691161-1-3.S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 21
A Undecidability of Verification of Population Protocols with
Unordered Data: Proof for Section 3
▶ Theorem 3. The well-specification problem for PPUD is undecidable.
A 2-counter machine is a transition system using two counters x and y. It consists of a
list of instructions of the form: inc(c), increment on counter c; dec(c), decrement on counter
c; Test (c,k), zero-test that moves to instruction k if c = 0 (and to the next instruction
0
otherwise); and Halt, halting instruction. The machine starts at the first instruction with
both counters equal to 0. It is well known that deciding whether a 2-counter machine
eventually reaches the Halt instruction is an undecidable problem.
Let CM be a 2-counter machine with n instructions i ,...,i .
1 n
Let Q :={i ,...,i ,i′,...,i′ }. We define a population protocol with unordered data
CM 1 n 1 n
P over infinite domain D as follows:
1. Q :={idle,inc,dec,done,Test ,=0,>0}
op 0
2. Q :=Q ∪{x,y}∪{x¯,y¯}×Q ∪{R,U,q }.
main CM op ⊥
3. Q:=Q ×{R,other}.
main
4. δ will be defined step by step later.
5. I ={(R,R),(U,other),((x¯,idle),other),((y¯,idle),other),(i ,other)}.
1
6. O(i ,other)=O(i ,R)=⊤ if i =halt, else O(q)=⊥ for all other q ∈Q.
m m m
The actual states of the protocol are Q, but the second component is never updated; it
simply remembers whether the initial state was R or not. We will hence mainly refer to
Q and specify all except one transition in terms of Q only.
main main
Recall the role of each state:
R is a reservoir, which can contain many agents of all data.
U is a state in which all agents should have different data
Q is the set of control states in which a single agent should evolve.
CM
for both c∈{x,y}, c¯×Q must contain a single agent at all times, with a datum that
op
is not in U, which is in charge of synchronising with the agent in Q and apply the
CM
transitions of the machine to counter c.
x,y represent the counters: all agents in each c should have the same datum as the
current agent in c¯×Q , and the number of agents in c represents the current counter
op
value.
We will ensure that those conditions are met using the violation detection mechanisms below.
We use the following notation: For p,p′,q,q′ ∈ Q we denote ((p,p′),▷◁,(q,q′)) ∈ δ by
p,p′ 7→ q,q′, or leave away ▷◁ if this transition is enabled in either case. The first transition
▷◁
we present allows us to guarantee that at most one agent per datum is not in R initially.
(p,other),(p′,other)7→ (q ,other),(q ,other) p,p′ ∈Q (Input Violation)
= ⊥ ⊥ main
This transition detects that a violation occurred; multiple agents of the same datum
startedinU orinthecontrolstates. Itoverwriteswhateverothertransitionwouldbedefined
between the states in Q . It is important that it is also impossible for one of the counter
main
control agents in {x¯,y¯}×Q to initially have a datum which is still in the pool U, otherwise
op
one cheat, i.e. an incorrectly performed zero-test, would be undetectable at the start.22 Verification of Population Protocols with Unordered Data
We continue by specifying the other violation transitions; namely if two agents are in
Q , if two agents are in x¯, or if an agent in x¯ meets an agent in x of different datum:
CM
(c¯,b),c7→ q ,q b∈Q ,c∈{x,y} (Counter Colour Violation)
̸= ⊥ ⊥ op
(c¯,b),(c¯,b′)7→q ,q b,b′ ∈Q ,c∈{x,y} (Counter Control Violation)
⊥ ⊥ op
q,q′ 7→q ,q q,q′ ∈Q (Control State Violation)
⊥ ⊥ CM
q ,q 7→q ,q q ∈Q (Convert To Sink)
⊥ ⊥ ⊥ main
The (Convert To Sink) transition informs other agents about violations.
Next we explain the actual counter machine simulation. Increments and Decrements are
performed via a sequence of three transitions each as follows.
i ,(c¯,idle)7→i′ ,(c¯,inc) c∈{x,y},i =inc(c) (Start Increment c)
m m m
(c¯,inc),R7→ (c¯,done),c c∈{x,y} (Increment c)
=
(c¯,done),i′ 7→(c¯,idle),i c∈{x,y},m∈{1,...,n} (End Operation on c)
m m+1
i ,(c¯,idle)7→i′ ,(c¯,dec) c∈{x,y},i =dec(c) (Start Decrement c)
m m m
(c¯,dec),c7→ (c¯,done),R c∈{x,y} (Decrement c)
=
To simulate zero test instructions, the counter control agent in c¯ is informed about the
instruction; afterwards they either meet an agent in c of their own datum, in which case
they decide >0, or an agent in U, in which case this new agent takes their place and the
counter is assumed to be 0.
i ,(c¯,idle)7→i′ ,(c¯,Test ) i =Test (c,k),c∈{x,y},k ∈N (Zerotest Start)
m m 0 m 0
(c¯,Test ),U 7→R,(c¯,=0) c∈{x,y} (c=0)
0
(c¯,Test ),c7→(c¯,>0),c c∈{x,y} (c>0)
0
i′ ,(c¯,=0)7→i ,(c¯,idle) i =Test (c,k),c∈{x,y},k ∈N (End Zerotest =0)
m k m 0
i′ ,(c¯,>0)7→i ,(c¯,idle) i =Test (c,k),c∈{x,y},k ∈N (End Zerotest >0)
m m+1 m 0
Correctness: First assume that the counter machine CM does halt.
Let k be the number of steps CM requires to halt. Let γ be an initial configuration with
0
γ (d ,R) ≥ k and γ (d ,U) = 1 for at least k different data d ,...,d . Moreover, assume
0 i 0 i 1 k
that in γ there is no input violation, i.e. all transitions with “Violation” as part of the
0
name are disabled. In particular, γ (D,i )=γ (D,x¯)=γ (D,y¯)=1, i.e. we do not have a
0 1 0 0
violation in the counter or the control states.
We perform the following transition sequence σ: Using the k data above, we correctly
simulate the counter machine until it halts. Observe that any simulating transition takes
at most 1 agent out of R and at most one new datum from U, hence we do not run out of
agents in R,U. Call the reached configuration γ. This configuration is clearly a deadlock,
since we do not have any violations to detect, and the control agent in Q does not start
CM
any new operation. However, some agent is in the halt instruction, i.e. we indeed have a fair
(in fact terminal) run which does not output ⊥.
Now assume that CM does not halt. We start with three important observations, which
will be used to prove that violation transitions can only be disabled by occurring:S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 23
1. γ(Q ,D), γ({x¯}×Q ,D) and γ({y¯}×Q ,D) are preserved by all transitions except
CM op op
transitions moving an agent to the sink state.
2. Agents who enter {x¯,y¯}×Q are always from U, a previously unused datum.
op
3. Agents who enter or leave x,y are always the same datum as the corresponding x¯,y¯.
We have to prove that every initial configuration has a unique output. Let γ be any
0
initial configuration. We claim that every fair run π = (γ ,γ ,...) stabilises to output ⊥.
0 1
Assume that in π no violation occurs, i.e.γ (q )=0 for all m∈N, otherwise π has output
m ⊥
⊥ via transition (Convert To Sink), since agents cannot leave the sink.
Initially all agents not starting in R have a different datum, otherwise (Input Violation)
would eventually occur. Furthermore, by observation 1, Q ,(x¯,idle) and (y¯,idle) all start
CM
with one agent each, otherwise the corresponding violation transition would eventually occur
by fairness. We claim that in π the counter machine is simulated faithfully. Assume the
opposite. The only way to not simulate the counter machine correctly is by performing a
zero-test wrong. That is, at some γ the goto k part of a Test (c,k) instruction was applied
m 0
with γ (c,d)>0 for some d∈D.
m
However, by observation 2, the unique agent with a state in the set {c¯}×Q will always
op
have a data d′ ̸= d for the rest of the run. By observation 3, the agent in state c with
data d can hence never leave, i.e. we have γ (c,d) > 0 for all l ≥ m. This implies that
l
(Counter Colour Violation) is always enabled, and would eventually occur, contradiction.
Hence in π the counter machine is faithfully simulated. Since CM does not halt, we have
γ (i ,D)=0 for all l∈N and halt instructions i . Since this is the only state with output ⊤,
l k k
every agent always has output ⊥, and the run π hence has output ⊥ as required, concluding
the proof.
As a final remark, this reduction in fact also establishes that the following problem is
undecidable: given two interval predicates φ ,φ and a PPUD P, decide whether the GRE
1 2
Post∗(φ )∩φ is empty. To see this, instead of using violation detection, use φ to encode
1 2 1
the restrictions on initial configurations and φ to encode that at the end, no agent in x or y
2
is supposed to have a different datum than the corresponding agent in x¯ or y¯.
B An Analysis of Immediate Observation Protocols with Data: Proofs
for Section 4
We recall a few notations: Let ρ:γ →γ →···→γ be a run. For i∈[1,m], let ρ[→i]
1 2 m
(resp. ρ[i →]) denote the prefix of ρ ending on its i-th configuration (resp. the suffix of ρ
starting on its i-th configuration).
We let A be the set of agents appearing in ρ, and set Ad :={a∈A |dat(a)=d}. We
ρ ρ ρ
let Ad be the set of agents with datum d that are observed in ρ, i.e., the a ∈Ad such that
ρ,o o ρ
there exists a step γ−▷ −◁ −a →o γ′ in ρ. For all q ,q ∈ Q, we let Ad be the set of agents
a 1 m ρ,q1,qm
with datum d that start in q and end in q , i.e., the a ∈ Ad such that γ (a) = q and
1 m ρ 1 1
γ (a)=q .
m m
▶ Lemma 13 (Agents core). Let ρ: γ −→∗ γ be a run. Then there exist configurations
start end
γ′ , γ′ and a run ρ′: γ′ −→∗ γ′ with A ⊆A such that:
start end start end ρ′ ρ
(i) for all a∈A , γ′ (a)=γ (a) and γ′ (a)=γ (a);
ρ′ start start end end
(ii) for all d∈D and q ,q ∈Q, if Ad ̸=∅, then Ad ̸=∅;
s e ρ,qs,qe ρ′,qs,qe
(iii) for all d∈D, we have |Ad |≤|Q|3.
ρ′24 Verification of Population Protocols with Unordered Data
Proof. Let ρ : γ → γ → ··· → γ . Suppose there are d ∈ D and q ,q ∈ Q such that
1 2 m s e
|Ad |>|Q| (otherwise we can set ρ′ :=ρ). Let R be the set of states visited by agents of
ρ,qs,qe
Ad during ρ. Notice that |R|≤|Q|. We are going to define a family (a ) of pairwise
ρ,qs,qe q q∈R
distinct agents and corresponding trajectories and identify them with agents in Ad such
ρ,qs,qe
that reducing Ad in ρ to (a ) still yields a valid run. Repeating the operation for
ρ,qs,qe q q∈R
every Ad will yield a run fulfilling the conditions of the lemma.
ρ,qs,qe
We iterate through R as follows. Let q be a state in R and let f be the first moment q is
reached in ρ, i.e., the minimal index such that there exists an a∈Ad with γ (a)=q.
ρ,qs,qe f
Let ℓ be the last moment q is occupied in ρ, i.e., the maximal index such that there exists
an a ∈ Ad with γ (a) = q. Let α be an agent in Ad that reaches q first, i.e.,
ρ,qs,qe ℓ q ρ,qs,qe
γ (α )=q, and let β be an agent in Ad that leaves q last, i.e., γ (β )=q. Note that
f q q ρ,qs,qe l q
these agents do not have to be distinct.
We pick a fresh agent a ∈/ A with dat(a )=d and modify ρ as follows. We let a copy
q ρ q q
α in ρ[→f], then a stays idle until β leaves q (for the last time) and then a copies β in
q q q q q
ρ[ℓ→]. We do this for every q ∈R. To see that this still yields a valid run ρ′′, we can apply
Lemma 12 stepwise.
In ρ′′, for every step in which an a in Ad is observed in state q, let a be observed
o ρ,qs,qe q
instead, i.e., replace steps −▷ −◁ −a →o with −▷ −◁ −a →q . Now remove all steps involving agents in
a a
Ad \{a |q ∈R}. To see that this yields a valid run, note that we only need to verify
ρ′′,qs,qe q
that every step is valid. This is the case, since, whenever an agent in Ad is observed
ρ′′,qs,qe
in state q in ρ′′, by construction of the trajectory for a , the agent a is also in state q. To
q q
render Ad a subset of Ad , we identify (or substitute) each a with a distinct agent
ρ′′,qs,qe ρ,qs,qe q
in Ad .
ρ,qs,qe
By applying this transformation to all data in D and all pairs of states q ,q for which
ρ s e
|Ad | > |Q|, we obtain a run ρ′ in which, for all d, q , q , at most |Q| agents go from
ρ,qs,qe s e
q to q with datum d. In total, for each d, there are most |Q|3 d-agents. Lemma 13-(i) is
s e
guaranteedbythefactthatallagentsofAd arefromAd . Lemma13-(ii)followsfrom
ρ′,qs,qe ρ,qs,qe
the fact that for all d, q , q , either |Ad |≤|Q| and Ad =Ad or |Ad |>|Q|
s e ρ,qs,qe ρ′,qs,qe ρ,qs,qe ρ,qs,qe
and |Ad |=|Q| as we have replaced those agents by the agents a . ◀
ρ′,qs,qe q
▶ Lemma 16 (Data core). Let ρ: γ −→∗ γ be a run and let K be a number such that
start end
there are at most K agents of each datum in ρ. Then there exist configurations γ′ , γ′ ,
start end
a run ρ′: γ′ −→∗ γ′ , and a subset of data D ⊆D such that:
start end ρ′ ρ
(i) foralld∈D andallagentsaofdatumd, γ (a)=γ′ (a)andγ (a)=γ′ (a),
ρ′ start start end end
(ii) for all d∈D , there exists d′ ∈D such that trd′ =trd,
ρ ρ′ ρ′ ρ
(iii) |D |≤(K+1)|Q|3+|Q|2.
ρ′
Proof. Let ρ: γ → γ → ··· → γ . We proceed similarly as in the proof of Lemma 13,
1 2 m
lifting the proof from agents to data.
For a datum d and i∈[1,m], we let strd(i): Q3 →N, called the split trace of d in ρ at i,
ρ
be such that for all q ,q ,q ∈Q, we have
1 2 3
strd ρ(i)(q 1,q 2,q 3):=(cid:12) (cid:12)Ad
ρ[→i],q1,q2
∩Ad ρ[i→],q2,q3(cid:12) (cid:12).
Thus, for each triple of states (q ,q ,q ), the value of strd(i)(q ,q ,q ) is the number of
1 2 3 ρ 1 2 3
d-agents that were in q at the start of ρ, in q at the ith configuration, and in q at the end.
1 2 3
Let S := {strd(i) | d ∈ D ,i ∈ [1,m]}. As there are no more than K agents of each
ρ ρ
datum in ρ, it holds that strd(i)(q ,q ,q )∈[0,K] for all data d, for i∈[1,m], and states
ρ 1 2 3
q ,q ,q ∈Q. Hence, |S|≤M :=(K+1)|Q|3.
1 2 3S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 25
For tr: Q2 → [0,K], let Dtr := {d ∈ D | trd = tr} be the data in ρ with trace tr. If
ρ ρ ρ
|Dtr|≤M for all tr: Q2 →[0,K], then |D |≤M ·(K+1)|Q|2 =(K+1)|Q|3+|Q|2, so ρ′ :=ρ
ρ ρ
already fulfils the requirements of the lemma.
Hence, in the following, let tr: Q2 → [0,K] be a trace with |Dtr| > M. We define
ρ
S ={strd(i)|d∈Dtr,i∈[1,m]} the set of split traces corresponding to some datum d of
tr ρ ρ
run ρ with trace tr at some point i. Note that S ⊆S, and thus, |S |≤M.
tr tr
For each split trace str ∈S , we let f be the minimal index such that there exists a
tr str
datum δ
str
in Dt ρr such that strδ ρstr(f str)=str. Similarly, for each str ∈S tr, we let ℓ
str
be
the maximal index such that there exists a datum ε
str
in Dt ρr such that strε ρstr(ℓ str)=str.
Note that those data do not have to be distinct. Also note that, by definition, we have
f
str
≤ ℓ
str
for all str ∈ S tr. As strδ ρstr(f str) = str = strε ρstr(ℓ str), we can define a bijection
g str: Aδ ρstr → Aε ρstr between δ str-agents and ε str-agents appearing in ρ such that γ 1(a) =
γ 1(g str(a)), γ m(a)=γ m(g str(a)), and γ fstr(a)=γ ℓstr(g str(a)) for all δ str-agents a∈Aδ ρstr.
We pick |S |≤M arbitrary, but pairwise distinct, data (η ) in Dtr, one for each
tr str str∈Str ρ
split trace reached by a datum of Dtr in ρ. For each str ∈ S , since δ ,η ∈ Dtr have
ρ tr str str ρ
the same trace tr in ρ, we can define a bijection f str: Aη ρstr → Aδ ρstr between η str-agents
and δ -agents appearing in ρ so that γ (a) = γ (f (a)) and γ (a) = γ (f (a)) for all
str 1 1 str m m str
η str-agents a∈Aη ρstr.
The function l str := g str ◦f str: Aη ρstr → Aε ρstr is then a bijection between η str-agents
and ε -agents such that γ (a) = γ (l (a)) and γ (a) = γ (l (a)) for all η -agents
str 1 1 str m m str str
a∈Aηstr.
ρ
Intuitively, we will replace Dtr with a subset {η |str ∈S }. Agents of each η will
ρ str tr str
be in charge of allowing all external observations on agents of data d∈Dtr in carried when
ρ
that datum matches split trace str.
To do so, agents of η start by mimicking the moves of δ (the first datum of Dtr
str str ρ
to reach str) until f . This is done by making each agent copy its image by f . Then,
str str
agents of η remain idle and allow all aforementioned external observations to be carried
str
out. Finally, when point ℓ is reached in ρ, the agents of η copy their images by l
str str str
until the end.
This is formalised by the following claim.
▷Claim26. Thereisarunρ˜: γ˜ −→∗ γ˜ −→∗ ···−→∗ γ˜ withD =(D \Dtr)∪{η |str ∈S }
1 2 m ρ˜ ρ ρ str tr
such that for all i∈[1,m], the following holds.
1. For all d∈D , we have Ad =Ad.
ρ˜ ρ˜ ρ
2. For all d∈D \Dtr and a∈Ad, we have γ˜ (a)=γ (a).
ρ ρ ρ i i
3. For all str ∈S
tr
and all a∈Aη ρstr,
if i≤f , then γ˜ (a)=γ (f (a)),
str i i str
if f ≤i≤ℓ , then γ˜ (a)=γ (f (a))=γ (l (a)), and
str str i fstr str ℓstr str
if i≥ℓ then γ˜ (a)=γ (l (a)).
str i i str
∗ ∗
Proof. We inductively define configurations γ˜ and runs γ˜ −→···−→γ˜ for all i∈[1,m] that
i 1 i
satisfy Items 1–3. For all a∈A, we set γ˜ (a):=γ (a) if dat(a)∈/ Dtr or if dat(a)=δ for
1 1 ρ str
some str ∈ S , and we set γ˜ (a) := ∗ otherwise. Now assume we have defined ρ˜up to γ˜
tr 1 i
with i<m. We continue with the run up to γ˜ . Let γ −▷ −◁ −a →o γ be the step at hand, and
i+1 i a i+1
let q −▷◁ −q →o p be the used transition.
If dat(a )∈/ Dtr, by Items 1 and 2, we have γ˜ (a )=γ (a )=q , and we set a˜ :=a .
o ρ i o i o o o o26 Verification of Population Protocols with Unordered Data
If d
o
:=dat(a o)∈Dt ρr, then let str
o
:=strd ρo(i). Since f
stro
and ℓ
stro
were defined as the
minimal and maximal indices where str occurs, we have f ≤ i ≤ ℓ . Moreover,
o stro stro
since γ (a ) = q , we must have str (q ,q ,q ) > 0 for some q ,q ∈ Q. As a
i o o o 1,o o m,o 1,o m,o
result, there exists a δ -agent a′ such that γ (a′) = q . We let a˜ := f−1 (a′).
stro o fstro o o o stro o
Then, by Item 3, we have γ˜ (a˜ )=γ (a′)=q .
i o fstro o o
∗
In both cases, we have γ˜ (a˜ ) = q . We now define the steps γ˜ −→ γ˜ based on another
i o o i i+1
case distinction.
If dat(a)∈/ Dtr, then we use the step γ˜ −▷ −◁ −a˜ →o γ˜ based on the transition q −▷◁ −q →o p. If
ρ i a i+1
dat(a ) ∈/ Dtr, then a˜ = a , and this transition can be taken because γ˜ (a) = γ (a)
o ρ o o i i
and γ˜ (a ) = γ (a ). Otherwise, if dat(a ) ∈ Dtr, then dat(a ) ̸= dat(a), so ▷◁ is
i o i o o ρ o
̸=. Further, dat(a˜ ) ∈ {η | str ∈ S }, so dat(a˜ ) ̸= dat(a). Also, we defined a˜
o str tr o o
so that γ˜ (a˜ ) = γ (a ). Then the transition can be taken because γ˜ (a) = γ (a) and
i o i o i i
γ˜ (a˜ )=γ (a ).
i o i o
If dat(a)∈Dtr\{δ ,ε |str ∈S }, then we ignore the step and set γ˜ :=γ˜ .
ρ str str tr i+1 i
If dat(a) ∈ {δ ,ε | str ∈ S }, then, for all str ∈ S we sequentially apply the
str str tr tr
following.
If i+1≤f and dat(a)=δ , then we move the agent a˜:=f−1(a). By Item 3, we
str str str
know that γ˜ (a˜)=γ (f (a˜))=γ (a)=q. Furthermore, we have γ˜ (a˜ )=γ (a )=q .
i i str i i o i o o
Finally, if ▷◁ is =, then it holds that dat(a )=δ , and thus dat(a˜)=η =dat(a˜ ).
o str str o
If ▷◁ is ̸=, then by definition of f , as i < f , at this point, no datum of trace tr
str str
matches split trace str. That is, for all data d ∈ Dtr, we have strd(i) ̸= str. Thus,
ρ ρ
for d
o
:= dat(a o), we have d
0
̸∈ Dt ρr or str
o
:= strd ρo(i) ̸= str. In the first case, we
have a˜ =a , so dat(a˜ )̸∈Dtr, but dat(a˜)=η ∈Dtr. In the second case, we have
o o o ρ str ρ
dat(a˜ )=η ̸=η =dat(a˜), since the data (η ) are pairwise distinct. In
o stro str str′ str′∈Str
both cases, we have dat(a˜ )̸=η .
o str
Hence, in all cases, we can let the agent a˜ take transition q −▷◁ −q →o p.
Similarly,ifi≥ℓ anddat(a)=ε ,thenwemovetheagenta˜:=l−1(a). ByItem3,
str str str
we know that γ˜ (a˜)=γ˜ (l−1(a))=γ (a)=q. Furthermore, we have γ˜ (a˜ )=γ (a )=
i i str i i o i o
q . Finally, if ▷◁ is =, then it holds that dat(a ) = ε , and thus dat(a˜) = η =
o o str str
dat(a˜ ). If ▷◁ is ̸= then by definition of ℓ , as i≥ℓ , dat(a ) cannot have trace
o str str o
tr and match split trace str, as otherwise it would still match it at step i+1>ℓ .
str
Therefore, analogously to the case i+1≤f and dat(a)=δ , for d :=dat(a ),
str str o o
we have d
0
̸∈Dt ρr or str
o
:=strd ρo(i)̸=str. Again, this implies that dat(a˜ o)̸=η str. In
all cases, we can let the agent a˜ take transition q −▷◁ −q →o p.
Note that for each str, at most one of the two cases applies. Furthermore, all the moving
agents a˜ are distinct, as they have different data (since the η are distinct). Moreover,
str
a˜ does not move at any point. Therefore, as all those steps are enabled in γ˜ , they can
o i
all be taken sequentially to get to γ˜ .
i+1
It is straightforward to show that the induction hypothesis is maintained in all these cases.
Since the moves of agents a with dat(a)∈/ Dtr do not change, clearly, γ˜ (a)=γ (a). For
ρ i+1 i+1
agents a with dat(a)=η for some str ∈S , note that we make a follow the same steps
str tr
as f(a) until point f , then stay idle until ℓ , and then follow the same steps as l(a).
str str
This concludes our induction. ◁
The following claim is a direct consequence of the previous one, as all remaining data
have preserved their initial and final configuration, thus their traces. Moreover, we have onlyS.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 27
deleted data with trace tr. Since there is a datum with trace tr in ρ, the set S is not empty,
tr
and thus there are data in ρ′ with trace tr, i.e., the datum η for every str ∈S . Hence,
str tr
as all traces appearing in ρ are represented in ρ′.
▷ Claim 27. For all tr: Q2 → [0,K], there is a run ρ˜: γ˜ −→∗ γ˜ over the set of agents
1 m
appearing in ρ with datum in (D \Dtr)∪{η |str ∈S } such that
ρ ρ str tr
for all d∈D and all d-agent a, we have γ (a)=γ˜ (a) and γ (a)=γ˜ (a),
ρ′ 1 1 m m
for all d∈D , there exists d′ such that trd′ =trd, and
ρ ρ′ ρ
there are at most M data d′ such that trρ′ =tr.
d′
The statement of Lemma 16 follows by iteratively applying the claim for each trace
tr: Q2 →[0,K] with |Dtr|>M; as argued above, once we have |Dtr|≤M for all tr: Q2 →
ρ ρ
[0,K], then |D |≤M ·(K+1)|Q|2 =(K+1)|Q|3+|Q|2, so ρ′ :=ρ fulfils the requirements of
ρ
the lemma. ◀
C From Expressions to Containers: Proofs for Section 5
▶ Lemma 18. Let n ,n ,M ,M ∈ N. If n ≤ n and M ≤ M , then every (n ,M )-
1 2 1 2 1 2 1 2 1 1
container is a union of (n ,M )-containers.
2 2
Proof. First, we show that every n -box is a union of n -boxes. Let γ,χ∈Γ and d,d′ ∈D
1 2
with ⌈γ,d⌉n2 =⌈χ,d′⌉n2. For every state q, there are either at least n
2
agents with datum d
in γ and at least n agents with datum d′ in χ, in which case there are at least n agents in
2 1
both, or the two numbers are the same.
As a result, ⌈γ,d⌉n1 =⌈χ,d′⌉n1. Hence, the partition of Γ×D induced by n 2-boxes is at
least as fine as the one induced by n -boxes.
1
Now let γ,χ ∈ Γ such that ⌈γ⌉n2,M2 = ⌈χ⌉n2,M2. We show that ⌈γ⌉n1,M1 = ⌈χ⌉n1,M1.
Let b∈Boxes . Then b is a union of n -boxes b ,...,b . If one of the two configurations
n1 2 1 k
has less than M data mapped to b, then, as M ≥M , it has less than M data mapped to
1 2 1 2
each b . As a consequence, the other configuration has the same number of data mapped to
i
each b , and thus the same number of data mapped to b.
i
This shows that (n ,M )-containers form a partition of Γ that is at least as fine as
2 2
(n ,M )-containers, concluding our proof. ◀
1 1
C.1 Proof of Proposition 19 and Comparison Between Sizes of
Representations
▶ Proposition 19. The sets of configurations defined by interval predicates of height at most
n and width at most M are exactly the sets formed by unions of (n,M)-containers.
We start with the translation from interval predicates to containers. First, in Lemma 28,
we show that a simple interval predicate of height n and width M cannot distinguish
configurations that are equivalent with respect to ≡ . Then, in Lemma 29, we use this
n,M
fact to prove that an interval predicate of height n and width M can be translated into a
union of (n,M)-containers.
▶Lemma 28. Let n,M ∈N, and let γ,χ be configurations such that γ ≡ χ. Furthermore,
n,M
let ψ be a simple interval predicate of height at most n and width at most M. Then γ satisfies
ψ if and only if χ does.28 Verification of Population Protocols with Unordered Data
Proof. Letψ =∃˙d ,...,d , V VM #(q,d )∈[A ,B ]beasimpleintervalpredicate
1 M q∈Q j=1 j q,j q,j
of height n and width M.
Suppose γ satisfies ψ. Then there are pairwise distinct data d ,...,d such that for all
1 M
q ∈Q and j ∈[1,M], it holds that γ#(q)∈[A ,B ].
dj q,j q,j
Let b be an n-box, and let d ,...,d be the pairwise distinct data among (d )
b,1 b,kb i 1≤i≤M
with ⌈γ,d ⌉n =b. As k ≤M and γ≡ χ, there are pairwise distinct data d′ ,...,d′
i b n,M b,1 b,kb
such that ⌈χ,d′ ⌉n =b for all j ∈[1,k ]. By doing this for every n-box, we obtain pairwise
b,j b
distinct data d′,...,d′ such that (γ,d )≡ (χ,d′) for all i ∈ [1,M]. Moreover, for all
1 M i n i
i∈[1,M],sinceA ,B ∈[0,n]∪{+∞},andsinceγ#(q)∈[A ,B ]and(γ,d )≡ (χ,d′),
q,i q,i di q,i q,i i n i
we have χ#(q)∈[A ,B ].
d′ q,i q,i
This shoi ws that χ satisfies ψ. The other direction follows by symmetry. ◀
▶Lemma 29. Let φ be an interval predicate of height at most n and width at most M. Then
φ is a union of (n,M)-containers.
P
(cid:74) (cid:75)
Proof. Let γ,χ be configurations such that γ≡ χ. By definition, φ is a Boolean combina-
n,M
tion of simple interval predicates ψ ,...,ψ for some p∈N. Furthermore, by Lemma 28, for
1 p
every i∈[1,p], the predicate ψ is satisfied by γ if and only if it is satisfied by χ. Thus, φ is
i
satisfied by γ if and only if it is satisfied by χ.
As a result, we obtain that each equivalence class of ≡ (i.e., each (n,M)-container) is
n,M
either fully contained in φ or disjoint from it. Since (n,M)-containers form a partition of
P
the set of configurations,(cid:74) th(cid:75) is implies the statement of Lemma 29. ◀
The next result takes care of the other direction of the proof of Proposition 19. That is,
weshowthatanyfiniteunionof(n,M)-containerscanbeexpressedasanintervalpredicateof
heightnandwidthM. Combinedwiththefirstdirection,thisshowsthatthetwoformalisms
are equally expressive.
▶ Lemma 30. Let cont ,...,cont be sets of configurations such that for all i, cont is an
1 k i
(n ,M )-container. Then there is an interval predicate of width max n and height max M
i i i i i i
that defines the set
Sk
cont .
i=1 i
Proof. As interval predicates are closed under disjunction, we only need to show that every
(n,M)-container can be expressed as an interval predicate of width n and height M.
Let cont be an (n,M)-container. We construct an interval predicate expressing the same
set of configurations. Let b be an n-box, and let m∈N. We set
m
φ :=∃˙d ,...,d , ^ ^ #(q,d )∈[A ,B ]
b,≥m 1 m j q,j q,j
q∈Qj=1
where for all q ∈Q and j ∈[1,m], we set A :=b(q), and we set B :=b(q) if b(q)<n
q,j q,j
and B :=+∞ otherwise. This simple interval predicate expresses that there are at least
q,j
m pairwise distinct data that match the n-box b. Let
^ (cid:0) (cid:1) ^
ψ := φ ∧¬φ ∧ φ .
cont b,≥cont(b) b,≥cont(b)+1 b,≥M
b∈Boxesn b∈Boxesn
cont(b)<M cont(b)=M
This interval predicate expresses that for every n-box b, the number of data mapped to
b matches the corresponding number in cont, or that the number of data mapped to b is
at least M if the corresponding number in cont is M. Hence, the interval predicate ψ is
cont
satisfied by a configuration γ if and only if γ ∈cont. ◀S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 29
▶ Remark 20. Containers can be exponentially more succinct than interval predicates, while
interval predicates can be doubly exponentially more succinct than unions of containers.
Proof. Toseethis,supposewewanttoexpressthatthereareexactly2k−1datathatallhave
one agent in q and no agents in q . This can be expressed with a (2,2k)-container (whose
1 0
binary encoding uses O(k) bits for each number). Meanwhile, this cannot be expressed by a
union of (n,M)-containers with M < 2k, as they cannot distinguish a configuration with
2k−1 such data from one with more than 2k−1. By the proposition above, this means that
an interval predicate for this set requires width 2k, and thus its encoding must be of size
Ω(2k) (as we must have at least this many data variables).
Conversely, consider the set of configurations containing at least one agent in state q.
This is expressible by a trivial interval predicate, but it corresponds to the union of all
(1,1)-containers cont such that cont(b)>0 for some box b with b(q)>0. One can show that
there are 22|Q| −22|Q|−1 such containers. ◀
C.2 Proof of Lemma 22
Recallthatwechosef: N→Nandg: N2 →Ntobethefunctionswithf(n):=(n+|P|3)·|P|
and g(n,M):=(cid:0) M +(|P|3+1)|P|3+|P|2(cid:1) (n+1)|P|. for all n,M ∈N
▶ Lemma 22. For all n,M ∈ N and all configurations γ ,γ ,χ ∈ Γ, if there is
start end start
∗
a run ρ: γ −→ γ and γ ≡ χ , then there is a configuration χ ∈ Γ
start end start f(n),g(n,M) start end
∗
with γ ≡ χ and a run π: χ −→χ .
end n,M end start end
Proof. By Corollary 17, we can assume that ρ has at most |P|3 observed agents per datum
andatmost(|P|3+1)|P|3+|P|2 externallyobserveddata. LetA andA bethesetsofagents
γ χ
appearing in γ and χ , respectively. Let D and D be their sets of data.
start start γ χ
We are going to define maps µ: D →D and ν: A →A . Intuitively, µ (resp. ν) will
χ γ χ γ
map each datum in D (resp. agent in A ) to a datum in γ (resp. agent in A ) that it
χ χ start γ
should mimic. We will ensure that data and agents are mapped to a counterpart in γ
start
that is “compatible” in the sense that they can mimic that counterpart while keeping the
same initial and final configurations (up to n-approximation for the data). We will also
ensure that µ maps a datum to each externally observed datum in ρ, so that the former can
fulfil the same roles in the run from χ . For the same reason, for each datum d∈D , all
start χ
observed agents in ρ with datum µ(d) must have an agent of χ with datum d mapped to
start
them. We will be able to satisfy these conditions as γ and χ are equivalent up to
start start
sufficient bounds.
The proof is split in three parts. We first prove two claims establishing the existence
of mappings µ and ν with the desired properties. The rest of the proof is dedicated to the
∗
construction of the run π: χ −→χ .
start end
For all b ∈ Boxes and b′ ∈ Boxes , we set Db→ := {d ∈ D | ⌈γ ,d⌉f(n) = b},
f(n) n γ γ start
Db→ := {d ∈ D | ⌈χ ,d⌉f(n) = b}, D→b′ := {d ∈ D | ⌈γ ,d⌉n = b′}, and Db→b′ :=
χ χ start γ γ end γ
Db→∩D→b′.
γ γ
▷ Claim 31. There exists a mapping µ: D →D such that
χ γ
1. for all d∈D , we have (χ ,d)≡ (γ ,µ(d)),
χ start f(n) start
2. for all data d′ ∈D externally observed in ρ, µ−1(d′)̸=∅, and
γ
3. forallb′ ∈Boxes ,wehave|µ−1(D→b′)|=|D→b′|,or|D→b′|≥M and|µ−1(D→b′)|≥M.
n γ γ γ γ30 Verification of Population Protocols with Unordered Data
Proof. Asγ ≡ χ ,weknowthatforallb∈Boxes ,itholdsthat|Db→|=
start f(n),g(n,M) start f(n) γ
|Db→|, or both |Db→| and |Db→| are at least g(n,M).
χ γ χ
In the first case, we let µ map a datum of Db→ to each datum Db→ to form a bijection.
χ γ
Otherwise, in the second case, for each b′ ∈Boxes , if |Db→b′|≤M, then we map a datum
n γ
of Db→ to each datum of Db→b′. If |Db→b′|>M, then we select M data from it, we add all
χ γ γ
those which are externally observed in ρ, and we map a datum of Db→ to each one of them.
χ
As there are at most (|P|3+1)|P|3+|P|2 externally observed data in ρ, we have selected at
most M +((|P|3+1)|P|3+|P|2) data per n-box b′. Further, as |Boxes | ≤ (n+1)|P|, we
n
have selected at most g(n,M) data in total. Hence, we can indeed map a datum of Db→ to
χ
each one of them. As |Db→|≥g(n,M)≥M ·|Boxes |, there exists b′ ∈Boxes such that
γ n n
|Db→b′|≥M. We pick any d∈Db→b′ and map all remaining data of Db→ to d.
γ γ χ
Thisconcludestheconstructionofµ. Itremainstoprovethatµfulfilstherequirementsof
the claim. The first two items follow directly from the definition of µ. Now let b′ ∈Boxes .
n
If |Db→b′| ≤ M for all b ∈ Boxes , then, by definition of µ, |Db→b′| = |µ−1(Db→b′)|
γ f(n) γ γ
for all b∈Boxes . As D→b′ =F Db→b′, we obtain |D→b′|=|µ−1(D→b′)|.
f(n) γ b∈Boxesf(n) γ γ γ
If |Db→b′|≥M for some b∈Boxes , then |µ−1(Db→b′)|≥M by definition of µ. As
γ f(n) γ
Db→b′ ⊆D→b′, we obtain that both |D→b′| and |µ−1(Db→b′)| are at least M.
γ γ γ γ
This concludes the proof of the claim. ◁
We now use similar arguments as above to define the mapping ν. The proof is almost
identical, but we provide it in full to avoid any confusion. For every d ∈ D , we let
χ
A (resp. A ) be the set of agents in A (resp. A ) with datum d. Moreover, for all
γ,d χ,d γ χ
q,q′ ∈Q, we set Aq→ :={a∈A |γ (a)=q}, Aq→ :={a∈A |χ (a)=q},
γ,µ(d) γ,µ(d) start χ,d χ,d start
A→q′ :={a∈A |γ (a)=q′}, and Aq→q′ :=Aq→ ∩A→q′ .
γ,µ(d) γ,µ(d) end γ,µ(d) γ,µ(d) γ,µ(d)
▷ Claim 32. Let µ be the mapping constructed in the previous claim. There exists a
mapping ν: A →A such that, for all d∈D , it holds that
χ γ χ
(A) for all a∈A , we have χ (a)=γ (cid:0) ν(a)(cid:1) ,
χ,d start start
(B) for all observed a′ ∈A , we have ν−1(a′)̸=∅, and
γ,µ(d)
(C) for all q′ ∈Q, we have |ν−1(A→q′ )|=|A→q′ |, or |ν−1(A→q′ )|≥n and |A→q′ |≥n.
γ,µ(d) γ,µ(d) γ,µ(d) γ,µ(d)
Proof. We proceed datum by datum. That is, for each d ∈ D , we define the map ν over
χ
agents in χ with datum d.
start
Let d ∈ D . By Item 1 of Claim 31, we have (χ ,d) ≡ (γ ,µ(d)). Thus, we
χ start f(n) start
know that for all q ∈Q, it holds that |Aq→ |=|Aq→|, or both |Aq→ | and |Aq→| are at
γ,µ(d) χ,d γ,µ(d) χ,d
least f(n). In the first case, we let ν form a bijection between Aq→ and Aq→ . Otherwise,
χ,d γ,µ(d)
in the second case, for each q′ ∈Q, if |Aq→q′ |≤n, then we select |Aq→q′ | agents from Aq→
γ,µ(d) γ,µ(d) χ,d
and let ν form a bijection between them and
Aq→q′
. Otherwise, if
|Aq→q′
|>n, then we
γ,µ(d) γ,µ(d)
select n agents from it, add all those which are observed in ρ, and we let ν be surjective on
this set by picking an agent from Aq→ for every one of them.
χ,d
As there are at most |P|3 observed agents with datum d in ρ (by Corollary 17, as
mentioned at the beginning of the proof), we have selected at most n+|P|3 agents per state
q′. Hence, we have selected at most f(n) agents in total. Thus, we can indeed map an agent
of Aq→ to each one of them.
χ,d
As |Aq→ | ≥ f(n) ≥ n·|P|, there exists q′ ∈ Q such that |Aq→q′ | ≥ n. We pick any
γ,µ(d) γ,µ(d)
a∈Aq→q′ and map all remaining agents of Aq→ to a.
γ,µ(d) χ,dS.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 31
Thisconcludestheconstructionofν. Itremainstoprovethatν fulfilstherequirementsof
the claim. The two first items are immediate from the definition. The third item is obtained
by observing that
if
|Aq→q′
| ≤ n for all q ∈ Q, then
|ν−1(Aq→q′
)| =
|Aq→q′
| for all q, and thus
γ,µ(d) γ,µ(d) γ,µ(d)
|ν−1(A→q′ )|=|A→q′
|, and
γ,µ(d) γ,µ(d)
if
|Aq→q′
| ≥ n for some q ∈ Q, then
|ν−1(Aq→q′
)| ≥ n, and thus both
|ν−1(A→q′
)|
γ,µ(d) γ,µ(d) γ,µ(d)
and
|A→q′
| are at least n.
γ,µ(d)
This concludes the proof of the claim. ◁
∗
In the remainder of the proof, we construct a run π: χ −→χ with χ ≡ γ
start end end n,M end
as required in the statement of the lemma. For that, we decompose ρ into steps ρ =
γ → γ → ··· → γ , with γ = γ and γ = γ . By induction, we construct a
0 1 m 0 start m end
sequence of configurations χ ,...,χ and runs π ,...,π such that, for all i ∈ [0,m], we
0 m 1 m
have γ (cid:0) ν(a)(cid:1) =χ (a) for all a∈A and, for all j ∈[1,m], it holds that π : χ −→∗ χ .
i i χ j j−1 j
(cid:0) (cid:1)
We start by setting χ :=χ . By Item (A) of Claim 32, we have γ ν(a) =χ (a) for
0 start 0 0
all a. Now assume we constructed χ and π for all i ≤ k for some k < m. We construct
i i
χ and π as follows. Consider the step γ →γ , and let δ =q −▷◁ −q →o q′ be the used
k+1 k+1 k k+1
transition, let aγ be the observing agent, and let aγ be the observed agent in that step. Let
o
{aχ,...,aχ}:=ν−1(aγ). Note that µ(dat(aχ))=dat(aγ) for all those agents.
1 p j
If ▷◁ is =, then dat(aγ) = dat(aγ). Let {d ,...,d } := µ−1(dat(aγ)). By Item (B) of
o 1 r o
Claim32,forallℓ∈[1,r],sinceaγ isobservedinρ,thereexistsaχ suchthatν(aχ )=aγ
o o,ℓ o,ℓ o
and dat(aχ ) = d . By the induction hypothesis, for all ℓ, we have χ (aχ ) = γ (aγ),
o,ℓ ℓ k o,ℓ k o
and for all j, we have χ (aχ) = γ (aγ). Thus, for every ℓ ∈ [1,r] and sequentially for
k j k
▷◁aχ
every j ∈[1,d], we can execute a step −−−o−→,ℓ aχ using transition δ. We call this sequence
j
of steps π , and we call the reached configuration χ .
k+1 k+1
If ▷◁ is ̸=, then dat(aγ) is externally observed in ρ, and by Item 2 of Claim 31, there
o
exists some datum d such that µ(d)=dat(aγ). Furthermore, as aγ is observed in ρ, by
o o
Item(B)ofClaim32,thereexistsaχ suchthatν(aχ)=aγ anddat(aχ)=µ(dat(aγ))=d.
o o o o o
Moreover, for all j, it holds that µ(dat(aχ))=dat(aγ)̸=dat(aγ)=µ(dat(aχ)). By the
j o o
inductionhypothesis,wehaveχ (aχ)=γ (aγ)and,forallj,itholdsthatχ (aχ)=γ (aγ).
k o k o k j k
▷◁aχ
Thus, sequentially for every j ∈[1,p], we can execute a step −−−→o aχ using transition δ.
j
We call this sequence of steps π , and we call the reached configuration χ .
k+1 k+1
It is easy to check that γ (ν(a)) = χ (a) for all a in both cases. This concludes our
k+1 k+1
∗
induction. As a result, we obtain a configuration χ = χ and a run π: χ −→ χ
end m start end
such that γ (ν(a))=χ (a) for all a appearing in χ and i∈[1,m].
i i init
All that is left to do is establish that χ ≡ γ . As a direct consequence of Item (C)
end n,M end
ofClaim32,itholdsthatforalld,wehave(γ ,µ(d))≡ (χ ,d). UsingItem3ofClaim31,
end n end
we obtain that γ ≡ χ , proving the lemma. ◀
end n,M end
We obtain the following analogous statement for Post∗.
▶ Corollary 33. For all n,M ∈ N and all configurations γ ,γ ,χ ∈ Γ, if there is
start end end
∗
a run ρ: γ −→ γ and γ ≡ χ , then there is a configuration χ ∈ Γ
start end end f(n),g(n,M) end start
∗
with χ ≡ γ and a run π: χ −→χ .
start n,M start start end
Proof. This result is obtained by reversing every transition in the IOPPUD, i.e., replacing
every q −▷◁ −q →1 q with q −▷◁ −q →1 q . We can then apply Lemma 22 on the reversed system. ◀
2 3 3 232 Verification of Population Protocols with Unordered Data
C.3 Proof of Proposition 21
▶Proposition 21. There is a polynomial function poly: N→N such that for all IOPPUD P
and GRE E, the set E is a union of
(cid:16) ||E||·(cid:0) poly(|P|)(cid:1)|E| ,||E||poly(|P|)·|E|2(cid:17)
-containers.
P
(cid:74) (cid:75)
Proof. In order to improve the readability of this proof, instead of directly using the bounds
in terms of f(n) and g(n,M), we use two polynomial functions poly ,poly . Although the
1 2
degree of the polynomials will be larger than necessary, the bounds will suffice to prove
ExpSpace membership.
We let poly ,poly : N → N be polynomial functions such that, for all n,M ∈ N with
1 2
n > 0, it holds that f(n) ≤ n·poly 1(|P|) and g(n,M) ≤ M ·npoly 2(|P|). Note that such
functions exist by the definition of f and g. Let poly: N → N,n 7→ poly (n)·poly (n).
1 2
Moreover, letαandβ befunctionswithα(P,E,F):=||E||·poly (|P|)|F| andβ(P,E,F):=
1
||E||poly(|P|)·|F|2 for all protocols P and all GRE E,F.
Foreverysub-expressionF ofE,weprovebyinductionon|F|that F canbedescribed
P
(cid:74) (cid:75)
as a union of (α(P,E,F),β(P,E,F))-containers.
IfF isanintervalpredicatethen,byLemma29, F isaunionof(||F||,||F||)-containers,
P
(cid:74) (cid:75)
and thus, by Lemma 18, it is also a union of (α(P,E,F),β(P,E,F))-containers.
Suppose F = G for some GRE G. By the induction hypothesis, G is a union of
P
(cid:74) (cid:75)
(α(P,E,G),β(P,E,G))-containers, and thus also of (α(P,E,F),β(P,E,F))-containers
by Lemma 18. Since (α(P,E,F),β(P,E,F))-containers form a partition of the set of
configurations,thisshowsthat E isalsoaunionof(α(P,E,F),β(P,E,F))-containers.
P
(cid:74) (cid:75)
If F =G ∪G , then again, by the induction hypothesis and Lemma 18, both G and
1 2 1 P
(cid:74) (cid:75)
G are unions of (α(P,E,F),β(P,E,F))-containers, and so is F .
2 P P
(cid:74) Supp(cid:75) ose F =Pre∗(G) for some GRE G. By the induction hypothes(cid:74) is,(cid:75) G is a union of
P
(cid:74) (cid:75)
(α(P,E,G),β(P,E,G))-containers. We show that for all configurations γ ,γ , if we have
1 2
γ ≡ γ and γ ∈ F , then γ ∈ F . By Lemma 22, it suffices to
1 α(P,E,F),β(P,E,F) 2 1 P 2 P
(cid:74) (cid:75) (cid:74) (cid:75)
show that γ ≡ γ . In the following, we assume that the
1 f(α(P,E,G)),g(α(P,E,G),β(P,E,G)) 2
constant term of poly is positive and that poly does not have any negative coefficients.
1 1
Hence, for all P,E,G, we have α(P,E,G)>0. Then it holds that
f(α(P,E,G))≤α(P,E,G)·poly (|P|)
1
=||E||·poly (|P|)|G|·poly (|P|)
1 1
=||E||·poly (|P|)|G|+1
1
=||E||·poly (|P|)|F|
1
=α(P,E,F)
and
g(α(P,E,G),β(P,E,G))≤β(P,E,G)·α(P,E,G)poly 2(|P|)
=||E||poly(|P|)·|G|2 ·(||E||poly (|P|))|G|·poly 2(|P|)
1
≤||E||poly(|P|)|G|2 ||E|||G|poly(|P|)
≤||E||poly(|P|)|F|2
=β(P,E,F).
Using Lemma 18, we conclude that γ ≡ γ .
1 f(α(P,E,G)),g(α(P,E,G),β(P,E,G)) 2
IfF =Post∗(G)forsomeGREG, weproceedthesamewayasinthepreviouscase, using
Corollary 33 instead of Lemma 22.S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 33
All in all, by induction, this proves that E is a union of (α(P,E,E),β(P,E,E))-
P
containers, which concludes the proof of Propo(cid:74) sit(cid:75) ion 21. ◀
D Decidability and Upper Complexity Bounds: Proofs for Section 6
▶ Proposition 23. The following problem is decidable in PSpace: given a PPUD P, a GRE
E, and a configuration γ described data-explicitly, decide if γ ∈ E .
P
(cid:74) (cid:75)
We prove the following auxiliary result:
▶ Lemma 34. The following problem is decidable in PSpace: given a PPUD P and two
∗
configurations γ ,γ described data-explicitly, decide if γ −→γ .
1 2 1 2
Proof. Let k be the number of data appearing in γ , and m the number of agents in γ .
1 1
All steps preserve the number of data and the number of agents. As a result, the graph of
configurations reachable from γ contains only configurations with k data and m agents; we
1
can look for a path between γ and γ in this graph in PSpace. ◀
1 2
We now prove Proposition 23.
Proof of Proposition 23. By Lemma 34, there exists a polynomial function poly such
reach
that we can check reachability between two configurations represented data-explicitly with k
data and m agents in deterministic space poly (|P|,k,log(m)). We denote the size of
reach
the encoding of a GRE E by |⟨E⟩|.
Let ψ =∃˙d ,...,d , V VM #(q,d )∈[A ,B ] be a simple interval predicate of
1 M q∈Q j=1 j q,j q,j
height n and width M, and let γ a configuration described data-explicitly with k data and
m agents. One can check whether γ satisfies ψ by enumerating all injective mappings from
{d |1≤i≤M} to the data appearing in γ, and checking whether one of them satisfies the
i
interval conditions on the number of agents in each state. This requires polynomial space in
k+log(m)+|⟨ψ⟩|.
Given an interval predicate φ and a configuration γ, it is then straightforward to check
which simple interval predicates appearing in φ are satisfied by γ and infer the satisfaction
of the interval predicate from this, all in polynomial space. Let poly be a polynomial
sat
such that poly (k,log(m),|⟨ψ⟩|) bounds the required space. We define poly(x,y,z,t):=
sat
poly (y,z,t)+poly (x,y,z)+xyz.
sat reach
We proceed by induction on E to show that checking if a configuration γ is in E can
P
(cid:0) (cid:1) (cid:74) (cid:75)
be done in space O |E|·poly(|P|,k,log(m),|⟨E⟩|) , where k and m are the numbers of data
and agents appearing in γ, respectively.
If E is an interval predicate, then we simply evaluate whether γ satisfies it. It is
straightforwardtogetthetruthvalueofeachsimpleintervalpredicateoveraconfiguration
in space poly (k,log(m),|⟨E⟩|), and then infer the satisfaction of the interval predicate
sat
from it.
If E = F, then it suffices to check if γ is in F and reverse the answer, which
P
(cid:74) (cid:75)
requires no extra space. Hence, by the induction hypothesis, we need space at most
|F|·poly(|P|,k,log(m),|⟨E⟩|)≤|E|·poly(|P|,k,log(m),|⟨E⟩|).
If E = F ∪F , then it suffices to check if γ is in F , accept if it is the case, and
1 2 1 P
(cid:74) (cid:75)
erase the previous computation and check if γ is in F otherwise. By the induction
2 P
(cid:74) (cid:75)
hypothesis, the required space is then the maximum of the space required by the two
sub-computations, which is at most |E|·poly(|P|,k,log(m),|⟨E⟩|).34 Verification of Population Protocols with Unordered Data
If E = Post∗(F), then we use the fact that a step of a run never changes the number
of data or the number of agents in a configuration. Hence, γ ∈ E if and only if
P
there exists γ′ with k data and m agents such that γ′ ∈ F a(cid:74) nd(cid:75) γ′ −→∗ γ. Thus,
P
(cid:74) (cid:75)
we can enumerate all configurations with k data and m agents, which requires space
k·|P|·log(m), andcheckforeachoneofthemwhetheritisin F , whichrequiresspace
P
|F|·poly(k,log(m),|⟨F⟩|) by the induction hypothesis. For e(cid:74) ver(cid:75) y such configuration γ′,
we check whether γ is reachable from it, which requires space poly (|P|,k,log(m)).
reach
As a result, we can check whether γ is in E in space |F|·poly(|P|,k,log(m),|⟨F⟩|)+
P
(cid:74) (cid:75)
k·|P|·log(m)+poly (|P|,k,log(m))≤|E|·poly(|P|,k,log(m),|⟨E⟩|).
reach
The case E =Pre∗(F) is analogous to the previous one.
Our induction shows that we can check if γ ∈ E in deterministic space at most
P
|E|·poly(k,|Q|,log(m),|⟨E⟩|). As a result, the probl(cid:74) em(cid:75) at hand is in PSpace. ◀
E Details for Theorem 24
Weproceedbyreductionfromtheproblemoftilinganexponentiallylargegrid. Recallthefol-
lowingdefinitions: Atilinginstanceisatuple(2n,C,T)wheren≥1,C isafinitesetofcolours
with special colour white and T ={t ,...,t }⊆C4 is a finite set of tiles. A tile represents a
1 m
square whose 4 edges have a colour; we write t∈T as t=:(top(t),bottom(t),left(t),right(t)).
The size of the tiling problem is n+|C|+m (implicitly, 2n is encoded in binary). Informally,
the tiling problem asks for the existence of a tiling of the 2n ×2n grid, i.e., a mapping
τ :[0,2n−1]×[0,2n−1]→T where the colours of neighbouring tiles match and the borders
of the grid are white:
▶ Definition 35 ( [27]). The following tiling problem is NExpTime-complete.
Input: A tiling instance (2n,C,T),
Question: Does there exist a tiling, i.e., a mapping τ :[0,2n−1]×[0,2n−1]→T such that:
1. for all i∈[0,2n−1], left(τ(i,0))=right(τ(i,2n−1))=white,
2. for all i∈[0,2n−1],j ∈[0,2n−2], right(τ(i,j))=left(τ(i,j+1)),
3. for all j ∈[0,2n−1], top(τ(0,j))=bottom(τ(2n−1,j))=white,
4. for all i∈[0,2n−2],j ∈[0,2n−1], bottom(τ(i,j))=top(τ(i+1,j))?
This problem is NExpTime-complete [27]. We will therefore provide a polynomial-time
reduction from this problem to the negation of the emptiness problem for GRE.
We use the following notations for interval predicates:
given a state q, Pres(q):=∃˙d, #(q,d)>0 is the simple interval predicate indicating that
q is populated,
given a set of states S ⊆Q, Abs(S):=V (∀˙d, #(q,d)=0)=V ¬(∃˙d, #(q,d)>0)
q∈S q∈S
is the interval predicate indicating that all states in S are empty,
given a state q, Mandatory(q) := V ∀˙d, (#(p,d) = 0∨#(q,d) > 0) is the interval
p∈Q
predicate indicating that all data appearing in the configuration has some agent on q.
E.1 Encoding the Tiling and Checking for Duplicates
Figure 5 displays how one encodes the tiling into a configuration and how one checks for
duplicates. Aduplicate designatesthattwovaluesencodethesametilecoordinates. Figure5a
corresponds to where τ is encoded. We only want E to contain configurations where no
(cid:74) (cid:75)
data type has two agents in the tile type part. To do so, we make it so that, if this conditionS.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 35
is violated, one will be able to cover q . For example, from h (0), there is a transition to q
⊥ 1 ⊥
labelled “h (1),=”, so that a configuration where a datum has agents on both h (0) and
1 1
h (1) will be in Pre∗(Pres(q )). Similarly, we ensure that a datum does not have agents on
1 ⊥
states t and t for i̸=j.
i j
The subprotocol of Figure 5b allows us to enforce that no two data encode the same tile.
We will impose that every datum has at least one agent on D and one on D . q can be
a b ≥3
covered if at least three agents go to the blue part and not to the sink state; therefore, in
ordertoreachaconfigurationcoveringq butfromwhichonecannotcoverq ,oneneedto
dup ≥3
send at most two agents to the blue part. Because the left and the right track must observe
each other with disequality tests, this is in fact only possible with agents of different data,
one in the left track and one in the right track. But then, the two agents can make it all the
way to q if and only if their data have an agent in common on every bit of horizontal and
dup
vertical coordinate which, assuming that they have only one agent per bit, means that the
two data encode the same coordinates. Overall, the predicate that we add to E for the tiling
encoding is E , defined as follows:
encoding
E :=Pre∗(Pres(q ))∩Mandatory(D )∩Mandatory(D )
encoding ⊥ a b
∩Abs(Q ∪Q )∩Pre∗(Pres(q )∩Pre∗(Pres(q )))
blue red dup ≥3
where Q and Q are the states in the blue and red parts, respectively.
blue red
Foraconfigurationγ,letτ(γ):[0,2n−1]2 →2T bethefunctionthat,tox,y ∈[0,2n−1],
maps the set of every t ∈T such that there is a datum d in γ with an agent on t and:
i i
if the i-th bit of x is b then d has an agent in h (b) in γ,
i
if the i-th bit of y is b then d has an agent in v (b) in γ.
i
▶ Lemma 36. For every γ ∈ E , for every i,j ∈[0,2n−1], |τ(γ)(i,j)|≤1.
encoding
(cid:74) (cid:75)
Proof. Let γ ∈ E . Assume by contradiction that we have i,j such that {ti,t } ⊆
encoding j
τ(γ)(i,j) with i(cid:74) ̸=j. Let(cid:75) d (resp. d′) the data witnessing that t∈τ(γ)(i,j). If d=d′ then
there is an agent in t and one in t with same datum, but then one can cover q from
i j ⊥
γ which contradicts that γ ∈ Pre∗(Pres(q )) . If d ̸= d′, because γ ∈ Mandatory(D )∩
⊥ a
Mandatory(D ) , d has an age(cid:74) nt a in D and(cid:75) d′ has an agent a′ in D . (cid:74) By making a and
b a b
a′ evolve in the(cid:75) blue part, taking the values of the bits of x and then y and observing each
other, they can cover q ; by sending all others agents in D and D to sink, we reach a
dup a b
configuration γ′ ∈ Pres(q )∩Pre∗(Pres(q )) , a contradiction. ◀
dup ≥3
(cid:74) (cid:75)
E.2 Verifying that the Encoded Tiling is Valid
We here describe the horizontal verifier, i.e., the part of P responsible for verifying left-
right frontiers of the tiling. The data of agents in this part are irrelevant. Two variables,
x,y ∈[0,2n−1], are encoded in binary in similar fashion to Figure 5a. These two variables
will be private to the horizontal verifier. There will be exactly one agent encoding each bit;
thenoveltywithrespecttoFigure5aisthattheseagentswillbeabletomovebetweenvalues
0 and 1, so that the values of x and y can be changed. The rest of the verifier will contain a
single agent, called the main agent. Under the guarantee that there is only one agent per
bit, the main agent can directly read and modify the values of x and y. For example, to
change bit i of x from 0 to 1, the main agent goes to state x(0→1), the agent of the bit
i
observes it and moves to value 1, the main agent observes this change and continues. We
represent the part of the protocol encoding the behaviour of the main agent in Figure 636 Verification of Population Protocols with Unordered Data
q
≥3
q ≥2,= q ≥2,̸=
q
≥2
q ≥1,= q ≥1,̸=
q
≥1
Tile type
where T =: t ... t
1 m
{t |i∈[1,m]}
i
q
dup
bit 1 h1(0) h1(1) Va(0),̸= Va(1),̸=
n n
Va(0) Va(1)
n n Vb(0) Vb(1)
n n
Horizontal
bit 2 h2(0) h2(1) v n(0),= v n(1),=
coordinate .
.
V nb(0),̸= V nb(1),̸= v n(0),= v n(1),=
.
(repeat test for every bit
bit n hn(0) hn(1) of horizontal and vertical coordinates)
bit 1 v1(0) v1(1) H 1a(0),̸= H 1a(1),̸=
Ha(0) Ha(1)
1 1 Hb(0) Hb(1)
1 1
Vertical
bit 2 v2(0) v2(1) h 1(0),= h 1(1),=
coordinate . . . H 1b(0),̸= H 1b(1),̸= h 1(0),= h 1(1),=
bit n vn(0) vn(1)
D sink D
a b
(a) The part of P encoding the value of (b)Thetestthatnotileisencodedbytwodata. Transitions
τ. Not depicted are the following trans- labelledbytwoobservationsareashortcutfortwochained
ition to q ⊥. For every i ̸= j ∈ [1,m], ti transitions,onewitheachobservation. Ifonlytwoagents
hasatransitiontoq
⊥
labelledtj,=. For withdistinctdatacomeinthebluepart(onefromDa and
everyi∈[1,n]andb∈{0,1},h (b)hasa onefromD ),theywillbeabletocoverq ifandonlyif
i b dup
transitiontoq labelledh (1−b),=;and theirdataencodethesametile. However,ifatleastthree
⊥ i
similarlyfortheverticalcounter. agentsareinthebluepart,thenq canbecovered.
≥3
Figure 5 The part of P encoding the tiling and checking for duplicates.S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 37
colour white
x (cid:0)0
colour white
y(cid:0)0
x (cid:0)0 q(h) (cid:0) colour right(T)
y (cid:0)y+1 i x (cid:0)x+1
(cid:0) T Ti (cid:0)
wher(cid:0)eT(h)
i
populated
checkthat ifx=2n−1 ifx<2n−1 checkthat
left(T)=colour andy<2n−1 andy<2n−1 left(T)=colour
andright(T)=white ifx=2n−1
andy=2n−1 checkthat
right(T)=white
q(h)
f
Figure 6 Thepartoftheprotocolencodingthehorizontalverifier. Thepartsencodingthevalues
ofxandy arenotrepresented. VariablesT andcolourareencodeddirectlyinthestatespace. The
operation “T T where T(h) populated” corresponds to m=|T| transitions in parallel, one for
i i
each t ∈T; ev(cid:0) ery such transition can be taken if an agent on state T(h) is observed. Not depicted
i i
is a gadget that allows to go to q if at least two agents play the role of horizontal verifier or two
⊥
agents play the same bit of x or of y.
where, for simplicity, we abstract bit encoding of x and y into direct access and modification
of the values of x and y by the main agent. The main agent will also manipulate a variable
colour∈C, which can be directly encoded in the state space.
E.3 Synchronisation with the Verifier
Finally, in the gadget represented in Figure 7, each datum will be represented by exactly
one agent, called the reader, which will initially be in S(h). The reader synchronises with
the horizontal verifier in order to let the main agent know what tile type its datum encodes.
The goal of synchronisation is to ensure, in relevant runs, that an agent in the middle part
of Figure 7 has a datum value equal to the current value of z :=x+2ny. The reader wants
to test equality of its own number in [0,22n −1] with z, this number being equal to its
horizontal coordinate plus 2n times the vertical coordinate. However, because the value of z
changes throughout the run, it would not suffice that the reader simply tests equality once
per bit. However, as we will now see, it suffices that the first synchronisation test tests for
equality all bits from most to least significant, and that the second synchronisation test tests
for equality all bits from least to most significant.
▶ Lemma 37. Consider a run where an agent a starts on S(h) and ends on F(h); assume
that its datum faithfully encodes value k ∈[0,2N −1]. Then:
the value of z after the first synchronisation test, which tests bits from most to least
significant, is such that z ≥k,
if we have z >k at the beginning of the second synchronisation test, which tests bits from
least to most significant, then the agent may not cover S(h).
f
Proof. Let N :=2n. In the following, a binary number ℓ∈[0,2N −1] is denoted ℓ ℓ ...ℓ 2
1 2 N
where ℓ ∈{0,1} is the ith most significant bit.
i
We first prove the first claim. Let z(m) the value of z after the m-th most significant bit
istestedinthefirstsynchronisationtest. Weprovebyinductionthatz(m) ≥k ...k 0...02 .
1 m
It is trivially true for m=0. Assume that z(m) ≥k ...k 0...02 : if we have k =0 then
1 m m+138 Verification of Population Protocols with Unordered Data
T(h)
1
=
,
first t 1 second
synchronisation test t ,= synchronisation test
S(h) 2 T(h) F(h)
2
.
t . .
m,
=
T(h)
m
Figure 7 The synchronisation gadget.
we have the property for m+1. If k =1, then the first value greater than z(m) whose
m+1
2
(m+1)-th bit is at least 1 is greater than k ...k k 0...0 , concluding the induction.
1 m m+1
We now prove the second claim. Let z(m) now denote the value of z after the test of
bit N −m+1 in the second synchronisation test; we use convention that z(0) is the value
right before the second synchronisation test, so that by hypothesis z(0) >k. We prove by
inductionthatthereisabitj ≤N−msuchthatbitj hasvalue1inz(m) and0ink whereas
all bits i<j are equal for z(m) and k. This is true for m=0 by hypothesis that z(0) >k.
Assume that it is true for m; if j <N −m−1 then it is true for m+1. Otherwise, we have
j =N −m, but the test of bit j needs z(m) to have value 0 at bit j; this means that there is
a carry between z(m) and z(m+1) that propagates to bit j−1 (and possibly further), proving
the result. For m=N, this yields a contradiction. ◀
E.4 Summary of the Reduction
Theprotocolbuiltisacombinationofallthepartsbuiltpreviously. InAppendixE.1,wehave
definedaGREE that, duetoLemma36, guaranteesthat, inconsideredconfigurations,
encoding
agivencoordinatewillhaveatmostonetiletype. WenowbuildalargerGREthatexpresses
that the horizontal and vertical verifiers are able to verifying the entire grid without anyone
cheating. Overall, the constructed GRE E is the following:
E :=E ∩Pre∗(Pres(q ))∩E(h)∩E(v)∩Pre∗(E(h))∩Pre∗(E(v))
encoding ⊥ init init final final
where:
E(h) expresses that all states in the horizontal synchronisation gadget except S(h) are
init
empty and that all states in the horizontal verifier gadget are empty except q(h) and the
i
states of bits of x and y of value 0,
E(v) is the counterpart of E(h) but for the vertical verifier and vertical synchronisation,
init init
E(h) expresses that q(h) is not empty and that all states in the horizontal synchronisation
final f
gadget are empty except F(h),
E(v) is the counterpart of E(h) but for the vertical verifier and vertical synchronisation.
final final
▶ Lemma 38. If E is not empty, then the instance of the tiling problem is positive.
(cid:74) (cid:75)
Proof. Let γ ∈ E . Due to Lemma 36, we have that |τ(γ)(x,y)|≤1 for every x and y; let
τ :[0,2n−1]2 →(cid:74) T(cid:75) ∪{∗} be the function that to (x,y) maps the only element in τ(γ)(x,y)
if it exists.S.vanBergerem,R.Guttenberg,S.Kiefer,C.Mascle,N.Waldburger,C.Weil-Kennedy 39
We will prove that τ is never equal to ∗ and that it is in fact a tiling. We will prove that
the horizontal colours match, i.e., that τ satisfies Item 3 and Item 4 of Definition 35; the
vertical case is very similar.
Let γ′ such that γ −→∗ γ′ and γ′ ∈ E(h) . By definition of E(h), there is in γ′ one agent a
final final
in q(h). In fact, a is the only agent in(cid:74) the m(cid:75) ain part of the horizontal verifier in both γ and
f
γ′, as otherwise γ would be in Pre∗(Pres(q )) . We know that a is in state q(h) in γ as all
⊥ i
other states are forbidden by
E((cid:74)h).
There is
at(cid:75)
least one agent encoding each bit of x and y,
init
otherwise a would not be able to go from q(h) to q(h); there is also at most one agent per bit,
i f
as otherwise one would be able to cover q from γ. Therefore, one can consider that x and y
⊥
are encoded reliably; to enforce that, initially, x=y =0, we can either encode it into E(h) or
init
make the main agent perform an initial sequence of transitions setting the variables to the
right values.
In the run from γ to γ′, z :=x+2ny has to go incrementally from 0 to 22n−1. Moreover,
whenever the transition updated the value of T is taken, we claim that the value T taken is
i
such that τ(x,y) = t (with x and y the values when the transition is taken). Indeed, let
i
x,y ∈[0,2n−1] and assume that some agent a is observed on T(h) by a with these values
syn i
of x and y. Because of E(h) and E(h), we know that a is in S(h) in γ and in F(h) in γ′.
init final syn
Let z :=x+2ny. Let d denote the datum of a in γ. Because one cannot cover q from γ,
syn ⊥
d has at most one agent in every bit of the horizontal and vertical coordinates. Moreover,
since a manages to pass the synchronisation tests, there is exactly agent with datum d
syn
one per bit. Let x and y the values encoded by agents of d; let z :=x +y . Because a
d d d d d syn
passes the two synchronisation test, by Lemma 37 we must have z =z hence τ(x,y)=t .
d i
We have proven that, when the verifier takes the transition observing state T(h), the
i
value observed indeed corresponds to τ(x,y)∈T. We conclude that, because the main agent
of the horizontal verifier ends on q(h), τ satisfies Item 3 and Item 4 of Definition 35. We can
f
similarly prove that τ also satisfies Item 1 and Item 2, proving that τ is a witness that our
instance of the tiling problem is positive. ◀
▶ Lemma 39. If the instance of the tiling problem is positive, then E ̸=∅.
(cid:74) (cid:75)
Proof. Let τ be a witness that the instance is positive. Let γ be a configuration whose
appearing data are in the set {d |i,j ∈[0,2n−1]} and, for every i,j ∈[0,2n−1]:
i,j
in the states of Figure 5a, d has exactly 2n+1 agents: n agents encoding the value of
i,j
i in the “horizontal coordinate” part, n agents encoding the value of j in the “vertical
coordinate” part and one agent in the “tile type” part, on the state corresponding to
τ(i,j);
in the states of Figure 5b, d has two agents: one on D and one on D ;
i,j a b
d has one agent on S(h) and one agent on S(v), and none in the rest of the horizontal
i,j
and vertical synchronisation gadgets;
d has agents in the horizontal and vertical verifier if and only if i=j =0; d has one
i,j 0,0
agent on q(h), one agent on q(v) and 4n agents on bits of value 0 of the four variables
i i
of the verifiers (variables x and y of the horizontal verifier and variables x and y of the
vertical verifier, which are distinct although, for ease of notation, we never distinguished
them above).
Because γ does not have two data with the same coordinates, one cannot cover q from γ
dup
without putting at least three agents in the blue part, which would in turn allow reaching
q . This proves that γ ∈Pre∗(Pres(q )∩Pre∗(Pres(q ))). It is quite easy to prove that
≥3 dup ≥340 Verification of Population Protocols with Unordered Data
γ ∈E and also that γ ∈Pre∗(Pres(q ))∩E(h)∩E(v). It finally remains to show that
encoding ⊥ init init
γ ∈Pre∗(E(h) ∩E(v)). To do so, we consider the execution where the horizontal and vertical
final final
verifiers go through all tiles one by one, synchronising with the right agents every time; this
execution exists because τ satisfies all four conditions from Definition 35. Overall, we have
γ ∈ E which proves E ̸=∅. ◀
(cid:74) (cid:75) (cid:74) (cid:75)
With Lemmas 38 and 39, we have built a polynomial-time reduction from the tiling
problem to the negation of the emptiness problem for GRE, which shows that the emptiness
problem is coNExpTime-hard.
E.5 Proof of Claim 25
We formalise Claim 25 into the following proposition:
▶ Proposition 40. For every n∈N, there is a protocol P of size polynomial in n that is not
n
well-specified but in which all fair runs from configurations with less that 2n data stabilise to
0.
Proof. For every n, we build a protocol P with states q and q such that:
n ⊥ f
from every initial configuration, P has a run stabilising to ⊥;
n
Q\{q } has output ⊥, q has output ⊤,
f f
an agent on q attracts agents on any other state,
⊥
an agent on q attracts agents on any other state except q .
f ⊥
Here, we say that an agent on state q attracts agents in state q′ when there is a transition
from q′ to q that observes the agent on q. This implies that, in a fair execution, if q is
populated infinitely often then eventually all agents move from q′ to q. The protocol P is a
n
simplified version of the protocol from Theorem 24. There are 2n encoding states, allowing
to encode in binary a number in [0,2n−1]. Each datum must have at most one agent per
bit, otherwise by fairness q is eventually covered. In a separate gadget, a verifier is able to
⊥
cover q only after checking that, for every value in [0,2n−1], there is a datum encoding
f
this value. This uses the same two ideas as in Theorem 24. First, the verifier manipulates
a variable x ∈ [0,2n−1] implemented using another gadget and n agents. Second, there
is a synchronisation gadget that makes sure that the verifier only interacts with a datum
encoding the current value of x. For this second point, there is a non-guarded transition
from q to q for every state q of the synchronisation gadget except its last state. This
⊥
guarantees that, eventually, all agents in the synchronisation gadget have successfully passed
both synchronisation tests. Again, if two agents play the same role, q is eventually covered.
⊥
Inordertostabiliseto⊤,oneneedsonedatumforeachvaluein[0,2n−1],hence2n data. ◀