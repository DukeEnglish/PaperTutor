QRtree - Decision Tree dialect specification of
QRscript
(Version 0.9)
March 8, 2024
This document [1] reports the specifications of QRtree, a specific dialect of
QRscript that can be used for the inclusion of decision trees (or other similar
high-level languages) within a QR code. A QR code containing an executable
code is called an executable QR code (eQR code). QRscript is a series of rules
on how to embed a programming language into a QR code in order to obtain an
eQR code.
Authors of this specification document are:
• StefanoScanzio(CNR-IEIIT,https://www.skenz.it/ss,stefano.scanzio[at]cnr.it)
• Matteo Rosani (matteo.rosani[at]gmail.com)
• Mattia Scamuzzi (mattia.scamuzzi[at]gmail.com)
• Gianluca Cena (CNR-IEIIT, gianluca.cena[at]cnr.it)
1
4202
raM
7
]IN.sc[
1v61740.3042:viXraContents
1. Scope 4
2. Conformance 4
3. Normative References 4
4. Overview 5
5. QRScript and Dialects 7
6. QRtree dialect 8
6.1. Data types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
6.1.1. String: ASCII-7, UTF-8 and DICT . . . . . . . . . . . . . . . . . . . 8
6.1.2. Integer: INT16 and INT32 . . . . . . . . . . . . . . . . . . . . . . . . 12
6.1.3. Real: FP16 and FP32 . . . . . . . . . . . . . . . . . . . . . . . . . . 13
6.2. QRtree header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
6.2.1. HEADER_END (000) . . . . . . . . . . . . . . . . . . . . . . . . . . 13
6.2.2. INT_TYPE (001) and FLOAT_TYPE (010) . . . . . . . . . . . . . 13
6.2.3. DICT_TYPES (011) . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
6.2.4. DICT_SPEC_TYPE (100) . . . . . . . . . . . . . . . . . . . . . . . 14
6.2.5. DICT_LOCAL (101) . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
6.2.6. USER_DEF (110) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
6.3. Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
6.3.1. Direct and indirect input . . . . . . . . . . . . . . . . . . . . . . . . . 16
6.3.2. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
6.3.3. input (000) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
6.3.4. inputs (001) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
6.3.5. print (010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
6.3.6. printex (011) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
6.3.7. goto (100) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
6.3.8. if (101) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
6.3.9. ifc (110) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
7. Sample implementation 23
8. Main terms and acronyms 23
2A. Definition of global and specific dictionary 26
B. Example of QRtreebytecode generation 27
C. Exponential encoding of an integer number 31
3QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
1. Scope
This specification document specifies the syntax and semantics of QRtree, which is a specific
dialect of QRscript particularly suited to represent decision trees without chance nodes. The
term “dialect” identifies one of the possible sub-languages that can be encoded inside of an
eQR code via QRscript.
This specification will describe an intermediate representation of QRtree, made through
a language derived by the three-address code. It will then define the transformation rules
from the intermediate representation to a binary code. The latter is a binary representa-
tion called eQRtreebytecode. These rules can also be applied inversely to transform the
eQRtreeBytecode into the intermediate representation.
This specification document will pay particular attention to the creation of a compact
eQRtreebytecode, as the maximum number of bits that can be stored in a QR code is, at the
time of writing, equal to 2953 bytes (in the case of QR code version 40 with a “low” error
correction level).
2. Conformance
A completely conforming implementation of QRscript must provide and support all the
functionalities mandated in this specification. The word must highlights these mandatory
specifications. Some specific names that are important in this specification were highlighted
in italic.
3. Normative References
The following referenced documents are indispensable for the application of this document.
For dated references, only the edition cited applies. For undated references, the latest edition
of the referenced document (including any amendments) applies.
1. The QR code standard, ISO/IEC 18004:2015 [2]
2. The UTF-8 standard, RFC 3629 [3]
3. The ISO 7-bit coded character, ISO/IEC 646, [4]
4. Floating-point arithmetic standard, IEEE Std 754, [5]
4QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
4. Overview
This document specifies how to include a program that complies with the QRtree dialect
into an eQR code.
The possibility to insert a programming language inside a QR code and, particularly,
the basis of the QRtree dialect presented in this specification were first and preliminarily
presented in [6].
The whole utilization chain of this technology can be schematized as shown in Fig. 1 in
which the process is divided into a generation phase and an execution phase.
Source
Interpreter
Language
1 6
Intermediate Intermediate
Representation Representation
2 5
3 4
Bytecode Bytecode
Generation Execution
Figure 1: Chain of usage of eQR code technology (generation and execution phases)
The generation phase leads to the creation of the eQR code, and it is detailed below:
1. A high-level language (Source Language) is translated into an intermediate represen-
tation (Intermediate Representation). It does not matter which high-level language is
used as it is not the topic of this specification document. Different high-level languages
can be translated to the same intermediate representation.
5QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
2. The intermediate representation is translated to a binary representation (Bytecode)
named eQRbytecode.
3. The eQRbytecode is transformed into an eQR code containing the bytecode.
The execution phase leads to the reading of the eQR code and its usage, and it is detailed
below:
4. The eQR code is read and transformed in eQRbytecode.
5. The eQRbytecode is converted into an intermediate representation
6. The intermediate representation is executed inside of a virtual machine on board the
end-user device. An end-user device is any apparatus capable of executing the virtual
machine (i.e., a smartphone, a PC, an embedded device, etc.)
The QRtree specification concerns the definition of the binary code that must be saved
within the eQR code, and in particular, the part related to the QRtree dialect of QRscript.
These specifications correspond to arrows 2 and 5 of Fig. 1, with the exclusion of the QRtree
header, which is detailed in the relevant specification document [7]. In addition, the same
specification document details the main characteristics regarding arrows 3 and 4 of Fig. 1.
Arrows 1 and 6 are not subject to the specification but have been shown in Fig. 1 to give a
general idea of the applicability of the technique.
In particular, among the parts described in this QRtree specification document, there is an
intermediate (low-level) language, similar to three-address code, which allows the coding, in
a simplified way, of decision trees without chance nodes. Chance nodes are particular nodes
of a decision tree that permit the coding of probabilistic decisions. QRtree is not limited to
the representation of decision trees, but more generally, all the possible high-level languages
that can be transformed into the intermediate representation are possible candidates.
This specification defines and details all the commands available in the intermediate rep-
resentation, the rules for converting them into the QRtreebytecode binary code, and the
format that must be used to form the QRtreebytecode.
The following Section 5 will describe the headers definable in the QRbytecode, which,
among other things, identify the dialect and allow reading more than one eQR code. This
last possibility was inserted to try to mitigate the limitation of the amount of data that can
be stored within an eQR code. Section 6 will define all the specific details of QRtree.
6QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
5. QRScript and Dialects
The first part of the QRbytecode containing the QRtree dialect follows the specifications
defined in the specification document of QRscript [7], and it is named QRscript header. It
encodes five aspects. The first is related to the padding that is used to make the length of
the QRbytecode multiple of 8 bits, which is needed if the binary input mode is used for the
generation of the eQR code. The second is the continuation, which allows the reading of
more than one eQR code in order to try to mitigate the limitation of the amount of data that
can be stored within an eQR code. The third is related to security by defining a security
profile that identifies which security mechanisms are used to protect the eQR code data. The
fourth is related to a URL to be accessed in order to enhance the functionalities of the eQR
code by executing a remote resource if a connection is available. The fifth and last aspect is
the identification of the dialect (QRtree in the case of this specification document).
In particular, a QRbytecode starts with a 1 in the case the padding is not present, with
the sequence 01 for 1 bit of padding, with the sequence 001 for 2 bit of padding, with the
sequence 0001 for 3 bit of padding, and so on. Then, the next bit is 0 in case all the
QRbytecode can be stored within a single eQR code. Alternatively, the bit is equal to 1,
and the next four bits represent a sequence number assigned to a specific eQR code, and
the other four bits represent the sequence length. These two groups of 4 bits are extensible
following the exponential encoding described in Appendix C. During the reconstruction of
the QRbytecode, the application that performs the reading can use the sequence numbers
to concatenate the binary code contained in the various eQR codes in the correct order.
After the bits related to the continuation, there are 4 bits that identify the security profile
with possibly some extra information like a digital signature. The security profile number
0000 corresponds to no security. This group of 4 bits is extensible following the exponential
encoding described in Appendix C.
After the bits related to security, there is 1 bit to signal the presence of a URL. If the
bit is set to 1, the following bytes identify a URL string encoded in UTF-8 [3] using the
end-of-text (EXT) character at the end of the string, corresponding to the sequence of bits
00000011; otherwise, if the bit is set to 0 the URL is not present.
After the bits related to the URL, there are 4 bits that identify the dialect. This group of 4
bits is extensible following the exponential encoding described in Appendix C. In particular,
for the QRtree dialect, these bits are set to 0000.
7QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
QRscript header 0/1 QRtree header Code
Figure 2: Binary format of the eQR code (i.e., QRbytecode)
6. QRtree dialect
The QRtreebytecode can be divided into two sections: QRtree header, which is optional and
is described in Subsection 6.2, and code, which is described in Subsection 6.3. The imple-
mentation of the header and of the dictionary, which will be explained next, are optional.
Although their implementation is highly recommended, a compliant implementation of this
specification document may not include these two features. Fig. 2 outlines the structure of
how binary code is stored within an eQR code. In particular, after the QRscript header,
there is a bit that, if set to 1, identifies the presence of a QRtree header, which is optional.
The QRtree header is then followed by the actual code, which contains the instructions of
the program that is coded into the eQR code.
Before the description of the QRtree header and the code, the next Section 6.1 describes
the data types available in the QRtree dialect, and some indications on how they are coded
in the QRtreeBytecode.
6.1. Data types
Theconstantdataformats(literals)thatcanbeusedinQRtreearestrings, integers numbers,
and real numbers.
6.1.1. String: ASCII-7, UTF-8 and DICT
The encoding of the string type is very important because this type of data is widely used
in decision trees, but it also occupies a lot of space; for this reason, three different encodings
havebeenproposed,inwhichthefirst2bitsidentifythetypeofencodingused: 00(ASCII-7),
01 (UTF-8), 10 (DICT), while 11 has been left free for future use.
• ASCII-7
8QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
The ASCII-7 encoding [4] is identified by the bit sequence 00, followed by the sequence
of characters that make up the string, and terminated by an end-of-string character.
The chosen end-of-string character is end-of-text (EXT) composed of the following
bits 0000011. The ASCII-7 encoding allows encoding a character in only 7 bits, but
obviously, the kind of representable characters is limited. For example, the encoding
of accented characters is not supported.
• UTF-8
The UTF-8 encoding [3] is identified by the bit sequence 01 followed by the sequence
of characters that make up the string, and terminated by an end-of-string character.
The chosen end-of-string character is end-of-text (EXT) composed of the following bits
00000011. The UTF-8 encoding allows encoding a much wider character set than
ASCII-7. Furthermore, the encoding of characters with a minimum of 8 bits allows the
encoding of other characters, for example, ideographic codes, with a greater number
of bits (up to 4 bytes per character).
• DICT
The DICT type is intended for the use of predefined strings in order to save space.
Rather than memorizing the string inside the eQR code, the string is identified with a
reference that occupies far less space. In particular, the following three types of DICT
strings are identified: global, specific, and local. The global type strings are defined
outside eQR codes because they are not specific for the application, but they are so
general that they are effective for a multitude of applications (e.g., “yes”, “no”, etc.).
Also, the specific type strings are defined outside eQR codes, but they are specific for
an application. The selection of the specific dictionary to be used is done in the QRtree
header viatheDICT_SPEC_TYPEcommand(seeSubsection6.2.4fordetails). Bothglobal
and specific dictionaries are defined using JSON, following the specifications described
in Appendix A. In particular, URLs containing the global dictionary and potentially
one or more specific dictionaries in JSON format are saved inside the application. In
Appendix A, a simple example of a global dictionary is reported. In case multiple
specific dictionaries are present, the DICT_SPEC_TYPE command specifies the number
of the dictionary to be used based on the loading order (e.g., number 0 for the first
specific dictionary loaded, number 1 for the second specific dictionary loaded, etc.).
It is possible to load more specific dictionaries using the DICT_SPEC_TYPE command
multiple times in the QRtree header; in this case, inside the eQR code, it is possible to
use multiple specific dictionaries, and a particular notation could be used for the DICT
type. In order to select the right specific dictionary to be used between the loaded ones,
see further on in this paragraph. With regard to the local type dictionary, it is defined
9QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
inside the QRtree header using the DICT_LOCAL command (see Subsection 6.2.5 for
details). As strings occupy a lot of space, attention is needed in defining as local
only the ones that appear more frequently in the eQR code. The definition of the
local dictionary or a part of it can be automated through a tool that automatically
analyses strings appearing in the eQR code, and places in the local dictionary more
frequent ones. In case dictionaries contain multiple languages, the application will
select the dictionary for the language with which the application has been configured.
If the language is not present in the dictionary, the application will select the default
dictionary, for example, the one for the English language. In this case, the application
is in charge of setting the default dictionary. If the default dictionary is not set, the
application selects the first that has been defined for the specific type that is selected
(i.e., global, specific, or local).
10QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
Table 1: Bits used to identify the type of dictionary (global, local, specific). The symbol -
indicates that this type of dictionary cannot be used, while the symbol * indicates
that the dictionary can be used without writing any bits because it is the only
dictionary type configured for that specific eQR code. The default configuration is
DICT_GLOBAL, DICT_SPEC and NO_DICT_LOCAL
Dictionary global specific local
Options
DICT_GLOBAL
DICT_SPEC 00 01 1
DICT_LOCAL
NO_DICT_GLOBAL
NO_DICT_SPEC - - -
NO_DICT_LOCAL
DICT_GLOBAL
NO_DICT_SPEC 0 - 1
DICT_LOCAL
NO_DICT_GLOBAL
DICT_SPEC - 0 1
DICT_LOCAL
DICT_GLOBAL
DICT_SPEC 0 1 -
NO_DICT_LOCAL
DICT_GLOBAL
NO_DICT_SPEC * - -
NO_DICT_LOCAL
NO_DICT_GLOBAL
DICT_SPEC - * -
NO_DICT_LOCAL
NO_DICT_GLOBAL
NO_DICT_SPEC - - *
DICT_LOCAL
The DICT type is identified by the sequence of bits 10. The next bits, named dictio-
nary_type, refer to the type of dictionary (global, specific or local), and the number and
11QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
DICT Type Word
1 0 0 0 1 0 1 1 1
1 0 0 1 1 0 1 1 1 1
1 0 1 1 0 1
Figure 3: Binary format of DICT data type
typeofbitstousedependsontheconfigurationofsomeconstantsintheQRtreeheader,
as shown in Table 1. In particular, the default configuration, which is DICT_GLOBAL,
DICT_SPEC and NO_DICT_LOCAL, identifies the presence of a global and a specific dic-
tionary, and the absence of a local dictionary. If a local dictionary is defined using
the DICT_LOCAL command (Subsection 6.2.5), the DICT_LOCAL constant is activated.
Instead, the command DICT_TYPES (Subsection 6.2.3) can be used to disable the global
dictionarybysettingtheNO_DICT_GLOBALconstantorthespecific dictionary,bysetting
the NO_DICT_SPEC constant.
Finally, the last bits of the DICT type represent the word contained inside the dictio-
nary that was selected using the previous bits (i.e., global, specific, or local). The word
is selected using its position inside the dictionary, with a number of bits equal to the
minimum number of bits necessary to encode all the words inside the selected dictio-
nary. For example, if the dictionary contains 23 words, the words will be encoded and
referred to using 5 bits. The number 0 corresponds to the first word. In case multiple
dictionaries of type specific are present at the same time, they are concatenated in the
order in which the DICT_SPEC_TYPE commands appear and, as in the previous case,
the word is selected using its position within the specific dictionaries concatenation,
using a number of bits equal to the smallest number of bits used to encode all the
words within the concatenation of dictionaries of type specific.
6.1.2. Integer: INT16 and INT32
Both INT16 and INT32 are encoded with the two’s complement [8] format on 16 and 32
bits, respectively.
12QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
6.1.3. Real: FP16 and FP32
The FP16 format encodes the real number on 16 bits using the half-precision floating-point
encoding according to the IEEE Standard for Floating-Point Arithmetic (IEEE 754) [5],
which consists of 1 sign bit, 5 exponent bits, and 10 fraction bits. The FP32 format encodes
the real number on 32 bits using the single-precision floating-point encoding according to
the IEEE Standard for Floating-Point Arithmetic (IEEE 754) [5], which consists of 1 sign
bit, 8 exponent bits, and 23 fraction bits.
6.2. QRtree header
After the general QRscript header, there is optionally a QRtree header. In order to identify
the presence of this header, the first bit of the QRtreebytecode (the one between the finish of
the QRscript header and the beginning of the QRtree header) is 1; alternatively, that bit is
set to 0 to notify the absence of a QRtree header.
In case the QRtree header is present, the following bits represent the contents of the
header, which consists of a series of commands encoded on 3 bits. The 110 code has not yet
been associated with any specific command and can be used freely. This group of 3 bits is
extensible following the exponential encoding provided in Appendix C.
6.2.1. HEADER_END (000)
The HEADER_END command, encoded with the 000 code, identifies the end of the QRtree
header. In particular, a QRtree header is a list of commands, and since there is no indication
of the number of commands present in the QRtree header, the command HEADER_END is used
in order to identify the end of this list.
6.2.2. INT_TYPE (001) and FLOAT_TYPE (010)
The commands INT_TYPE, identified by the code 001, and FLOAT_TYPE, identified by the
code 010, are used to define the storing dimensions for integer and floating point numbers,
respectively.
In particular, regarding the INT_TYPE instruction, if the following bit is set to 0, all the
integer numbers inserted in the QRtreebytecode are to be interpreted as stored using the
INT16 format, while if the following bit is set to 1, all the integer numbers inserted in the
QRtreebytecode are to be interpreted as stored using the INT32 format.
Regarding the FLOAT_TYPE instruction, if the following bit is set to 0, all the real numbers
inserted in the QRtreebytecode are to be interpreted as stored using the FP16 format, while
13QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
if the following bit is set to 1, all the real numbers inserted in the QRtreebytecode are to be
interpreted as stored using the FP32 format.
6.2.3. DICT_TYPES (011)
The DICT_TYPE command, identified by the code 011, allows managing the activation of the
global and specific types of dictionary for the current eQR code. In particular, the following
two bits identify which dictionaries are activated by setting the options NO_DICT_GLOBAL to
disable the global dictionary, DICT_GLOBAL to enable the global dictionary, NO_DICT_SPEC to
disable the specific dictionary and DICT_SPEC to enable the specific dictionary. Please note
that if the DICT_TYPES command is not present, the DICT_GLOBAL and DICT_SPEC options
are enabled by default.
Table 2 shows the possible configurations of the two bits following those used to identify
the command (i.e., 011) in order to activate the different combinations of options. Although
the sequence of bits 11 has been reported in the table, it should never be used because the
configuration with the DICT_GLOBAL and DICT_SPEC options is the default one.
Table 2: Bits for activating the global and/or specific dictionaries.
Bits global specific
00 NO_DICT_GLOBAL NO_DICT_SPEC
01 NO_DICT_GLOBAL DICT_SPEC
10 DICT_GLOBAL NO_DICT_SPEC
11 DICT_GLOBAL DICT_SPEC
6.2.4. DICT_SPEC_TYPE (100)
The DICT_SPEC_TYPE command, identified by the 100 code, identifies which dictionary of
type specific should be used for the current eQR code. Specifically, the following bits rep-
resent the integer index that identifies the specific dictionary. When such dictionaries are
loaded by the application, they are loaded in a certain order, and index 0 will be assigned to
the first specific dictionary loaded, index 1 to the second specific dictionary loaded, etc. To
load multiple dictionaries of type specific, the DICT_SPEC_TYPE command must be repeated
several times, and specifically once for each specific dictionary loaded.
14QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
6.2.5. DICT_LOCAL (101)
As previously pointed out, strings are a kind of data that takes up a lot of space. Through a
dictionary of type local, it is possible to define some strings (typically those repeated several
times within the eQR code) and associate them with a numeric index.
ThecommandDICT_LOCAL,identifiedbythecode101, allowsthedefinitionofadictionary
of type local, whose content is saved within the eQR code itself. The first three bits after the
DICT_LOCAL command (i.e., the bits following 101) represent the language associated with
thisdictionary. ThesethreebitsfollowtheexponentialencodingasdescribedinAppendixC.
The 000 language is the default language, the 001 language is language number 1, and so
on. If a given dictionary is defined for multiple languages, you must repeat the DICT_LOCAL
command as many times as the number of languages for which the dictionary is defined. The
association of the language number to the specific language is defined within the application,
except for the language with index 000, which is always associated with the default language.
After the 3 bits that identify the language, there are 4 bits (following, once again, the
exponential encoding described in Appendix C) that identify the number of words present
in the dictionary. Next, there is a list of words, which are in number equal to the number of
words. Each individual word is identified by the encoding type (0 for ASCII-7, or 1 for UTF-
8) and the word encoded in ASCII-7 or UTF-8, respectively. In the event that a particular
word belonging to a dictionary of a language other than that of the default dictionary is
encoded with the empty string (i.e., “”), the corresponding dictionary default word will be
printed. If a word in the default dictionary has an empty string associated with it, the empty
string will be coherently printed when this word is printed.
6.2.6. USER_DEF (110)
TheUSER_DEFcommand,identifiedbythe110code,hasnotbeenassociatedwithanyspecific
actions. It can therefore be freely used by the application developer to add new functionality
to the application. It is the responsibility of the developer to maintain a correct parsing of
this command in the client application that will execute the eQR code.
6.3. Code
Within an eQR code, after the header due to the QRscript header and the optional header
due to the QRtree header, there is the section called code, which contains the language of
type QRtree that must actually be executed.
As already mentioned, this specification will detail the conversion rules from the inter-
mediate representation to the QRtreebytecode (arrow 2 in Fig. 1). The opposite conversion,
15QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
i.e. from the QRtreebytecode to the intermediate representation (arrow 5 in Fig. 1), follows
exactly the application of the same rules in reverse.
From the perspective of the intermediate representation, the code section consists of a list
of 0 or more instructions. There are 7 types of instructions, which are identified with 3
bits: input (000), inputs (001), print (010), printex (011), goto (100), if (101), and
ifc (110). Code 111 has been left without a corresponding instruction to allow, through
the exponential encoding described in Appendix C, to extend the instruction set of the
intermediate representation and coherently of the generated QRtreebytecode.
Appendix B shows a small example of the QRtreebytecode generated from an intermediate
representation.
6.3.1. Direct and indirect input
For what concerns the input instructions, there are two types: direct (inputs), and indirect
(input).
An input of type direct is a text string, while an input of type indirect is an input in which
the possible choices are prefixed within a predefined set and can be defined, for example,
throughasetofdecisionbuttons. Thepossiblepredeterminedchoices(i.e., thesetofpossible
choices)aredirectlyinferredbytheapplicationbyanalyzingtheintermediate representation.
For each question, there is an additional default answer named “Other”, which is only added
if there is a chained question that follows the current one. This answer, if selected, causes
the program to jump to the next chained question. Actually, if the default language used in
the application is different than English, the word “Other” can be directly translated by the
application to the target language.
As an example, the following code has been written using the intermediate representation:
(1) input "Question 1"
(2) if "Resp 1" (6)
(3) if "Resp 2" (8)
(4) if "Resp 3" (10)
(5) goto (12)
(6) # Code related to Resp 1
(7) ...
(8) # Code related to Resp 2
(9) ...
(10) # Code related to Resp 3
(11) ...
(12) inputs "Question 2"
16QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
Question 1
Resp 1 Resp 2 Resp 3 Other
Question 2
105
The answer to your question is: ....
Figure 4: Example of interaction between the user and the application executing the eQR
code
Line (1) writes the string “Question 1” to the screen, and an input of type indirect is inserted
(input command). The set of possible choices consists of { “Resp 1”, “Resp 2”, “Resp
3”, “Other” }. An example of a possible input interface based on decision buttons is
reported in Figure 4 and explained in detail in the following paragraph.
In the event that the user chooses “Resp 1”, for example, by clicking on the button
identified by “Resp 1”, a jump is performed to line (6), in which the code related to “Resp
1” starts. Please note that this code may recursively contain other questions (i.e., a decision
sub-tree). Similarly, if the user chooses “Resp 2”, for example, by clicking on the button
identified by “Resp 2”, a jump is performed to the line (8), in which the code related to Resp
2 starts. The behavior is similar even if the user chooses “Resp 3”. In case the user chooses
the “Other” response, the unconditional jump instruction goto (12) takes the execution
flow to the line (12), where there is a subsequent question, in this case, of type direct. Since
the question is direct, the user will have the possibility to enter a string that, depending
on subsequent commands, can be interpreted as a string (instruction if) or as a number
(instruction ifc).
6.3.2. References
eQR codes, but also QR codes in general, being printed on physical supports, have the
undeniable advantage of being able to be combined with additional information that can be
printed or placed near the eQR code itself, such as text or images. In the case the eQR
code is displayed on a monitor, there is the possibility to combine it also with videos. So, in
addition to a possible explanation of how the eQR code can be used, additional information
associated with it, can be added and be an integral part of the program itself. For example,
if a program of type QRtree outputs very large strings, these strings (which would take
up a large part of the available space within the eQR code) could be extracted from the
17QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
eQR code in order to be printed near to it. This also applies to the questions that can be
inserted into input or inputs instructions. For this reason, the ability for input and output
instructions to print a reference has been defined. The term reference refers to an integer
value that identifies the text or image (or any other kind of information) printed/displayed
near the eQR code. For example, a very long answer is replaced with an indication to read
the reference number 1. The same reasoning applies to images: by associating an integer
with an image (possibly accompanied by a textual description), the program can guide the
user to follow the instructions in the image with that particular number in order to obtain
information from the program itself (for example the path to reach a certain destination).
References are encoded following the exponential encoding described in Appendix C, with a
starting size of 4 bits.
All the instructions and the rules for converting from intermediate representation to QR-
bytecode are detailed in the following subsections.
6.3.3. input (000)
Theinputinstructionisusedtoprompttheapplicationendusertoenterastringasaninput
of type indirect. This instruction, before requesting the insertion of the input, displays the
constant<constant>onthescreen. Theinstructioninput <type> <constant>isidentified
by the first 3 bits equal to 000, followed by a bit identifying the type of the constant (i.e.,
<type>), and the <constant> to be printed on the screen. In the case where <type> is 0,
the <constant> is to be interpreted as a string, while in the case where <type> is 1, the
<constant> is to be interpreted as a reference, as detailed in Subsection 6.1.1.
Code Type Value
0 0 0 0 String
0 0 0 1 Reference
Figure 5: Conversion of input instruction to QRtreeBytecode
6.3.4. inputs (001)
The inputs instruction is used to prompt the application end user to enter a string as an
input of type direct. This instruction, before requesting the insertion of the input, displays
the constant <constant> on the screen. The instruction inputs <type> <constant> is
18QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
identified by the first 3 bits equal to 001, followed by a bit identifying the type of the
constant (i.e., <type>), and the <constant> to be printed on the screen. In the case where
<type> is 0, the <constant> is to be interpreted as a string, while in the case where <type>
is 1, the <constant> is to be interpreted as a reference, as detailed in Subsection 6.1.1.
Code Type Value
0 0 1 0 String
0 0 1 1 Reference
Figure 6: Conversion of inputs instruction to QRtreeBytecode
6.3.5. print (010)
The print instruction is used to request the printing of a <constant> on the screen. The
instruction print <type> <constant> is identified by the first 3 bits equal to 010, followed
by a bit identifying the type of the constant (i.e., <type>), and the <constant> to be printed
on the screen. In the case where <type> is 0, the <constant> is to be interpreted as a string,
while in the case where <type> is 1, the <constant> is to be interpreted as a reference, as
detailed in Subsection 6.1.1.
Code Type Value
0 1 0 0 String
0 1 0 1 Reference
Figure 7: Conversion of print instruction to QRtreeBytecode
6.3.6. printex (011)
The printex instruction is used to request the printing of a <constant> on the screen and
to terminate the execution of the program. The instruction printex <type> <constant>
is identified by the first 3 bits equal to 011, followed by a bit identifying the type of the
constant (i.e., <type>), and the <constant> to be printed on the screen. In the case where
19QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
<type> is 0, the <constant> is to be interpreted as a string, while in the case where <type>
is1, the<constant>istobeinterpretedasareference, asdetailedinSubsection6.1.1. When
used for printing the empty string, for example, by printing the UTF-7 character 0000011
via the instruction 011 1 00 0000011, it causes the end of the program without printing
anything on the screen. In particular, referring to the sequence of bits 011 1 00 0000011,
the first 3 bits 011 represent the printex instruction, the next bit 1 indicates to interpret
the <constant> as a string, 00 identifies the string as ASCII-7, and finally 0000011 encodes
the string terminator end-of-text (ETX) which in this context represents the empty string.
Code Type Value
0 1 1 0 String
0 1 1 1 Reference
Figure 8: Conversion of printex instruction to QRtreeBytecode
6.3.7. goto (100)
The goto instruction is used to perform unconditional jumps.
The instruction goto <relative_jump> is identified by the first 3 bits equal to 100,
followed by a <relative_jump>, which represents the number of subsequent instructions for
which the jump should be made. It is important to note that <relative_jump> only allows
forward jumps. Since backward jumps are not possible, it is not possible to create cycles
with QRtree. This choice is due to the fact that, for the realization of decision trees, cycles
are not of direct use. The value of <relative_jump> is encoded on 4 bits (following the
exponential encoding described in Appendix C), and the sequence 0000 encodes a jump to
the next instruction.
20QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
Code Relative jump
1 0 0 0 0 1 1
Relative jump extension 1
1 0 0 1 1 1 1 0 0 0 1
Relative jump extension 2
1 0 0 1 1 1 1 1 1 1 1 0 0 0 0 1 0 0 1
Figure 9: Conversion of goto instruction to QRtreeBytecode
6.3.8. if (101)
The if instruction is used to perform conditional jumps.
The instruction if <type> <constant> <relative_jump> is identified by the first 3 bits
equal to 101, followed by a bit identifying the type of the constant (i.e., <type>), the
<constant> (which if it is equal to the last input allows performing the jump) and by a
<relative_jump>, which represents the number of subsequent instructions for which the
jump should be made. In the case where <type> is 0, the <constant> is to be interpreted
as a string, while in the case where <type> is 1, the <constant> is to be interpreted as a
reference, as detailed in Subsection 6.1.1.
Each time an input instruction is executed, either indirect (i.e., input instruction) or
direct (i.e., inputs instruction), the inserted data is saved in a variable intended to contain
the last input, which will be named tmp_input. Whenever the content saved in the tmp_-
input variable is equal to the content saved in <constant>, a relative jump equal to the
number of statements encoded in <relative_jump> is performed. If the content of tmp_-
input is different from the content saved in constant, the if instruction has no effect, and
the next statement is executed. For details on how <relative_jump> is encoded, refer to
the description of the goto instruction in Subsection 6.3.7.
Code Type Value Relative jump
1 0 1 0 String 1 0 1 1
Relative jump extension 1
1 0 1 1 Reference 1 1 1 1 1 0 0 1
Figure 10: Conversion of if instruction to QRtreeBytecode
21QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
6.3.9. ifc (110)
Theinstructionifcisusedtoperformconditional jumpsafteracomparisonusingarelational
operator (i.e., ==, !=, <=, >=, <, >). The comparison is executed between the value inserted
via an input instruction (i.e., input or inputs instruction) and an integer or real number.
The instruction ifc <rel_op> <type> <constant> <relative_jump> is identified by the
first 3 bits equal to 110, followed by 3 bits identifying the relational operator <rel_op>,
followed by a bit identifying the type of the constant (i.e., <type>), the <constant>, which
is an integer or real number, and by a <relative_jump>, which represents the number of
subsequent instructions for which the jump should be made.
In detail, the correspondence between the 3 bits of <rel_op> and the relational operator
encodedbythemarerepresentedinthefollowingTable3. The110and111bitscombinations
are not currently used and are left for future extensions. The == operator, encoded with 000,
is the equality operator, while the != operator, encoded with 001, is the inequality operator.
Table 3: Correspondence between <rel_op> and the encoded relational operator.
<rel_op> Relational operator
000 ==
001 !=
010 <=
011 >=
100 <
101 >
In the case where type is 0, the <constant> is to be interpreted as a number of type
integer, which can be encoded with the INT16 (i.e., 00) or INT32 (i.e., 01) notation as
described in Subsection 6.1.2). In the case where type is 1, <constant> is to be interpreted
as a number of type real, which can be encoded with the FP16 (i.e., 10) and FP32 (i.e., 11)
notation as described in Subsection 6.1.3. It is worth noting that depending on the setting
of the header, more compact notations of the type are allowed.
Eachtimeaninputinstructionisexecuted, eitherindirect (i.e., inputinstruction)ordirect
(i.e., inputs instruction), the inserted data is saved in a variable intended to contain the
last input, which will be named tmp_input. Whenever the comparison between tmp_input
and the content saved in <constant> (using the <rel_op> relational operator) gives a true
22QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
result, a relative jump equal to the number of statements encoded in <relative_jump> is
performed. In case the comparison gives a false result, the ifc instruction has no effect, and
the next statement is executed. For details on how <relative_jump> is encoded, refer to
the description of the goto instruction in Subsection 6.3.7.
Code Operator Type Relative jump
1 1 0 0 1 1 0 1 0 1 1
Relative jump extension 1
1 1 0 1 0 1 1 1 1 1 1 1 0 0 1
Figure 11: Conversion of ifc instruction to QRtreeBytecode
7. Sample implementation
AsampleimplementationofthisspecificationdocumentisfreelyavailableundertheGPL-3.0
license [9].
8. Main terms and acronyms
• Continuation: featureoftheQRscriptheaderneededtosplittheprogramovermultiple
eQR codes.
• Decision tree: a decision tree is composed of three kinds of nodes: decision, end, and
chance nodes, but in the context of the QRtree dialect chance nodes have not been
implemented. The decision nodes of a tree are the points where the tree branches out,
and they depict the criteria that enable the user to select from various paths based on
their responses. The tree’s terminal nodes are the concluding points, which are utilized
to produce a response to the user.
• Dialect: sub-language defined through QRscript in the eQR code with implementation
characteristics specific to the particular application scope (e.g., decision trees, etc.).
• Dialect code: program coded within the eQR codes, which specification is reported in
separate documents (e.g., in this document, the specification of the QRtree dialect is
reported).
23QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
• eQR code: a QR code containing executable code. It can be obtained by encoding a
program within a QR Code using QRscript.
• eQRbytecode: the binary representation of the executable program. It is used to create
an eQR code and, after the scanning of the eQR code, to reconstruct the intermediate
representation.
• eQRtreebytecode: the binary representation of the part related to the QRtree dialect
of the executable program. It is the last part of an eQRbytecode.
• High-level language: a computer programming language (even visual) designed to be
easy for humans to read and write. It is easier to use and more abstract than the
intermediate representation. In the context of this specification document, it is a high-
levelprogramminglanguagethatcanbetranslatedintotheintermediaterepresentation
of the QRtree dialect.
• Intermediate representation: lower-level representation of the high-level language used
to standardize and simplify the translation between the latter and the correspondent
eQRbytecode.
• QRbytecode: the binary representation of the executable program. It is used to create
an eQR code and, after the scanning of the eQR code, to reconstruct the intermediate
representation. It is formed by a header named QRscript header, an optional header
named QRtree header, and by the encoding of the executable code.
• QRscript: a series of rules on how to embed a programming language into an eQR
code. In particular, it refers to the definition of the binary code that has to be saved
inside of an eQR code and the rules used for its decodification.
• QRscript header: part of an eQR code that is independent of the dialect.
• QRtree: dialect mainly aimed at coding decision trees without chance nodes.
• QRtree code: part of an eQR code containing the instructions of the QRtree dialect.
• QRtree header: part of an eQR code containing the optional header of the QRtree
dialect.
• QRtreebytecode: binary representation of the part related to the QRtree dialect.
24QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
• Reference: the possibility of some instructions of the QRtree dialect to print in output
a number instead of a string that represents a reference to information that is printed
near the eQR code. References are used to save space by avoiding inserting long strings
within the eQR code or referring to information that cannot be included in an eQR
code, such as big images or videos.
• Security: featuresoftheQRscriptheaderaimedatmanagingauthenticity andintegrity,
and eventually the encryption of the content of the eQR code.
• Security profile: indicates the security mechanisms activated and exploited in the cur-
rent eQR code.
• Three-address code: it is an intermediate representation, and in the context of this
specification document, it represents the intermediate representation of the QRtree
dialect.
• URL: used to permit the connection to an external uniform resource locator (URL) if
an Internet or local connection is available.
References
[1] S. Scanzio, M. Rosani, M. Scamuzzi, and G. Cena, “QRtree - Decision Tree dialect
specification of QRscript,” in arXiv, Mar. 2024, pp. 1–32.
[2] ISO Central Secretary, “Information technology — Automatic identification and data
capture techniques — QR Code bar code symbology specification,” International
Organization for Standardization, Geneva, CH, Standard ISO/IEC 18004:2015, 2015.
[Online]. Available: https://www.iso.org/standard/62021.html
[3] F. Yergeau, “UTF-8, a transformation format of ISO 10646,” RFC 3629, Nov. 2003.
[Online]. Available: https://www.rfc-editor.org/info/rfc3629
[4] International Organization for Standardization, “Information technology - ISO 7-bit
coded character set for information interchange,” International Organization for Stan-
dardization, Geneva, ISO/IEC Standard 646, 1991.
[5] “IEEE Standard for Floating-Point Arithmetic,” IEEE Std 754-2019 (Revision of IEEE
754-2008), pp. 1–84, 2019.
25QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
[6] S.Scanzio,G.Cena,andA.Valenzano,“QRscript: EmbeddingaProgrammingLanguage
in QR codes to support Decision and Management,” in 2022 IEEE 27th International
Conference on Emerging Technologies and Factory Automation (ETFA), 2022, pp. 1–8.
[7] S. Scanzio, M. Rosani, M. Scamuzzi, and G. Cena, “QRscript specification,” in arXiv,
Mar. 2024, pp. 1–13.
[8] D. A. Patterson and J. L. Hennessy, Computer Organization and Design: The Hard-
ware/Software Interface, 5th ed. Morgan Kaufmann Publishers, 2014, Section 2.4.2:
Two’s complement representation of numbers.
[9] S. Scanzio, M. Rosani, and M. Scamuzzi, “QRtree software,” Mar. 2024. [Online].
Available: https://github.com/eQR-code/QRtree
Appendix
A. Definition of global and specific dictionary
A global or specific dictionary can contain one or more languages. Each language must
contain a language identifier on 2 or more characters (for example, “it”, “en”, “ru”, ...) and
a list of words. The order of the words is important because the index/position inside the
list is the identifier used to refer to the word.
The schema for a dictionary is the following:
"$schema": width0pthttp://json-schema.org/draft-07/schema
definitions:
dictionary:
type: object
properties:
language:
type: string
minLength: 2
words:
type: array
items:
type: string
oneOf:
- "$ref": "#/definitions/dictionary"
26QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
- type: array
items:
"$ref": "#/definitions/dictionary"
An example
- language: en
words:
"Yes"
"No"
"Cancel"
"Ok"
- language: it
words:
"Si"
"No"
B. Example of QRtreebytecode generation
The idea behind this example is to guide the user to manage correctly a defibrillator in case
it is needed. The first question asked by the program regards the heart beats that can be
counted in 10 seconds, in order to get a general idea of how fast the heart is beating.
In case this number is lower than 5, then the program suggests to, first of all, call an
ambulance and then proceed with the cardiac massage and the defibrillator, also giving
instructions (in the case of the example, the instructions are given as references to possible
images printed near the eQR code that may better explain the procedures). Then, the
program asks if the patient woke up; if she/he did, it suggests waiting for the ambulance by
keeping the patient awake. If she/he did not, it suggests repeating alternating the precedent
procedures until the ambulance arrives.
If, instead, the number of beats in the 10 seconds is less than 10, the program suggests
having the person get seated and call the ambulance only if she/he does not feel better after
some time.
If the number of heart beats is more than 30, then the program notes that the person has
a really high heart rate, suggesting laying the person down, making her/him breathe, and
call the ambulance if she/he does not feel well after some time.
Finally, if the heart rate is not in any of the previous cases (so between 10 and 20 heart
beats), the program notes that the heart rate is fine and terminates.
The high-level program used in this example is the following:
27QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
inputs "How many heart beats can you count in 10 seconds?"
ifc <= 5:
print "The person has a heart beat rate too low. You should call an
ambulance."
print "In the mean time you should try doing a cardiac massage and then
using the defibrillator."
print 1 # "Apply the two pads to the bare chest. One in the middle of
the chest and one on the left side slightly below the nipple."
print 2 # "Don’t touch the body and start the defibrillator."
input "After a couple of charges does the patient woke up?"
if "Yes":
print "Great! Wait for the ambulance and keep the patient awake."
else if "No":
print "Keep alternating between 2-3 minutes of cardiac massage and
defibrillator charges until the ambulance arrives."
else ifc <= 10:
print "The person has a slightly low heart beat. Sit them down."
print "If they don’t feel better after a couple of minutes it’s better
to call an ambulance."
else ifc >= 30:
print "The person has a very high heart rate. Lay them down and make
them do deep breaths."
print "If they don’t feel better after a couple of minutes it’s better
to call an ambulance."
else:
print "The heart beat is normal."
The intermediate representation generated by the previous high-level language program
through the rules specified in this specification document is the following:
(0) inputs "How many heart beats can you count in 10 seconds?"
(1) ifc <= 5 (6)
(2) ifc <= 10 (18)
(3) ifc >= 30 (21)
(4) print "The heart beat is normal."
(5) goto (23)
(6) print "The person has a heart beat rate too low. You should call an
ambulance."
28QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
(7) print "In the mean time you should try doing a cardiac massage and then
using the defibrillator."
(8) print 1
(9) print 2
(10) input "After a couple of charges does the patient woke up?"
(11) if "Yes" (14)
(12) if "No" (16)
(13) goto (17)
(14) print "Great! Wait for the ambulance and keep the patient awake."
(15) goto (17)
(16) print "Keep alternating between 2-3 minutes of cardiac massage and
defibrillator charges until the ambulance arrives."
(17) goto (23)
(18) print "The person has a slightly low heart beat. Sit them down."
(19) print "If they don’t feel better after a couple of minutes it’s better
to call an ambulance."
(20) goto (23)
(21) print "The person has a very high heart rate. Lay them down and make
them do deep breaths."
(22) print "If they don’t feel better after a couple of minutes it’s better
to call an ambulance."
This intermediate representation is then converted into a binary format and inserted into
a QR code, thus generating an eQR code.
29QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
QRscriptheadersection
00100000000000001 no Qrtreeheader
0
00100010010001101111111011101000001101101110000111011101111001010000011010001100101110000111100101110100010000011000101100101110000111101001110011010000011000
11110000111011100100000111100111011111110101010000011000111101111111010111011101110100010000011010011101110010000001100010110000010000011100111100101110001111
01111110111011001001110011011111100000111100100000000000000001010100110010000000000000001010111100001100110000000000000111101111001001000010101001101000110010
10100000110100011001011100001111001011101000100000110001011001011100001111010001000001101001111001101000001101110110111111100101101101110000111011000101110000
00111001111001001000010101001101000110010101000001110000110010111100101110011110111111011100100000110100011000011110011010000011000010100000110100011001011100
00111100101110100010000011000101100101110000111101000100000111001011000011110100110010101000001110100110111111011110100000110110011011111110111010111001000001
01100111011111110101010000011100111101000110111111101011101100110010001000001100011110000111011001101100010000011000011101110010000011000011101101110001011101
01110110011000011101110110001111001010101110000001101000010010011101110010000011101001101000110010101000001101101110010111000011101110010000011101001101001110
11011100101010000011110011101111111010101000001110011110100011011111110101110110011001000100000111010011100101111001010000011001001101111110100111011101100111
01000001100001010000011000111100001111001011001001101001110000111000110100000110110111000011110011111001111000011100111110010101000001100001110111011001000100
00011101001101000110010111011100100000111010111100111101001110111011001110100000111010011010001100101010000011001001100101110011011010011100010111001011010011
10110011011001100001111010011011111110010010111000000110101000101010010000000100000111001101110100110010111100100100000110000101000001100011110111111101011110
00011011001100101010000011011111100110010000011000111101000110000111100101100111110010111100110100000110010011011111100101111001101000001110100110100011001010
10000011100001100001111010011010011100101110111011101000100000111011111011111101011110010101000001110101111000001111110000011101000101100111001011110011000001
10010101000100111011011110000011001110000110100001000111111001011001011100001111010001000010100000101011111000011101001111010001000001100110110111111100100100
00011101001101000110010101000001100001110110111000101110101110110011000011101110110001111001010100000110000111011101100100010000011010111100101110010111100000
10000011101001101000110010101000001110000110000111101001101001110010111011101110100010000011000011110111110000111010111100101010111000000111000001010000100101
11100101110010111100000100000110000111011001110100110010111100101101110110000111101001101001110111011001110100000110001011001011110100111011111001011100101110
11100100000011001001011010110011010000011011011101001110111011101011110100110010111100110100000110111111001100100000110001111000011110010110010011010011100001
11000110100000110110111000011110011111001111000011100111110010101000001100001110111011001000100000110010011001011100110110100111000101110010110100111011001101
10011000011110100110111111100100100000110001111010001100001111001011001111100101111001101000001110101110111011101001101001110110001000001110100110100011001010
10000011000011101101110001011101011101100110000111011101100011110010101000001100001111001011100101101001111011011001011110011010111000000111000101010000101010
01101000110010101000001110000110010111100101110011110111111011100100000110100011000011110011010000011000010100000111001111011001101001110011111010001110100110
11001111001010000011011001101111111011101000001101000110010111000011110010111010001000001100010110010111000011110100010111001000001010011110100111101000100000
11101001101000110010111011010100000110010011011111110111110111001011100000011010000100100111001100100000111010011010001100101111100101000001100100110111111011
10010011111101000100000110011011001011100101110110001000001100010110010111101001110100110010111100100100000110000111001101110100110010111100100100000110000101
00000110001111011111110101111000011011001100101010000011011111100110010000011011011101001110111011101011110100110010111100110100000110100111101000100111111001
10100000110001011001011110100111010011001011110010010000011101001101111010000011000111100001110110011011000100000110000111011100100000110000111011011100010111
01011101100110000111011101100011110010101011100000011100001001000010101001101000110010101000001110000110010111100101110011110111111011100100000110100011000011
11001101000001100001010000011101101100101111001011110010100000110100011010011100111110100001000001101000110010111000011110010111010001000001110010110000111101
00110010101011100100000100110011000011111001010000011101001101000110010111011010100000110010011011111110111110111001000001100001110111011001000100000110110111
00001110101111001010100000111010011010001100101110110101000001100100110111101000001100100110010111001011110000010000011000101110010110010111000011110100110100
01110011010111000000110100001001001110011001000001110100110100011001011111001010000011001001101111110111001001111110100010000011001101100101110010111011000100
00011000101100101111010011101001100101111001001000001100001110011011101001100101111001001000001100001010000011000111101111111010111100001101100110010101000001
10111111001100100000110110111010011101110111010111101001100101111001101000001101001111010001001111110011010000011000101100101111010011101001100101111001001000
001110100110111101000001100011110000111011001101100010000011000011101110010000011000011101101110001011101011101100110000111011101100011110010101011100000011
Figure 12: Binary representation of the provided example
30QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
Figure 13: Example of eQR code
From the conversion results between the intermediate representation and the correspond-
ing eQRbytecode binary representation and the generated eQR code just provided, it is
noticeable that the QRscript header starts with the padding 001, while the continuation is
disabled by the next bit set to 0. The security is disabled (0000), and the URL is disabled
(0). The dialect is “QRtree” (0000), and the version is 1 (0001). The first bit after the
QRscript header is set to 0, which means that the QRtree header is also disabled. The
length of the QRbytecode is 5704 bits, which corresponds to an occupation of the 24.1% of
the maximum available capacity within a QR code. Most of the space is occupied by strings
and correction bits.
C. Exponential encoding of an integer number
The exponential encoding is used in many parts of the QRscript language to permit the
encoding of integer numbers of any size, but coding at the same time small numbers with
a reduced number of bits. The number of bits for the coding is doubled each time the bits
used are not enough. The exponential encoding permits to have a compact notation for
small numbers without limiting a priori the size of the number to be encoded.
31QRtree - Decision Tree dialect specification of QRscript (Version 0.9)
Moreindetail, givenanintegernumberwithoutsignX, theexponentialencodingoccupies
an exponentially increasing number of bits in the binary representation of the number.
Let n bit be the initial number of bits used for the exponential encoding. As an example,
an exponential encoding over four bits is characterized by n = 4. If the number X is greater
than or equal to (2n −1) means that the value is too big to fit in n bits. In particular, the
remaining value that cannot be coded in n bits is X−(2n−1). In this case, the exponential
coding doubles the number of bits to 2·n.
This process is repeated, doubling n every time the number of bits is not sufficient to code
number X (i.e., n = 2·n ). The starting point (n ) can be any positive integer number
i i−1 0
greater than 0. Primarily, in this specification document, 4 bits are used as a starting point.
Some examples of this representation can be found in Tab. 4.
Value Sign Base 1st extension 2nd extension 3rd extension
Integer 1 bit 4 bit 4 bit 8 bit 16 bit
12 1100
14 1110
15 1111 0000
120 1111 1111 01011010
300 1111 1111 11111111 0000000000001111
Table 4: Examples of exponential encoding of integer numbers without sign
32