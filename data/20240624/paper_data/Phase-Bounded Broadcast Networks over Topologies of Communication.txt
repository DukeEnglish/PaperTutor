Phase-Bounded Broadcast Networks over
Topologies of Communication
Lucie Guillou #(cid:26)
IRIF, CNRS, Université Paris Cité, France
Arnaud Sangnier #(cid:26)
DIBRIS, Università di Genova, Italy
Nathalie Sznajder #(cid:26)
LIP6, CNRS, Sorbonne Université, France
Abstract
Westudynetworksofprocessesthatallexecutethesamefinitestateprotocolandthatcommunicate
throughbroadcasts. Theprocessesareorganizedinagraph(atopology)andonlytheneighborsofa
processinthisgraphcanreceiveitsbroadcasts. Thecoverabilityproblemasks,givenaprotocoland
astateoftheprotocol,whetherthereisatopologyfortheprocessessuchthatoneofthem(atleast)
reaches the given state. This problem is undecidable [6]. We study here an under-approximation of
theproblemwhereprocessesalternateaboundednumberoftimesk betweenphasesofbroadcasting
and phases of receiving messages. We show that, if the problem remains undecidable when k is
greater than 6, it becomes decidable for k=2, and ExpSpace-complete for k=1. Furthermore, we
show that if we restrict ourselves to line topologies, the problem is in P for k=1 and k=2.
2012 ACM Subject Classification Theoryofcomputation→Formallanguagesandautomatatheory
Keywords and phrases Parameterized verification, Coverability, Broadcast Networks
Digital Object Identifier 10.4230/LIPIcs...
Funding Lucie Guillou: ANR project PaVeDyS (ANR-23-CE48-0005)
1 Introduction
Verifying networks with an unbounded number of entities. Ensuring safety properties for
concurrent and distributed systems is a challenging task, since all possible interleavings must
be taken into account; hence, even if each entity has a finite state behavior, the verification
procedurehastodealwiththestateexplosionproblem. Anotherlevelofdifficultyariseswhen
dealingwithdistributedprotocolsdesignedforanunboundednumberofentities. Inthatcase,
the safety verification problem consists in ensuring the safety of the system, for any number
of participants. Here, the difficulty comes from the infinite number of possible instantiations
of the network. In their seminal paper [13], German and Sistla propose a formal model to
representandanalyzesuchnetworks: inthiswork,alltheprocessesinthenetworkexecutethe
same protocol, given by a finite state automaton, and they communicate thanks to pairwise
synchronized rendez-vous. The authors study the parameterized coverability problem, which
asks whether there exists an initial number of processes that allow an execution leading to a
configuration in which (at least) one process is in an error state (here the parameter is the
number of processes). They show that it is decidable in polynomial time. Later on, different
variations of this model have been considered, by modifying the communication means:
token-passing mechanism [1,5], communication through shared register [8,11], non-blocking
rendez-vous mechanism [14], or adding a broadcast mechanism to send a message to all the
entities [9]. The model of population protocol proposed in [2] and for which verification
methodshavebeendevelopedrecentlyin[10,12]belongsalsotothisfamilyofsystems. Inthis
latter model, the properties studied are different, and more complex than safety conditions.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany
4202
nuJ
12
]OL.sc[
1v20251.6042:viXraBroadcast networks working over graphs. In [6], Delzanno et. al propose a new model of
parameterizednetworkinwhicheachprocesscommunicateswithitsneighborsbybroadcasting
messages. Theneighborsofanentityaregiventhankstoagraph: thecommunicationtopology.
This model was inspired by ad hoc networks, where nodes communicate with each other
thanks to radio communication. The difficulty in proving safety properties for this new
model lies in the fact that one has to show that the network is safe for all possible numbers
of processes and all possible communication topologies. So the verification procedure not
only looks for the number of entities, but also for a graph representing the relationship of the
neighbourstoshowunsafeexecution. Asmentionedearlier,itisnotthefirstworktoproposea
parameterized network with broadcast communication; indeed the parameterized coverability
probleminnetworkswithbroadcastisdecidable[9]andnon-primitiverecursive[23]whenthe
communication topology is complete (each entity is a neighbor of all the others). However,
when there is no restriction on the allowed communication topologies the problem becomes
undecidable [6] but decidability can be regained by providing a bound on the length of all
simple paths in allowed topologies [6]. This restriction has then been extended in [7] to allow
also cliques in the model. However, with this restriction, the complexity of parameterized
coverability is non-primitive recursive [7].
Boundingthenumberofphases. Whendealingwithinfinite-statesystemswithanundecidable
safety verification problem, one option consists in looking at under-approximations of the
global behavior, restricting the attention to a subset of executions. If proving whether the
considered subset of executions is safe is a decidable problem, this technique leads to a sound
but incomplete method for safety verification. Good under-approximation candidates are
the ones that can be extended automatically to increase the allowed behavior. For instance,
it is known that safety verification of finite systems equipped with integer variables that
can be incremented, decremented, or tested to zero is undecidable [18], but if one considers
only executions in which, for each counter, the number of times the execution alternates
between an increasing mode and a decreasing mode is bounded by a given value, then safety
verification becomes decidable [15]. Similarly, verifying concurrent programs manipulating
stacksisundecidable[21]butdecidabilitycanberegainedbyboundingthenumberofallowed
contextswitches(acontextbeingaconsecutivesequenceoftransitionsperformedbythesame
thread) [19]. Context-bounded analysis has also been applied to concurrent programs with
stacksanddynamiccreationofthreads [3]. Anothertypeof underapproximationanalysishas
been conducted by [16] (and by [4] in another context), by considering bounded round-robin
schedules of processes. Inspired by this work, we propose here to look at executions of
broadcast networks over communication topologies where, for each process, the number
of alternations between phases where it broadcasts messages and phases where it receives
messages is bounded. We call such protocols k-phase-bounded protocols where k is the
allowed number of alternations.
Our contributions. We study the parameterized coverability problem for broadcast networks
working over communication topologies. We first show in Section 2 that it is enough to
consider only tree topologies. This allows us to ease our presentation in the sequel and is
also an interesting result by itself. In Section 3, we prove that the coverability problem
is still undecidable when considering k-phase-bounded broadcast protocols with k greater
than 6. The undecidability proof relies on a technical reduction from the halting problem
for two counter Minsky machines. We then show in Sections 4 and 5 that if the number of
alternations is smaller or equal to 2, then decidability can be regained. More precisely, we
show that for 1-phase-bounded protocols, we can restrict our attention to tree topologies
of height 1, which provides an ExpSpace-algorithm for the coverability problem. To solve
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany?a !!c
?b q 1 q 2 q 3
?a
q !!a
in !!a, !!b ?c
q q
4 5
Figure 1 Example of a broadcast protocol denoted P
this problem in the case of 2-phase-bounded protocols, we prove that we can bound the
height of the considered tree and rely on the result of [6] which states that the coverability
problem for broadcast networks is decidable when considering topologies where the length of
all simple paths is bounded. We furthermore show that if we consider line topologies then
the coverability problem restricted to 1- and 2-phase-bounded protocols can be solved in
polynomial time.
Due to lack of space, omitted proofs and reasonings can be found in Appendix.
2 Preliminaries
Let A be a countable set, we denote A∗ as the set of finite sequences of elements taken in
A. Let w ∈ A∗, the length of w is defined as the number of elements in the sequence w
and is denoted ∣w∣. For a sequence w =a 1⋅a 2⋯a
k
∈A+, we denote by w[−1] the sequence
a 1⋅a 2⋯a k−1. Let ℓ,n∈N with ℓ≤n, we denote by [ℓ,n] the set of integers {ℓ,ℓ+1,...,n}.
2.1 Networks of processes
We study networks of processes where each process executes the same protocol given as a
finite-state automaton. Given a finite set of messages Σ, a transition of the protocol can be
labelled by three types of actions: (1) the broadcast of a message m∈Σ with label !!m, (2)
the reception of a message m∈Σ with label ?m or (3) an internal action with a special label
τ ∉ Σ. Processes are organised according to a topology which gives for each one of them
its set of neighbors. When a process broadcasts a message m∈Σ, the only processes that
can receive m are its neighbors, and the ones having an output action ?m have to receive it.
Furthermore, the topology remains fixed during an execution.
Let Σ be a finite alphabet. In order to refer to the different types of actions, we write !!Σ
for the set {!!m∣m∈Σ} and ?Σ for {?m∣m∈Σ}.
▶Definition2.1. ABroadcastProtocolisatupleP =(Q,Σ,q in,∆)suchthatQisafiniteset
ofstates,Σisafinitealphabetofmessages,q
in
isaninitialstateand∆⊆Q×(!!Σ×?Σ∪{τ})×Q
is a finite set of transitions.
We depict an example of a broadcast protocol in Figure 1. Processes are organised according
to a topology, defined formally as follows.
▶ Definition 2.2. A topology is an undirected graph, i.e. a tuple Γ=(V,E) such that V
is a finite set of vertices, and E ⊆V ×V is a finite set of edges such that (u,v)∈E implies
(v,u)∈E for all (u,v)∈V2, and for all u∈V, (u,u)∉E (there is no self-loop).
We will use V(Γ) and E(Γ) to denote the set of vertices and edges of Γ respectively, namely
V and E. For v ∈ V, we will denote N Γ(v) the set {u ∣ (v,u) ∈ E}. When the context is
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyv 1∶ q in v 1∶ q 4 v 1∶ q 4 v 1∶ q 5
v v v
1 2 3
v 3∶ q in v 2∶ q in v 3∶ q 1 v 2∶ q 1 v 3∶ q 2 v 2∶ q in v 3∶ q 3 v 2∶ q in
Figure 2 Example of an execution of protocol P (Figure 1).
clear, wewillwriteN(v). Foru,v∈V(Γ), wedenote⟨v,u⟩forthetwopairs(v,u),(u,v). We
name Graphs the set of topologies. In this work, we will also be interested in some families
of topologies: line and tree topologies. A topology Γ = (V,E) is a tree topology if V is a
set of words of N∗ which is prefix closed with ϵ∈V, and if E ={⟨w[−1],w⟩ ∣w∈V ∩N+ }.
This way, the root of the tree is the unique vertex ϵ∈V and a node w∈V ∩N+ has a unique
parent w[−1]. The height of the tree is max{n∈N ∣∣w∣=n}. We denote by Trees the set of
tree topologies. A topology Γ=(V,E) is a line topology if V is such that V ={v 1,...,v n}
for some n∈N and E ={⟨v i,v i+1⟩∣1≤i<n}. We denote by Lines the set of line topologies.
Semantics. A configuration C of a broadcast protocol P =(Q,Σ,q in,∆) is a tuple (Γ,L)
whereΓisatopology, andL∶V(Γ)→Qisalabellingfunctionassociatingtoeachvertexv of
the topology its current state of the protocol. In the sequel, we will sometimes call processes
or nodes the vertices of Γ. A configuration C is initial if L(v)=q
in
for all v∈V(Γ). We let
CP be the set of all configurations of P, and IP the set of all initial configurations. When
P is clear from the context, we may drop the subscript and simply use C and I. Given a
protocol P =(Q,Σ,q in,∆), and a state q∈Q, we let R(q)={m∈Σ∣∃q′ ∈Q,(q,?m,q′ )∈∆}
be the set of messages that can be received when in the state q.
Consider δ = (q,α,q′ ) ∈ ∆ a transition of P, and C = (Γ,L) and C′ = (Γ′,L′ ) two
v,δ
configurations of P, and let v ∈ V(Γ) be a vertex. The transition relation —→ ∈ C×C is
defined as follows: we have C —v, →δ C′ if and only if Γ=Γ′, and one of the following conditions
holds:
α=τ and L(v)=q, L′ (v)=q′ and L′ (u)=L(u) for all u∈V(Γ)∖{v}: vertex v performs
an internal action;
α=!!m and L(v)=q, L′ (v)=q′ (vertex v performs a broadcast), and for each process
u∈N(v) neighbor of v, either (L(u),?m,L′ (u))∈∆ (vertex u receives message m from
v), or m∉R(L(u)) and L(u)=L′ (u) (vertex u is not in a state in which it can receive
m and stays in the same state). Furthermore, L′ (w) = L(w) for all other vertices
w∈V(Γ)∖({v}∪N(v)) (vertex w does not change state).
We write C —→C′ whenever there exists v∈V(Γ) and δ∈∆ such that C —v, →δ C′. We denote
by →∗ [resp. →+] for the reflexive and transitive closure [resp. transitive] of →. An execution
of P is a sequence of configurations C 0,...,C n∈CP such that for all 0≤i<n, C i→C i+1.
▶ Example 2.3. We depict in Figure 2 an execution of protocol P (from Figure 1): it starts
with an initial configuration with three processes v ,v ,v , organised as a clique (each vertex
1 2 3
is a neighbour of the two others), each on the initial state q in. More formally, Γ=(V,E)
with V ={v 1,v 2,v 3} and E ={⟨v 1,v 2⟩,⟨v 2,v 3⟩,⟨v 1,v 3⟩}. From the initial configuration, the
following chain of events happens: C 0—v1 —,( —qi —n —,!! —b, —q4 →) C 1—v —2, —(q —1 —,!! —a, —qi —n →) C 2—v —3, —(q —2, —!!c —,q —3 →) C 3.
2.2 Verification problem
Inthiswork,wefocusonthecoverability problem whichconsistsinensuringasafetyproperty:
we want to check that, no matter the number of processes in the network, nor the topology
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyin which the processes are organised, a specific error state can never be reached.
The coverability problem over a family of topologies S ∈{Graphs,Trees,Lines} is stated
as follows:
Cover[S]
Input: A broadcast protocol P and a state q ∈Q;
f
Question: Is there Γ∈S, C=(Γ,L)∈I and C′=(Γ,L′)∈C and v∈V(Γ) such that
P P
C→∗C′ and L′(v)=q ?
f
For a family S, if indeed there exist C =(Γ,L) and C′ =(Γ,L′ ) such that C →∗C′ and
L′ (v)=q
f
for some v ∈V(Γ), we say that q
f
is coverable (in P) with Γ. We also say that
the execution C →∗ C′ covers q f. For short, we write Cover instead of Cover [Graphs].
Observe that Cover is a generalisation of Cover [Trees] which is itself a generalisation of
Cover [Lines]. In [6], the authors proved that the three problems are undecidable, and they
later showed in [7] that the undecidability of Cover still holds when restricting the problem
to families of topologies with bounded diameter.
However, in [6], the authors show that Cover becomes decidable when searching for an
execution covering q
f
with a K-bounded path topology for some K ∈N, i.e. for a topology
in which all simple paths between any pair of vertices v 1,v 2∈V have a length bounded by
K. In [7], it is also shown that Cover is Ackermann-hard when searching for an execution
covering q with a topology where all maximal cliques are connected by paths of bounded
f
length. We establish the first result.
▶ Theorem 2.4. Cover [Graphs] and Cover [Trees] are equivalent.
Indeed, if it is obvious that when a state is coverable with a tree topology, it is coverable
with a topology from Graphs, we can show that whenever a state is coverable, it is coverable
with a tree topology. If a set q
f
of a protocol P is coverable with a topology Γ∈Graphs, let
ρ=C 0 →⋯→C n =(Γ,L n) be an execution covering q f, and a vertex v f ∈V(Γ) such that
L n(v f)=q f. We can build an execution covering q
f
with a tree topology Γ′ where the root
reaches q . Actually, Γ′ is the unfolding of Γ in a tree of height n.
f
3 Phase-Bounded Protocols
As Cover [Graphs], Cover [Trees] and Cover [Lines] are undecidable in the general case,
we investigate a restriction on broadcast protocols: phase-bounded protocols.
For k ∈ N, a k-phase-bounded protocol is a protocol that ensures that each process
alternates at most k times between phases of broadcasts and phases of receptions. Before
giving our formal definition of a phase-bounded protocol, we motivate this restriction.
Phase-bounded protocols can be seen as a semantic restriction of general protocols in
which each process can only switch a bounded number of times between phases where it
receives messages and phases where it broadcasts messages. When, usually, restricting the
behavior of processes immediately yields an underapproximation of the reachable states, we
highlight in Appendix B the fact that preventing messages from being received can in fact
lead to new reachable states. Actually, the reception of a message is something that is not
under the control of a process. If another process broadcasts a message, a faithful behavior
of the system is that all the processes that can receive it indeed do so, no matter in which
phase they are in their own execution. Hence, in a restriction that attempts to limit the
number of switches between broadcasting and receiving phases, one should not prevent a
reception to happen. This motivates our definition of phase-bounded protocols, in which a
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany?b
?a
!!a qr,2 qr,2
1 2
?b q 1r,1 ?a
qr,1
q ib n,2 !!a,!!b q 4b,2
?a
2
qb,2
q i0 n !!a, !!b !!c 3 ?a
qb,1 qr,2
4 ?c 5
Phase 0
Phase 1 Phase 2
Figure 3 P : the 2-unfolding of protocol P (Figure 1).
2
process in its last broadcasting phase, can still receive messages. A k-unfolding of a protocol
P is then a protocol in which we duplicate the vertices by annotating them with the type
and the number of phase (b or r for broadcast or reception and an integer between 0 and k
for the number).
▶ Example 3.1. Figure 3 pictures the 2-unfolding of protocol P (Figure 1). Observe that
from state qb,2, which is a broadcast state, it is still possible to receive message a and go to
4
state qr,2. However, it is not possible to send a message from qr,2 (nor from any reception
5 5
state of phase 2).
We show in Appendix that this definition of unfolding can be used as an underapproximation
for Cover. In the remaining of the paper, we study the verification problems introduced
in Section 2.2 when considering phase-bounded behaviors. We turn this restriction into a
syntactic one over the protocol, defined as follows.
▶ Definition 3.2. Let k∈N. A broadcast protocol P =(Q,Σ,q in,∆) is k-phase-bounded if
Q can be partitioned into 2k+1 sets Q={Q 0,Qb 1,Qr 1,...Qb k,Qr k}, such that q in∈Q
0
and for
all (q,α,q′ )∈∆ one of the following conditions holds:
1. there exist 0≤i≤k and β∈{r,b} such that q,q′ ∈Qβ
i
and α=τ (for ease of notation, we
take Q 0=Qb 0=Qr 0);
2. there exists 1≤i≤k such that q,q′ ∈Qb
i
and α∈!!Σ;
3. there exists 1≤i≤k such that q,q′ ∈Qr
i
and α∈?Σ;
4. there exists 0≤i<k such that q∈Qb i, q′ ∈Qr
i+1
and α∈?Σ;
5. there exists 0≤i<k such that q∈Qr i, q′ ∈Qb
i+1
and α∈!!Σ;
6. q∈Qb k, q′ ∈Qr
k
and α∈?Σ
A protocol P is phase-bounded if there exists k∈N such that P is k-phase-bounded.
▶ Example 3.3. Observe that the protocol P displayed in Figure 1 is not phase-bounded:
by definition, it holds that Q
0
={q in}, and q
1
∈Qr
1
(because of the transition (q in,?b,q 1)).
As a consequence q in∈Qb 2, because of the transition (q 1,!!a,q in). This contradicts the fact
that Qb 2∩Q 0 = ∅. Intuitively, P does not ensure that every vertex alternates at most a
bounded number of times between receptions and broadcasts, in particular, for any integer
k ∈ N, it might be that there exists an execution where a process alternates k+1 times
between reception of a message b from state q , and broadcast of a message a from state
in
q 1. Removing the transition (q 1,!!a,q in) from P would give a 2-phase-bounded protocol P′:
Q 0={q in}, Qr 1={q 1,q 2}, Qb 1={q 4}, Qb 2={q 3} and Qr 2={q 5}.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany!!td !!td
s 0 s 0 s
0 1 2
?d
?m, m∉ ?m, m∉
?m,m≠d
1
1 ?m,m≠d
1
?m, m∈Σ idl ch
{td1, d1} {td1, d1}
?d
1
(cid:47) (cid:47)
Figure 5 Protocol P executed by v .
Figure 4 Protocol P executed by v . t n
(cid:47) (cid:47) h (cid:47) 0
The following table summarizes our results (PB stands for phase-bounded).
1-PB Protocols 2-PB Protocols PB Protocols
Cover[Lines] ∈P (Section 6.2) Undecidable (k≥4) (Sec 4)
Cover[Graphs] ExpSpace-complete Decidable Undecidable (k≥6)
Cover[Trees] (Section 5) (Section 6.1) (Section 4)
4 Undecidability Results
We prove that Cover restricted to k-phase-bounded protocols (with k≥6) is undecidable
by a reduction from the halting problem of a Minksy machine [18]: a Minsky machine is a
finite-state machine (whose states are called locations) with two counters, x and x (two
1 2
variables that take their values in N). Each transition of the machine is associated with an
instruction: increment one of the counters, decrement one of the counters or test if one of
the counters is equal to 0. The halting problem asks whether there is an execution that ends
in the halting location. In a first step, the protocol will enforce the selection of a line of
nodes from the topology. All other nodes will be inactive. In a second step, the first node of
the line (that we call the head) visits the different states of the machine during an execution,
whileallothernodes(exceptthelastone)simulatecounters’values: theyareeitherinastate
representing value 0, or a state representing x (respectively x ). The number of processes on
1 2
states representing x gives the actual value of x in the execution. The last node (called the
1 1
tail) checks that everything happens as expected. When the head has reached the halting
location of the machine, it broadcasts a message which is received and forwarded by each
node of the line until the tail receives it and reaches the final state to cover.
When the head of the line simulates a transition of the machine, it broadcasts a message
(the instruction for one of the counters), which is transmitted by each node of the line
until the tail receives it. A classical way of forwarding the message through receptions and
broadcastswouldnotgiveaphase-boundedprotocol. Hence,duringthetransmission,thetail
only receives messages and all other nodes only broadcast and do not receive any message.
In the next subsection, we explain how this is achieved. To do so, we explain the mechanism
by abstracting away the actual instruction, and just show how to transmit a message.
4.1 Propagating a message using only broadcasts in a line
In a line, a node has at most two neighbors, but cannot necessarily distinguish between the
two (its left and its right one). To do so, nodes broadcast messages with subscript 0, 1 or
2, and we ensure that: if a node broadcasts with subscript 1, its right [resp. left] neighbor
broadcasts with subscript 0 [resp. subscript 2]. Similarly, if a node broadcasts with subscript
0 [resp. 2], its right neighbor broadcasts with subscript 2 [resp. 1] and its left one with
subscript 1 [resp. 0].
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany!!td 0 tr0 ?m,m∉ !!td 1 tr1 ?m,m∉ !!td 2 tr2 ?m,m∉
td td td
{td ,td } {td ,td } {td ,td }
!!td 2 1 !!td 0 2 !!td 1 0
0?m, 1?m, 2?m,
m∉{td , m∉{td , m∉{td ,
idl0
d ,td
,d2
}
idl1
d ,td
,d0
}
idl2
d ,td
,d1
}
2 1 1 0 2 2 1 0 0
!!d !!d !!d
0 ?m(cid:47),m∉ 1 ?m(cid:47),m∉ 2 ?m(cid:47),m∉
tr0 tr1 tr2
!!td 0 !!d 0 d {d 2,d 1} !!td 1 !!d 1 d {d 0,d 2} !!td 2 !!d 2 d {d 1,d 0}
?m, ?m, ?m,
ex0 ex1 ex2
m∉{td ,d , m∉{td ,d , m∉{td ,d ,
2 2 0 0 1 1
td ,d } td ,d } td ,d }
1 1 2 2 0 0
!!d !!d !!d
0 (cid:47) 1 (cid:47) 2 (cid:47)
hlt0 ?m, hlt1 ?m, hlt2 ?m,
m∉{td ,d , m∉{td ,d , m∉{td ,d ,
2 2 0 0 1 1
td ,d } td ,d } td ,d }
1 1 2 2 0 0
(cid:47) (cid:47) (cid:47)
Figure 6 P . Figure 7 P . Figure 8 P .
0 1 2
v 0∶s 0 v 1∶idl1 v 2∶idl2 v 3∶idl0 v 4∶idl1 ... v n−1∶idl1 v n∶idl
Figure 9 A configuration from which the transmission can happen: a node in state idli can only
broadcast messages with subscript i.
Consider the five protocols displayed in Figures 4–8. The states marked as initial are the
ones from which a process enters the protocol. Protocol P is executed by the head of the
h
line, P by the tail of the line and other nodes execute either P , P or P . Observe that
t 0 1 2
messages go by pairs: td i,td
i
and d i, d
i
for all i∈{0,1,2}.
The head broadcasts a request to be done with the pair of messages td , td . Each
0 0
process in one of the P starts in idli and has a choice: either it transmits a message without
i
executing it, or it “executes” it and tells it to the others. When it transmits a message not
yet executed, it broadcasts the messages td and td and visits states tri and idli. When
i i td
it executes the request, it broadcasts the messages td and d and visits states exi and hlti.
i i
Finally, when it transmits a request already done, it broadcasts the messages d and d and
i i
visits states tri and idli. Once a process has executed the request (i.e. broadcast a pair td ,
d j
d
j
for some j ∈{0,1,2}), only pairs d j, d j, with j ∈{0,1,2}, are transmitted in the rest of
the line.
Correct transmission of a request. Take for instance the configuration C depicted in
0
Figure9forn=5(i.e. therearesixvertices). Wesaythataconfigurationisstable ifthehead
is in s
0
or s 2, the tail is in idl and other nodes are in idli or hlti for i∈{0,1,2}. Note that C
0
is stable. We depict a transmission in Figures 10a and 10b, starting from C . We denote the
0
successive depicted configurations C ,C ,...C . Note that C is stable. Between C and
0 1 11 11 0
C , the following happens: Between C and C , v broadcasts the request with messages
11 0 3 0
td and td . Between C and C , v and v successively repeat the request to be done with
0 0 1 8 1 2
messages td and td for v and td td for v . Between C and C , v executes the request
1 1 1 2 2 2 6 10 3
by broadcasting messages td and d . Between C and C , v transmits the done request
0 0 7 11 4
with messages d and d . Hence, the request is executed by exactly one vertex (namely
1 1
v ), as highlighted in Figure 10b. Observe that the processes sort of spontaneously emit
3
broadcast to avoid to receive a message. A correct guess of when to broadcast yields the
interleaving of broadcasts that we have presented in this example.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyv 0∶s 0 v 1∶idl1 v 2∶idl2 v 2∶tr2 td v 3∶idl0 v 4∶idl1 v 5∶idl
!!td 0 !!td 0
v 0∶s 1 v 1∶idl1 v 2∶idl2 v 2∶tr2 td v 3∶ex0 v 4∶idl1 v 5∶idl
!!td 1 !!td 2
v 0∶s 1 v 1∶tr1 td v 2∶idl2 v 2∶idl2 v 3∶ex0 v 4∶idl1 v 5∶idl
v 0∶s! 2!td 0 v 1∶tr1 td v 2∶idl2 v 2∶idl2 v 3∶ex0 !! vd 41 ∶tr1 d v 5∶ch
!!td
2 !!d
v 0∶s 2 v 1∶tr1 td v 2∶tr2 td v 2∶idl2 v 30 ∶hlt0 v 4∶tr1 d v 5∶ch
!!td 1 !!d 1
v 0∶s 2 v 1∶idl1 v 2∶tr2 td v 2∶idl2 v 3∶hlt0 v 4∶idl1 v 5∶idl
(a) C →C →⋯→C . (b) C →C →⋯→C .
0 1 5 6 7 11
Figure 10 Example of correct transmission.
v 0∶s 0 v 1∶idl1 v 1∶idl1 v 2∶idl2
!!td !!td
0 1
v 0∶s 1 v 1∶idl1 v 1∶tr1 td v 2∶idl2
!!td 0 !!d 2
v 0∶s 2 v 1∶ v 1∶ v 2∶tr2 d
(a) v doesnottransmitthe(cid:47)request. (b) v broadcastst(cid:47) hewrongpairofmessages.
1 2
Figure 11 Example of wrong behaviors during the transmission.
How to prevent wrong behaviors? Observe that, when a node is in state idl1, if one of its
neighbor broadcasts a message which is not td ,d or td ,d , then the node in idl1 reaches
0 0 2 2
. We say that a process fails whenever it reaches . We have the following lemma:
(cid:47) (cid:47)
▶ Lemma 4.1. Let C ∈C be a stable configuration such that C 0→+C. Then in C, it holds
that v 0 is in s 2, and there is exactly one vertex v ∈{v 1,v 2,v 3,v 4} on a state hltj for some
j ∈{0,1,2}.
Indeed, let C be a stable configuration such that C 0→+C. It holds that:
1. From C , the first broadcast is from v and it broadcasts td .
0 0 0
Indeed,ifanothervertexthanv broadcastsamessagemwithsubscriptifromC ,itsleft
0 0
neighbor would fail with transition (idlj,?m, ) as j =(i−1) mod3 and m∈{td i,d i}.
2. Each vertex (except the tail) broadcasts one p(cid:47)air of messages between C and C.
0
Assume for instance that v does not broadcast anything. From Item 1, v broadcasts
1 0
td , and so at some point it will also broadcasts td otherwise it would not be in s or s
0 0 0 2
in C. Hence v fails as depicted in Figure 11a. Actually, each vertex (except the tail)
1
broadcasts exactly one pair: if it broadcasts more, its left neighbor would fail as well.
3. When a node broadcasts a pair (td , td ), its right neighbor broadcasts either a pair (td ,
j j i
td i) or (td i, d i), for j,i∈{0,1,2}.
Assume its right neighbor broadcasts d i, it must be that i = (j+1) mod3. Such an
example is depicted in Figure 11b: v
1
fails with (tr1 td,?d 2, ). Similarly, we have:
4. When a node broadcasts a pair (td , d ) or a pair (d , d ),(cid:47)its right neighbor broadcasts a
j j j j
pair (d i, d i), for j,i∈{0,1,2}.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany4.2 Putting everything together
We adapt the construction of Section 4.1 to propagate operations on counters of the machine
issued by the head of the line. Counters processes will evolve in three different protocols as
in Section 4.1. They can be either in a zero state, from which all the types of instructions
can be transmitted, or in a state 1 for x one of the two counters, from which all the types of
x
operations can be transmitted, except 0-tests of x. Increments and decrements of a counter x
are done in a similar fashion as in Section 4.1 (exactly one node changes its state). 0-tests
are somewhat easier: no node changes state nore executes anything, and the tail accepts the
same pair as the one broadcast by the head. However, if a node is in a 1 when x is the
x
counter compared to 0, it fails when its left neighbor broadcasts the request.
We ensure that we can select a line with a similar structure as the one depicted in
Figure9thankstoafirstpartoftheprotocolwhereeachnode: (i)receivesanannouncement
message from its predecessor with a subscript j (except the head which broadcasts first), (ii)
broadcasts an announcement message with the subscript (j+1) mod3 (head broadcasts
with subscript 0) and (iii) waits for the announcement of its successor with subscript (j+2)
mod3(exceptforthetail). Ifitreceivesanynewannouncementatanypointofitsexecution,
it fails. When considering only line topologies, as each node has at most two neighbors, this
part can be achieved with fewer alternations. We get the two following theorems.
▶ Theorem 4.2. Cover and Cover [Trees] are undecidable for k-phase-bounded protocols
with k≥6.
▶ Theorem 4.3. Cover [Lines] is undecidable for k-phase-bounded protocols with k≥4.
5 Cover in 1-Phase-Bounded Protocols
WeshowthatCover [Graphs]restrictedto1-phase-boundedprotocolsisExpSpace-complete.
We begin by proving that for such protocols Cover [Graphs] and Cover [Stars] are
equivalent (where Stars correspond to the tree topologies of height one). To get this property,
we first rely on Theorem 2.4 (stating that Cover and Cover [Trees] are equivalent) and
without loss of generality we can assume that if a control state can be covered with a tree
topology, it can be covered by the root of the tree. We then observe that when dealing
with 1-phase-bounded protocols, the behaviour of the processes of a tree which are located
at a height strictly greater than 1 have no incidence on the root node. Indeed if a process
at depth 2 performs a broadcast received by a node at depth 1, then this latter node will
not be able to influence the state of the root because in 1-phase-bounded protocols, once
a process has performed a reception, it cannot broadcast anymore. In the sequel we fix a
1-phase-bounded protocol P =(Q,Σ,q in,∆) and a state q
f
∈Q. We then have:
▶ Lemma 5.1. There exist Γ∈Graphs, C =(Γ,L)∈IP and D=(Γ,L′ )∈CP and v ∈V(Γ)
such that C →∗ D and L′ (v) = q f iff there exists Γ′ ∈ Stars, C′ = (Γ′,L′′ ) ∈ I and D′ =
(Γ′,L′′′ )∈CP such that C′ →∗ P D′ and L′′′ (ϵ)=q f.
To solve Cover [Stars] in ExpSpace, we proceed as follows (1) we first propose an
abstract representation for the configurations reachable by executions where the root node
does not perform any reception, and that only keeps track of states in Q and Qb (2) we
0 1
show that we can decide in polynomial space whether a configuration corresponding to a
given abstract representation can be reached from an initial configuration (3) relying on
reduction to the control state reachability problem in VASS (Vector Addition System with
States), we show how to decide whether there exists a configuration corresponding to a given
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyabstract representation from which q can be covered in an execution where the root node
f
does not perform any broadcast. This reasoning relies on the fact that a process executing
a 1-phase-bounded protocol first performs only broadcast (or internal actions) and then
performs only receptions (or internal actions).
We use Qb to represent the set Q 0∪Qb 1 and we say that a configuration C = (Γ,L)
in CP is a star-configuration whenever Γ ∈ Stars. For a star-configuration C = (Γ,L) in
CP such that L(ϵ) ∈ Qb, the broadcast-print of C, denoted by bprint(C), is the pair
(L(ϵ),{L(v) ∈ Qb ∣ v ∈ V(Γ)∖{ϵ}}) in Qb ×2Qb. We call such a configuration C a b-
configuration. Notethatanyinitialstar-configurationC in=(Γ in,L in)∈I isab-configuration
verifying bprint(C in)∈{(q in,∅),(q in,{q in})} (the first case corresponding to V(Γ)={ϵ}).
We now define a transition relation ⇒ between broadcast-prints. Given (q,Λ) and (q′,Λ′ ) in
Qb ×2Qb, we write (q,Λ)⇒(q′,Λ′ ) if there exists two b-configurations C and C′ such that
bprint(C)=(q,Λ) and bprint(C′ )=(q′,Λ′ ) and C →C′. We denote by ⇒∗ the reflexive
and transitive closure of ⇒. One interesting point of this abstract representation is that we
can compute in polynomial time the ⇒-successor of a given broadcast-print. The intuition is
simple: either the root performs a broadcast of m∈Σ, and in that case we have to remove
from the set Λ all the states from which a reception of m can be done (as the associated
processesinC′ willnotbeinastateinQb anymore)oroneprocessinastateofΛperformsa
broadcast and in that case it should not be received by the root node (otherwise the reached
configuration will not be a b-configuration anymore).
▶ Lemma 5.2. Given (q,Λ)∈Qb ×2Qb, we can compute in polynomial time the set {(q′,Λ′ )∣
(q,Λ)⇒(q′,Λ′ )}.
In order to show that our abstract representation can be used to solve Cover [Stars], we
need to rely on some further formal definitions. Given two star-configurations C =(Γ,L) and
C′ =(Γ′,L′ ), we write C ⪯C′ iff the two following conditions hold (i) L(ϵ)=L′ (ϵ), and, (ii)
∣{v∈V(Γ)∖{ϵ}∣L(v)=q}∣≤∣{v∈V(Γ′ )∖{ϵ}∣L′ (v)=q}∣ for all q∈Qb. We then have the
following lemma where the two first points show that when dealing with star-configurations,
the network generated by 1-phase-bounded protocol enjoys some monotonicity properties.
Indeed, if the root node performs a broadcast received by other nodes, then if we put more
nodes in the same state, they will also receive the message. On the other hand if it is another
node that performs a broadcast, only the root node is able to receive it. The last point of the
lemma shows that we can have as many processes as we want in reachable states in Qb (as
soon as the root node does not perform any reception) by duplicating nodes and mimicking
behaviors.
▶ Lemma 5.3. The following properties hold:
(i) If C 1, C 1′ and C
2
are star-configurations such that C 1→C 1′ and C 1⪯C
2
then there exists
a star-configuration C 2′ such that C 1′ ⪯C 2′ and C 2→∗C 2′.
(ii) If C 1, C 1′ and C 2 are b-configurations such that C 1→C 1′ and bprint(C 1)=bprint(C 2)
and C 1⪯C 2 then there exists a b-configuration C 2′ such that C 1′ ⪯C 2′ and bprint(C 1′ )=
bprint(C 2′ ) and C 2→∗C 2′ .
(iii) If C is a b-configuration such that C in→∗C for some initial configuration C
in
then for all
N ∈N,thereexistsaninitialconfigurationC i′
n
andab-configurationC′ =(Γ′,L′ )suchthat
C i′
n
→∗ C′ and bprint(C)=bprint(C′ )=(q,Λ) and ∣{v∈V(Γ′ )∖{ϵ}∣L′ (v)=q′ }∣≥N
for all q′ ∈Λ.
We can now prove that we can reason in a sound and complete way with broadcast prints
to characterise the b-configurations reachable from initial star-configurations. To prove this
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanynext lemma, we rely on the two last points of the previous lemma and reason by induction
on the length of the ⇒-path leading from (q in,Λ in) to (q,Λ).
▶Lemma 5.4. Given (q,Λ)∈Qb ×2Qb, we have (q in,Λ in)⇒∗ (q,Λ) with Λ in∈{∅,{q in}} iff
thereexisttwob-configurationsC in∈I andC ∈C suchthatC in→∗C andbprint(C)=(q,Λ).
Finally, we show that we can verify in exponential space whether there exists a configura-
tion with a given broadcast-print (q,Λ) from which we can reach a configuration covering q
f
thanks to an execution where the root node does not perform any broadcast. This result is
obtained by a reduction to the control state reachability problem in (unary) VASS which is
known to be ExpSpace-complete [17,20]. VASS are finite state machines equipped with
variables (called counters) taking their values in N, and where each transition of the machine
can either change the value of a counter, by incrementing or decrementing it, or do nothing.
In our reduction, we encode the state of the root in the control state of the VASS and we
associate a counter to each state of Qb to represent the number of processes in this state.
In a first phase, the VASS generates a configuration with (q,Λ) as broadcast-print and in
a second phase it simulates the network. For instance, if a process performs a broadcast
received by the root node, then we decrement the counter associated to the source state
of the broadcast, we increment the one associated to the target state and we change the
control state of the VASS representing the state of the root node accordingly. We need a last
definition to characterise executions where the root node does not perform any broadcast:
given two star-configurations C =(Γ,L) and C′ =(Γ,L′ ), we write C —→r C′ whenever there
existv∈V(Γ)andδ∈∆suchthatC —v, →δ C′ andeitherv≠ϵorδ=(q,τ,q′ )forsomeq,q′ ∈Q.
We denote by →∗
r
the reflexive and transitive closure of →r.
▶ Lemma 5.5. Given (q,Λ)∈Qb ×2Qb, we can decide in ExpSpace whether there exist a b-
configurationC =(Γ f,L)andastar-configurationC
f
=(Γ f,L f)suchthatbprint(C)=(q,Λ)
and L f(ϵ)=q
f
and C →∗
r
C f.
Combining the results of the previous lemmas leads to an ExpSpace-algorithm to solve
Cover [Stars]. Wefirstguessabroadcast-print(q,Λ)andcheckinpolynomialspacewhether
it is ⇒-reachable from an initial broadcast-print in {(q in,∅),(q in,{q in})} thanks to Lemma
5.2 (relying on a non-deterministic polynomial space algorithm for reachability). Then
we use Lemma 5.5 to check the existence of a b-configuration C with bprint(C)=(q,Λ)
from which we can cover q . By Savitch’s theorem [22], we conclude that the problem is
f
in ExpSpace. The completeness of this method is direct. For the soundess, we reason
as follows: using Lemma 5.4, there exists a configuration C reachable from an initial star-
configuration such that bprint(C)=(q,Λ), and by Lemma 5.5, there is a configuration C′
such that bprint(C′ )=(q,Λ) from which we cover q f. Thanks to Lemma 5.3.(iii), there is
a configuration C′′ reachable from an initial configuration such that C ⪯C′′ and C′ ⪯C′′
and bprint(C′′ )=(q,Λ). Thanks to Lemma 5.3.(i) applied to each transition, we can build
an execution from C′′ that covers q . The lower bound is obtained by a reduction from the
f
control state reachability in VASS.
▶ Theorem 5.6. Cover [Graphs] and Cover [Trees] are ExpSpace-complete for 1-phase-
bounded protocols.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany6 Decidability Results for 2-Phase-Bounded Protocols
6.1 Cover and Cover[Trees] are Decidable on 2-PB Protocols
A simple path between u and u′ in a topology Γ=(V,E) is a sequence of distinct vertices
v 0,...,v
k
such that u=v 0, u′ =v k, and for all 0≤i<k, (v i,v i+1)∈E. Its length is denoted
d(v 0,...,v k) and is equal to k. Given an integer K, we say that a topology Γ is K-bounded
path(andwewriteΓ∈K−BP)ifthereisnosimplepathv 0,...,v
k
suchthatd(v 0,...,v k)>K
The result of this subsection relies on the following theorem.
▶ Theorem 6.1 ( [6],Theorem 5). For K ≥1, Cover[K-BP] is decidable.
Hence, we show that if a state q of a protocol P is coverable with a tree topology, then
f
q
f
is actually coverable with a tree topology that is also 2(∣Q∣+1)−BP. To establish this
result, consider a coverable state q of a protocol P with a tree topology Γ, such that Γ is
f
minimal in the number of nodes needed to cover q . We can suppose wlog that q is covered
f f
by the root of the tree. We argue that all nodes (except maybe the root) in the execution
covering q broadcast something, as otherwise they are useless and could then be removed.
f
We also argue that, since P is 2-phase-bounded, a node that would first broadcast after the
first broadcast of its father would also be useless for the covering of q : this broadcast will
f
only be received by its father in its last phase of reception, hence it will have no influence on
the behavior of the root. These two properties are the key elements needed to establish the
following lemma.
▶ Lemma 6.2. Let P =(Q,Σ,q in,∆) be a 2-phase-bounded protocol and q
f
∈Q. If q
f
can be
covered with a tree topology, then it can be covered with a topology Γ∈Trees such that, for all
u∈V(Γ), ∣u∣≤∣Q∣+1.
Indeed, a counting argument implies that if this is not the case, there exist two nodes u
1
and u on the same branch, different from the root, with u a prefix of u , that both execute
2 1 2
their first broadcast from the same state q. In this case, we could replace the subtree rooted
in u by the subtree rooted in u , and still obtain an execution covering q . Once u has
1 2 f 1
reached q (possibly by receiving broadcasts from the children of u ), it will behave as in
2
the initial execution. Behaviors of the children of u might differ in this second part, but it
1
can only influence u in its reception phase, which will be the last phase, and hence will not
1
influence the behavior of the root. Thanks to Theorems 2.4 and 6.1, we can then conclude.
▶ Theorem 6.3. Cover and Cover [Trees] are decidable for 2-phase-bounded protocols.
6.2 Polynomial Time Algorithm for Cover[Lines] on 2-PB Protocols
In the rest of this section, we fix a 2-phase-bounded protocol P =(Q,Σ,q in,∆) and a state
q f ∈ Q to cover. For an execution ρ = C 0 —→ C 1 —→ ⋯ —→ C n with C n = (Γ,L n), for all
v,t
v ∈ V(Γ), we denote by b first(v,ρ) the smallest index 0 ≤ i < n such that C i —→ C i+1 with
t = (q,!!m,q′ ) ∈ ∆. If v never broadcasts anything, b first(v,ρ) = −1. We also denote by
v,t
t last(v,ρ) the largest index 0≤i<n, such that C
i
—→C
i+1
for some transition t∈∆. If v
never issues any transition, we let t last(v,ρ)=−1.
The polynomial time algorithm relies on the fact that to cover a state, one can consider
only executions that have a specific shape, described in the following lemma.
▶ Lemma 6.4. If q f is coverable with a line topology Γ such that V(Γ)={v 1,...,v ℓ} then
there exists an execution ρ=C 0—→C 1—→⋯—→C
n
such that C n=(Γ,L n), and 3≤N ≤ℓ−2
with L n(v N)=q f, and
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanynobroadcastfromvN−2
C 0 v 1∶q in ... v N−2∶q in v N−1∶q in v N ∶q in v N+1∶q in v N+2∶q in ... v ℓ∶q in
nobroadcastfromvN+2
∗
C j1 v 1∶_ ... v N−2∶q 1 v N−1∶q in v N ∶q in v N+1∶q in v N+2∶q in ... v ℓ∶q in
∗
C j2 v 1∶_ ... v N−2∶q 1 v N−1∶q in v N ∶q in v N+1∶q in v N+2∶q 2 ... v ℓ∶_
∗
C n v 1∶_ ... v N−2∶_ v N−1∶_ v N ∶q f v N+1∶_ v N+2∶_ ... v ℓ∶_
Figure 12 Illustration of execution ρ obtained from Lemma 6.4.
1. there exist 0≤j 1<j 2<n such that for all 0≤j <n, if we let C
j
—v —j, —t →j C j+1:
(a) if 0 ≤ j < j 1, then vj ∈ {v 1,...,v N−2} and if vj = v N−2, then tj = (q,τ,q′ ) for some
q,q′ ∈Q; and
(b) if j 1 ≤j <j 2, then vj ∈{v N+2,...,v ℓ} and if vj =v N+2, then tj =(q,τ,q′ ) for some
q,q′ ∈Q; and
(c) if j 2≤j <n, then vj ∈{v N−2,...,v N+2}.
2. (a) for all 1≤i≤N −2, t last(v i,ρ)≤b first(v i+1,ρ), and
(b) for all N +2≤i≤ℓ, t last(v i,ρ)≤b first(v i−1,ρ).
Figure 12 illustrates the specific form of the execution described in Item 1 of Lemma 6.4:
the first nodes to take actions are the ones in the purple part (on the left), then, only nodes
in the green part (on the right) issue transitions), and finally the nodes in the orange central
part take actions in order to reach q . The fact that P is 2-phase bounded allows us to
f
establish Item 2 of Lemma 6.4: when v starts broadcasting, no further broadcasts from v
i+1 i
will influence v ’s broadcasts (it can only receive them in its last reception phase).
i+1
Figure 12 highlights why we get a polynomial time algorithm: when we reach the orange
partoftheexecution,thenodesv ,v andv arestillintheinitialstateoftheprotocol.
N−1 N N+1
Moreover, in the orange part (which is the one that witnesses the covering of q ), only five
f
nodes take actions. Once one has computed in which set of states the nodes v and v
N−2 N+2
can be at the beginning of the orange part, it only remains to compute the set of reachable
configurations from a finite set of configurations. Let H be the set of possible states in which
v
N−2
and v
N+2
can be at the beginning of the last part of the execution, and for q 1,q 2∈H,
let C q1,q2 =(Γ 5,L q1,q2) where Γ 5 is the line topology with five vertices {v 1,v 2,v 3,v 4,v 5} and
L q1,q2(v 1)=q 1, L q1,q2(v 5)=q
2
and for all other vertex v, L q1,q2(v)=q in.
Our algorithm is then: (1) Compute H; (2) For all q 1,q 2 ∈ H, explore reachable con-
figurations from C ; (3) Answer yes if we reach a configuration covering q , answer no
q1,q2 f
otherwise. It remains to explain how to compute H. This computation relies on Item 2 of
Lemma 6.4: locally, each node v at the left of v (resp. at the right of v ) stops issuing
i N−1 N+1
transitions once its right neighbor v (resp. its left neighbor v ) starts broadcasting.
i+1 i−1
Hence we compute iteratively set of coverable pairs of states S ⊆Q×Q by relying on a
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyfamily (S i)i∈N of subsets of Q×Q formally defined as follows:
S 0={(q in,q in)}
S i+1=S i ∪{(q 1,q 2)∣there exist (p 1,p 2)∈S i,j ∈{1,2} s.t. (p j,τ,q j) ∈∆ and p 3−j =q 3−j}
∪{(q 1,q 2)∣there exists (p 1,p 2)∈S i, s.t. (p 2,!!m,q 2) ∈∆,(p 1,?m,q 1) ∈∆,m∈Σ}
∪{(q 1,q 2)∣there exists p 2∈Q s.t. (q 1,p 2)∈S i, and (p 2,!!m,q 2) ∈∆ and m∉R(q 1)}
∪{(q in,q)∣there exists (q,q′ )∈S
i
for some q′ ∈Q}.
We then define S =⋃n ∈NS n, and H ={q∈Q∣ there exists q′ and (q,q′ )∈S}. Observe that
(S i)i∈N is an increasing sequence bounded by ∣Q∣2. The computation reaches then a fixpoint
and S can be computed in polynomial time. We define H ={q ∣∃q′ ∈Q,(q,q′ )∈S}. Note
that H ⊆Q 0∪Qr 1, as expected by Item 2 of Lemma 6.4. We also state that our construction
is complete and correct, leading to the following theorem.
▶ Theorem 6.5. Cover [Lines] is in P for k-phase-bounded protocols with k∈{1,2}.
Proof. Weexplainwhythealgorithmtakesapolynomialtime: step1(computingH)isdone
in polynomial time as explained above. For step 2, there are at most ∣H∣×∣H∣≤∣Q∣2 pairs,
and for each pair, we explore a graph of at most ∣Q∣5 nodes in which each vertex represents
a configuration C =(Γ 5,L). Accessibility in a graph can be done non-deterministically in
logarithmic space, and so in polynomial time. Observe that all the lemmas of this section
hold true when considering 1-phase-bounded protocols, hence the theorem. ◀
References
1 B. Aminof, S. Jacobs, A. Khalimov, and S. Rubin. Parametrized model checking of token-
passing systems. In VMCAI’14, volume 8318 of LNCS, pages 262–281. Springer-Verlag,
2014.
2 D. Angluin, J. Aspnes, Z. Diamadi, M. J. Fischer, and R. Peralta. Computation in networks
of passively mobile finite-state sensors. In PODC’04, pages 290–299. ACM, 2004.
3 M. F. Atig, A. Bouajjani, and S. Qadeer. Context-bounded analysis for concurrent programs
with dynamic creation of threads. Log. Methods Comput. Sci., 7(4), 2011.
4 Benedikt Bollig, Mathieu Lehaut, and Nathalie Sznajder. Round-bounded control of para-
meterized systems. In ATVA’18, volume 11138 of Lecture Notes in Computer Science, pages
370–386. Springer, 2018.
5 E. M. Clarke, M. Talupur, T. Touili, and H. Veith. Verification by network decomposition. In
CONCUR’04, volume 3170 of LNCS, pages 276–291. Springer-Verlag, 2004.
6 G.Delzanno,A.Sangnier,andG.Zavattaro. Parameterizedverificationofadhocnetworks. In
CONCUR’10, volume 6269 of LNCS, pages 313–327. Springer, 2010.
7 G. Delzanno, A. Sangnier, and G. Zavattaro. On the power of cliques in the parameterized
verification of ad hoc networks. In FOSSACS’11, volume 6604 of LNCS, pages 441–455.
Springer, 2011.
8 A. Durand-Gasselin, J. Esparza, P. Ganty, and R. Majumdar. Model checking parameterized
asynchronous shared-memory systems. Formal Methods Syst. Des., 50(2-3):140–167, 2017.
9 J. Esparza, A. Finkel, and R. Mayr. On the verification of broadcast protocols. In LICS’99,
pages 352–359. IEEE Computer Society, 1999.
10 J. Esparza, P. Ganty, J. Leroux, and R. Majumdar. Verification of population protocols. Acta
Informatica, 54(2):191–215, 2017.
11 J. Esparza, P. Ganty, and R. Majumdar. Parameterized verification of asynchronous shared-
memory systems. J. ACM, 63(1):10:1–10:48, 2016.
12 J. Esparza, S. Jaax, M. A. Raskin, and C. Weil-Kennedy. The complexity of verifying
population protocols. Distributed Comput., 34(2):133–177, 2021.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany13 S.M.GermanandA.P.Sistla. Reasoningaboutsystemswithmanyprocesses. Journal of the
ACM, 39(3):675–735, 1992.
14 L. Guillou, A. Sangnier, and N. Sznajder. Safety analysis of parameterised networks with
non-blocking rendez-vous. In CONCUR’23, volume 279 of LIPIcs, pages 7:1–7:17. Schloss
Dagstuhl - Leibniz-Zentrum für Informatik, 2023.
15 O. H. Ibarra. Reversal-bounded multicounter machines and their decision problems. J. ACM,
25(1):116–133, 1978.
16 S. La Torre, P. Madhusudan, and G. Parlato. Model-checking parameterized concurrent
programs using linear interfaces. In CAV’10, volume 6174 of LNCS, pages 629–644. Springer,
2010.
17 R.J. Lipton. The reachability problem requires exponential space. Research report (Yale Uni-
versity. Department of Computer Science). Department of Computer Science, Yale University,
1976.
18 M. L. Minsky. Computation: Finite and Infinite Machines. Prentice-Hall, Inc., 1967.
19 S.QadeerandJ.Rehof.Context-boundedmodelcheckingofconcurrentsoftware.InTACAS’05,
volume 3440 of LNCS, pages 93–107. Springer, 2005.
20 C. Rackoff. The covering and boundedness problems for vector addition systems. Theoretical
Computer Science, 6:223–231, 1978.
21 G. Ramalingam. Context-sensitive synchronization-sensitive analysis is undecidable. ACM
Trans. Program. Lang. Syst., 22(2):416–430, 2000.
22 WalterJ.Savitch. Relationshipsbetweennondeterministicanddeterministictapecomplexities.
J. Comput. Syst. Sci., 4(2):177–192, 1970. doi:10.1016/S0022-0000(70)80006-X.
23 S. Schmitz and P. Schnoebelen. The power of well-structured systems. In CONCUR’13,
volume 8052 of LNCS, pages 5–24. Springer, 2013.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyA Cover and Cover[Trees] are equivalent
Let P = (Q,Σ,q in,∆) be a broadcast protocol, and q f ∈ Q. Let ρ = C 0 → ⋯ → C n with
C i =(Γ,L i) ∈ CP for all 0 ≤ i≤n, and a vertex v f ∈ V(Γ) such that L n(v f) =q f. We will
build an execution covering q with a tree topology Γ′, rooted in v , the node that reaches
f f
q . Γ′ is actually an unfolding of the topology Γ.
f
We first define inductively the set of nodes V′ ⊆N∗, along with a labelling function λ
which associates to each node v′ ∈V′ a node v∈V(Γ).
1. ϵ∈V′ and λ(ϵ)=v f;
2. Let N Γ(v f)={v 1,...,v k}. For all 1≤i≤k, i∈V′ and λ(i)=v i;
3. Let w⋅x∈V′, with w∈N∗ such that ∣w∣<n−1, and x∈N. Let N Γ(λ(w⋅x))∖{λ(w)}=
{v 1,...,v k}. Then, for all 1≤i≤k, w⋅x⋅i∈V′ and λ′ (w⋅x⋅i)=v i.
Finally, define E′ = {⟨w,w⋅x⟩ ∣ w ∈ V′,w⋅x ∈ V′ }. Note that ϵ ∈ V′ and V′ ⊆ N∗ and is
prefix closed. Furthermore, by construction, for all w∈V′, ∣w∣≤n, and for all w∈V′, in fact
w∈{1,...,d}∗ wheredisthemaximaldegreeofΓ. Hence, V′ isafinitesetandΓ′ =(V′,E′ )
is a tree topology.
The way we built Γ′ ensures that each node v∈V′ (except the leaves) enjoys the same
set of neighbors than λ(v)∈V. This is formalised in the following lemma.
▶ Lemma A.1. For all u ∈ V′, for all u′ ∈ N Γ′(u), λ(u′ ) ∈ N Γ(λ(u)). Then, we let
f u∶N Γ′(u)→N Γ(λ(u)) defined by f u(u′ )=λ(u′ ). If ∣u∣<n, f
u
is a bijection.
Proof. We prove the lemma inductively on the structure of the nodes of V′.
Let u = ϵ, then λ(u) = v f and let N Γ(v f) = {v 1,...,v k}. Then by definition, for all
1≤i≤k, i∈V′ and λ(i)=v i. By definition of E′, {1,...,k}⊆N Γ′(ϵ). Now let u∈N Γ′(ϵ),
again by definition of E′, ∣u∣=1 and u∈{1,...,k} because all other nodes added in V′
are of length greater of equal than 2. So N Γ′(ϵ)={1,...,k}, and the function f
ϵ
such
that f ϵ(i)=λ(i)=v
i
is obviously a bijection.
Let w⋅x∈V′ such that ∣w⋅x∣<n and w∈N∗. By induction hypothesis, f
w
∶N Γ′(w)→
N Γ(λ(w)) is a bijection. Hence, since by definition of E′, w⋅x ∈ N Γ′(w), f w(w⋅x) =
λ(w⋅x)∈N Γ(λ(w)) and (λ(w),λ(w⋅x))∈E. Let then N Γ(λ(w⋅x))={v 1,...,v ℓ,λ(w)}.
By definition of V′ and E′, N Γ′(w⋅x)={w,w⋅x⋅1,...,w⋅x⋅ℓ} and λ(w⋅x⋅i)=v
i
for
all 1≤i≤ℓ. Hence, f
w⋅x
is a bijection.
Moreover, if w⋅x ∈ V′ with ∣w⋅x∣ = n, then w⋅x is a leaf and N Γ′(w⋅x) = {w}. By
construction, λ(w⋅x)=v∈N Γ(λ(w)), which implies that λ(w)∈N Γ(λ(w⋅x)). ◀
From the execution ρ=C 0→...C
n
we will build a similar execution on Γ′. The idea is
thatforeachstepoftheexecutionρ, foreachnodev∈V, allthenodesinΓ′ thatarelabelled
by v will behave in the same way. This is possible thanks to Lemma A.1. Observe though
that the leaves might no be able to behave as expected because they might not have the
samesetofneighborsthanthenodetheyarelabelledby, sotheymightnotbeabletoreceive
some broadcast message. However, we can ensure some weaker version of correctness, defined
as follows. Let 0 ≤ h ≤ n and C = (Γ,L) be a configuration. We say that a configuration
C′ =(Γ′,L′ ) is h-correct for C if for all u∈V(Γ′ ), if ∣u∣≤h then L′ (u)=L(λ(u)).
The following lemma gives the main ingredient that allows to mimick the execution ρ on
Γ′.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany▶Lemma A.2. Let C 1=(Γ,L 1), C 2=(Γ,L 2)∈CP such that C 1→C 2 and let C 1′ =(Γ′,L′ 1)∈
CP and 0<h≤n such that C 1′ is h-correct for C 1. There exists C 2′ ∈CP such that C 1′ →∗C 2′,
and C 2′ is (h−1)-correct for C 2.
Proof. Denote C 1—v, →t C 2 with t=(q,α,q′ ) and α∈!!Σ∪{τ}. Let {u 1,...,u K} be the set of
vertices in V′ such that for all 1≤k≤K, ∣u k∣≤h and λ(u k)=v. We will build inductively
an execution C 1′
,0
—u —1, →t C 1′
,1
—u —2, →t ... —uK —, →t C 1′
,K
of configurations over Γ′ such that for all
0≤k≤K, C 1′ ,k =(Γ′,L′ 1,k) and for all node u∈V′ such that ∣u∣≤h,
if u∈⋃1≤j≤k({u j}∪N Γ′(u j)), then L′ 1,k(u)=L 2(λ(u)),
otherwise, L′ 1,k(u)=L′ 1(u).
We let C 1′ ,0=C 1′, since ⋃1≤j≤k({u j}∪N Γ′(u j))=∅, C 1′ trivially meets the requirements.
Let0≤k<K andassumenowthatwehavebuiltC 1′ ,0,...,C 1′
,k
asrequired. First,observe
that
(u k+1∪N Γ′(u k+1))∩( ⋃ ({u j}∪N Γ′(u j)))=∅. (1)
1≤j≤k
Indeed assume otherwise and let u an element of this intersection. If u = u k+1, then
u ∉ ⋃1≤j≤k{u j} by definition. Then it must be in ⋃1≤j≤kN Γ′(u j) and let j such that
u k+1 ∈ N Γ′(u j). By Lemma A.1, f uj(u k+1) = λ(u k+1) = v ∈ N Γ(λ(u j)) = N Γ(v). Hence it
implies that (v,v) ∈ E which is impossible. If u ∈ N Γ′(u k+1) then by a similar argument,
u∉⋃1≤j≤k{u j}. Thenlet1≤j ≤ksuchthatu∈N Γ′(u j). Thenu
j
∈N Γ′(u)andu k+1∈N Γ′(u).
If ∣u∣ < n (u is not a leaf), then f u(u j) = λ(u j) = v and f u(u k+1) = λ(u k+1) = v which
contradicts the fact that f
u
is bijective from Lemma A.1. If ∣u∣=n, then it is a leaf and it
has only one neighbor: its father in the tree. So it is not possible that {u j,u k+1}∈N Γ′(u).
To define C′ we need to differentiate between the possible values of α (recall that
1,k+1
t=(q,α,q′ )).
if α=τ, let L′ 1,k+1(u k+1)=q′ and L′ 1,k+1(u)=L′ 1,k(u) for all u≠u k+1. First, by Equa-
tion (1) and induction hypothesis, u k+1∉⋃({u j}∪N Γ′(u j)), then L′ 1,k(u k+1)=L′ 1(u k+1).
Moreover,sinceC 1′ ish-correctforC 1,L′ 1(u k+1)=L 1(v)=q. ThenC 1′
,k
—u —k+ —1, →t C 1′ ,k+1. Let
u∈V′ such that ∣u∣≤h and u∈⋃1≤j≤k+1({u j}∪N Γ′(u j)). If u∈⋃1≤j≤k({u j}∪N Γ′(u j)),
byinductionhypothesis, L′ 1,k(u)=L 2(λ(u)). Moreover, byEquation (1), u≠u k+1. Then,
L′ 1,k+1(u)=L′ 1,k(u)=L 2(λ(u)). By construction, L′ 1,k+1(u k+1)=q′ =L 2(λ(u k+1)). Now,
if u∈N Γ′(u k+1), or u∉⋃1≤j≤k+1({u j}∪N Γ′(u j)). Then, L′ 1,k+1(u)=L′ 1,k(u). By induc-
tion hypothesis, L′ 1,k(u)=L′ 1(u)=L 1(λ(u)) because C 1′ is h-correct for C 1. Moreover,
L 1(λ(u))=L 2(λ(u)). Hence, C 1′
,k+1
meets the requirements.
If α=!!m for some m∈Σ, we define L′
1,k+1
as follows.
L′ 1,k+1(u k+1)=q′ (the node u
k+1
performs the broadcast).
for all u∈N Γ′(u k+1) such that ∣u∣≤h, L′ 1,k+1(u)=L 2(λ(u)).
for all u∈N Γ′(u k+1) such that ∣u∣>h, if there exists p∈Q and (L′ 1,k(u),?m,p)∈∆,
L′ 1,k+1(u)=p, otherwise, L′ 1,k+1(u)=L′ 1,k(u) (its neighbors receive the broadcast).
For all other u∈V′, L′ 1,k+1(u)=L 1,k(u).
We first show that C 1′
,k
—u —k+ —1, →t C 1′ ,k+1. By Equation (1), u
k+1
∉⋃1≤j≤k({u j}∪N Γ′(u j)).
Hence, the induction hypothesis ensures that L′ 1,k(u k+1) = L 1(λ(u k+1) = L 1(v). Let
u∈N Γ′(u k+1) such that ∣u∣≤h. By Equation (1), u∉⋃1≤j≤k({u j}∪N Γ′(u j)). Then, by
induction hypothesis, L′ 1,k(u)=L′ 1(u)=L 1(λ(u)) since C 1′ is h-correct for C 1. Moreover,
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyv,t
since u ∈ N Γ′(u k+1), Lemma A.1 implies that λ(u) ∈ N Γ(v). Since C 1 —→ C 2, we
know that either (L 1(λ(u)),?m,L 2(λ(u))) ∈ ∆, hence (L′ 1,k(u),?m,L′ 1,k+1(u)) ∈ ∆,
or L′ 1,k+1(u) = L 2(λ(u)) = L 1(λ(u)) = L′ 1,k(u). In both cases, we can conclude that
C 1′
,k
—u —k+ —1, →t C 1′ ,k+1.
Let now u∈V′ such that ∣u∣≤h and u∈⋃1≤j≤k+1({u j}∪N Γ′(u j)). If u∈⋃1≤j≤k({u j}∪
N Γ′(u j)), again by Equation (1), u ∉ {u k+1}∪N Γ′(u k+1), and L′ 1,k+1(u) = L′ 1,k(u) =
L 2(λ(u)) by induction hypothesis. If u = u k+1, L′ 1,k+1(u) = q′ = L 2(v) = L 2(λ(u k+1).
If u ∈ N Γ′(u k+1), by definition we have that L′ 1,k+1(u) = L 2(λ(u)). If now ∣u∣ ≤ h and
u∉⋃1≤j≤k+1({u j}∪N Γ′(u j)), L′ 1,k+1(u)=L′ 1,k(u)=L′ 1(u) by induction hypothesis.
We let C 2′ =C 1′
,K
and we prove that C 2′ is (h−1)-correct for C 2. Let u∈V′ such that
∣u∣≤h−1<n. As C 1′ is h-correct for C 1, L′ 1(u)=L 1(λ(u)).
If u is such that λ(u)∈N Γ(v), then by Lemma A.1, there exists u′ ∈N Γ′(u) such that
λ(u′ ) = v. Furthermore, since Γ′ is a tree topology, and ∣u∣ ≤ h−1, either ∣u′ ∣ ≤ h−2
or ∣u′ ∣ ≤ h−1+1 = h. In both cases, ∣u′ ∣ ≤ h. As a consequence, u′ ∈ {u 1,...,u K}, and
so, L′ 2(u) = L′ 1,K(u) = L 2(λ(u)). If u is such that λ(u) = v, then u ∈ {u 1,...,u K}, and
again, L′ 2(u) = L′ 1,K(u) = L 2(λ(u)). In other cases, λ(u) ∉ N Γ(v)∪{v}, and L 2(λ(u)) =
L 1(λ(u)). By definition of {u 1,...,u K} and by Lemma A.1, u∉⋃1≤j≤k({u j}∪N Γ′(u j)). As
a consequence, L′ 2(u)=L′ 1,K(u)=L′ 1(u)=L 1(λ(u))=L 2(λ(u)).
Hence, C 2′ is (h−1)-correct for C 2. ◀
We build now an execution covering q f with Γ′: let C 0′ =(Γ′,L′ 0) defined by L′ 0(v)=q in
for all v ∈ V(Γ′ ). Obviously, C 0′ is n-correct. By Lemma A.2, there exists a sequence of
configurations (C i′ )1≤i≤n such that for all 1≤i≤n, C i′ −1→∗C i′ and C i′ is (n−i)-correct for
C i. Hence, C 0′ →∗C n′ and C n′ is 0-correct for C
n
and L′ n(ϵ)=L n(λ(ϵ))=L n(v f)=q f.
This allows to prove the following result.
▶ Theorem A.3. Cover and Cover [Trees] are equivalent.
B Phase-bounded protocols as an under-approximation
Phase-bounded protocols can be seen as a semantic restriction of general protocols in which
each process can only switch a bounded number of times between phases where it receives
messages and phases where it can send messages. When, usually, restricting the behavior of
processes immediately yields an underapproximation of the reachable states, we highlight
here the fact that preventing messages from being received can in fact lead to new reachable
states. This motivates our definition of phase-bounded protocols, in which a process always
ends in a reception phase.
Indeed, consider the protocol pictured on Figure 13a. The state q is not coverable:
3
to cover q , a node v needs to receive message a when it is on state q from one of its
3 1 2
neighbor v . By construction, v broadcasts message m before reaching q . Vertex v can
2 1 2 2
only broadcast message a when it is on state q . To reach q , vertex v visited exactly states
5 5 2
q ,q and q . From each of those states, there is an outgoing reception transition labelled
in 4 5
with m going to p. Hence, at any moment of the execution, the broadcast of message m by
vertexv wouldhavebroughtv inp,preventingthebroadcastofa. However,anaive2-phase
1 2
bounded unfolding of this protocol, in which we limit the number of phases of sending and
reception to 2, is illustrated in Figure 13b. In this protocol, (q 3,r,2) (hence q 3) is coverable:
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany!!m ?a
!!m ?a !!c (q1,b,1) (q2,b,1) (q3,r,2)
!!c q 1 q 2 q 3 qin ?c
!!b !!a
q in ?c (q4,r,1) (q5,b,2) (q6,b,2)
!!b !!a
q 4 q 5 q 6 ?m ?m
?m ?m (p,r,1)
p ?m (b)UnfoldingofP limitedto2phases: (q,b,i)means
thatthestateqisreachedinabroadcastphasewhen
(a) AnexampleofabroadcastprotocolP (q,r,i)meansthatitisreachedinareceptionphase.
Thenumberofthephaseisgivenbyi.
Figure 13 A protocol and its bounded unfolding showing that it may not be an underapproxima-
tion.
consider Γ=({v 1,v 2},{⟨v 1,v 2⟩}) and the following execution:
(Γ,{v 1↦q in,v 2↦q in})→(Γ,{v 1↦(q 1,b,1),v 2↦(q 4,r,1)})→(Γ,{v 1↦(q 1,b,1),
v 2↦(q 5,b,2)})→(Γ,{v 1↦(q 2,b,1),v 2↦(q 5,b,2)})→(Γ,{v 1↦(q 3,r,2),v 2↦(q 6,b,2)}).
In fact, in state (q 5,b,2) a process is not allowed to switch anymore, hence the transition
allowing to receive message m has been removed. Doing so, we have made state q coverable.
3
This shows that this type of bounded semantics does not give an underapproximation of the
coverable states, in spite of what was expected.
Actually, the reception of a message is something that is not under the control of a
process. If another process broadcasts a message, a faithful behavior of the system is that all
the processes that can receive it indeed do so, no matter in which phase they are in their own
execution. Hence, in a restriction that attempts to limit the number of switches between
sending and receiving phases, one should not prevent a reception to happen. This motivates
our definition of a phase-bounded protocol.
Let P =(Q,Σ,q in,∆) be a broadcast protocol, and k∈N.
Wedefinethek-unfoldingofP denotedbyP kasthefollowingprotocol: P k =(Q k,Σ,q in,∆ k)
with Q
k
={q0 ∣q ∈Q}∪{qb,j,qr,j ∣q ∈Q,1≤j ≤k}. To ease the notations we let qr,0 =q0,
qb,0 =q0 = for all q0 ∈Q 0.
∆
k
={(q0,τ,p0 )∣(q,τ,p)∈∆}
∪{(qr,j,α,pr,j )∣1≤j ≤k and (q,α,p)∈∆ and α∈{τ}∪?Σ}
∪{(qb,j,α,pb,j )∣1≤j ≤k and (q,α,p)∈∆ and α∈{τ}∪!!Σ}
∪{(qr,j,!!m,pb,j+1 )∣0≤j <k and (q,!!m,p)∈∆}
∪{(qb,j,?m,pr,j+1 )∣0≤j <k and (q,?m,p)∈∆}
∪{(qb,k,?m,pr,k )∣(q,?m,p)∈∆}.
Thelastcaseofthedefinitionof∆ implementsthefactthatweneverpreventareception
k
from occurring, even in the last phase.
The following lemma establishes that this definition of unfolding can be used as an
underapproximation for Cover.
▶Lemma B.1. q
f
can be covered in P if and only if there exist k∈N, y∈{r,b} and 0≤j ≤k
such that (q f,y,j) can be covered in P k.
Proof. Left-to-right direction: Assume that q f can be covered in P, and let C 0→C 1→
⋯→C
n
beanexecutionofP suchthatC i=(Γ,L i)forall0≤i≤nandthereexistsv
f
∈V(Γ)
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanysuch that L n(v f)=q f. For all v∈V, we define κ
v
a function associating to each 0≤i ≤n
the number and the type of phase in which vertex v is. More formally, κ v(0)=0 and for
0≤i<n,
κ
v(i+1)=⎧ ⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪
⎨ ⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪
⎩
(
(
(
(
κb
r
b
r
v,
,,
,
(j1
j1 i))))
)
i
q
i
it
q
i
otf
f
f
f,
,
t=
=
hq
qκ
κ
κ
κ′
′(
(
ev
v
v
vq
q
r∈
∈(
(
(
(
w,
,i
i
i
iQ
Q!
!)
)
)
)
i!
!
sm
m,
,=
=
=
=
em
m
.,
,0
0
(
(q
qr
b∈
∈a
a
′
′,
,)
)j
jn
nΣ
Σ∈
∈d
d
−
−∆
∆1
1C
C
)
),
,i
i
q
qa
a—
—
,
,v
v —
n
nq
q, ′→t
, →
d
d′
′t
∈
∈C
C
CC
Q
Qi
i
ii+
+
,
,—1
—v
v1
m
m—,
′→f
t
,
→wo
t∈
∈r
i
C
Ct
Σ
Σs
h
io
i+
+a
a1m
v
1n
nfe
∈
d
dwoN
rt
i(
(t=
(
sL
Lhv
o(
i
im′
v(
(q
)
v
v,
e
∈a
)
)!!
N,
,n
tm
?
?d
=
(m
m, v(q
′,
,q′
)L
L)
,
a!i
i∈
!+
+nm∆
1 1d(
(,,
v vq)
)′
)) )∈∈ ∈∆∆
∆,
We define k = max v∈V(Γ){x v ∣ κ v(n) = (x v,y),y ∈ {r,b}}. Since, for all 0 ≤ i < n, for all
v ∈V(Γ), κ v(i)≤κ v(i+1), it holds that k ≥{x
v
∣κ v(i)=(x v,y),y ∈{r,b},0≤i≤n}. We
now consider P k =(Q k,Σ,q i0 n,∆ k) the k-unfolding of P. For each 0≤i≤n, for all v∈V(Γ),
if L i(v)=q we let L′ i(v)=qκv(i). We now show C 0′ →C 1′ →⋯→C n′ is an execution of P
k
where for all 0≤i≤n, C i′ =(Γ,L′ i). Consider C 0′ =(Γ,L′ 0) with L′ 0(v)=q i0 n for all v∈V(Γ).
As κ v(0) = 0 for all v ∈ V(Γ), the induction property holds and C 0′ is initial. Assume we
proved that C 0′ →∗ C i′. We have to prove that C i′ →C i′ +1. Denote v
!
the vertex such that
C
i—v —!, →t
C i+1.
If t = (q 1,τ,q 2) for some q 1,q 2 ∈ Q, for all v ∈ V(Γ), κ v(i+1) = κ v(i) and if v ≠ v !,
L i+1(v) = L i(v) hence, L′ i+1(v) = L′ i(v). By definition of P k, (q 1κv!(i) ,τ,q 2κv!(i+1) ) ∈ ∆ k.
Hence, if α=τ, C i′ →C i′ +1.
Now let t=(q 1,!!m,q 2) for some m∈Σ and q 1,q 2∈Q. We start by observing that for all
v∈V(Γ)∖({v !}∪N(v !)), κ v(i+1)=κ v(i) and L i+1(v)=L i(v) hence, L′ i+1(v)=L′ i(v).
Observe that, either (a) κ v!(i+1) = (b,j) and κ v!(i) = (r,j −1) (or κ v(i) = 0) for
some j ≤ k, or (b) κ v!(i+1) = κ v!(i). In case (a), L′ i(v !) = q 1(r,j−1) or L′ i(v !) = q 10, and
L′ i+1(v !)=L i+1(v !)κv!(i+1) =L i+1(v !)(b,j) =q 2(b,j) . By definition, (q 1(r,j−1) ,!!m,q 2(b,j) )∈∆
k
(or
(q 10,!!m,q 2b,1 )∈∆ k).
In case (b), κ v(i) = κ v(i+1) = (b,j) for some 1 ≤ j ≤ k. Then, L′ i(v !) = q 1(b,j) and
L′ i+1(v !)=L i+1(v !)κv!(i+1) =L i+1(v !)b,j =q 2(b,j) . By definition, (q 1(b,j) ,!!m,q 2(b,j) )∈∆ k.
Let now v ∈ N(v !). If there is no q′ ∈ Q such that (L i(v),?m,L i+1(v)) ∈ ∆, then
L i(v)=L i+1(v) and κ v(i+1)=κ v(i). Hence L′ i+1(v)=L i+1(v)κv(i+1) =L i(v)κv(i) =L′ i(v).
Furthermore, by construction of P k, there is no transition (L′ i(v),?m,pκ ) ∈ ∆ k for some
pκ ∈Q
k
as otherwise, there would be a transition (L i(v),?m,p)∈∆, which contradicts the
fact that L i(v)=L i+1(v).
Let now v∈N(v !) such that (L i(v),?m,L i+1(v))∈∆. By definition of κ v, again, either
(a)κ v(i+1)=(r,j)andκ v(i)=(b,j−1)(orκ v(i)=0)forsome1≤j,or(b)κ v(i+1)=κ v(i).
In that case, κ v(i)=(r,j) for some j ≥1. In both cases, by construction of k, it holds that
j ≤k. Hence, by definition of ∆ k, in case (a), L′ i(v)=L i(v)(b,j−1) and L′ i+1(v)=L i+1(v)(r,j)
and (L′ i(v),?m,L′ i+1(v))∈∆ k, and in case (b), L′ i(v)=L i(v)(r,j) and L i+1(v)=L i+1(v)(r,j).
Hence, (L′ i(v),?m,L′ i+1(v))∈∆ k.
We conclude that C i′ →C i′ +1.
Hence, L′ n(v f) = q fκvf(n) and so there exists 0 ≤ j ≤ k and y ∈ {r,b} such that q fy,j is
coverable in P .
k
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyRight-to-left direction: Conversely, assume that there exist k ∈ N, 0 ≤ j ≤ k and
y∈{r,b} such that q fy,j is coverable in P k. Let C
0
→C
1
→⋯→C
n
an execution such that
C n = (Γ,L n) and there exists v f ∈ V(Γ) with L n(v f) = q fy,j. We show that there exists
an execution C 0′ → C 1′ → ⋯ → C n′ such that for all 1 ≤ i ≤ n, for C i′ = (Γ,L′ i) and any
vertex v ∈V(Γ), L′ i(v)=q if and only if there exists κ
v,i
∈{0}∪({r,b}×[0,n]) such that
L i(v)=qκv,i.
Let C 0′ = (Γ,L′ 0) with L 0(v) = q in for all v ∈ V(Γ). As L′ 0(v) = q i0 n for all v ∈ V(Γ),
the induction hypothesis holds. Assume we proved that C 0′ →∗ C i′ where for all v ∈V(Γ),
L′ i(v)=q if and only if there exists κ v,i∈{0}∪({r,b}×[0,n]) such that L i(v)=qκv,i.
Let C i′ +1 =(Γ,L′ i+1) be the configuration such that for all v ∈V(Γ), L′ i+1(v)=q if and
only if there exists κ
v,i+1
∈{0}∪({r,b}×[0,n]) such that L i+1(v)=qκv,i+1. We prove now
that C i′ →C i′ +1.
Denote C
i
—v —!, →t
C
i+1
and t=(q
1κv!,i,α,q 2κv!,i+1
)∈∆ k. From the definition of ∆ k, it holds
that (q 1,α,q 2) ∈ ∆. Hence, if α = τ, C i′ → C i′ +1, as for all other nodes, L′ i+1(v) = q if and
only if there exists κ v,i+1 ∈ {0}∪({r,b}×[0,n]) such that L i+1(v) = qκv,i+1. Furthermore,
L i+1(v)=L i(v)=qκv,i+1 hence L′ i(v)=q=L′ i+1(v).
Assumenowthatα=!!mforsomem∈Σandletv∈N(v !). Either(a)(L i(v),?m,L i+1(v))∈
∆ k, or (b) there is no p ∈ Q k such that (L i(v),?m,p) ∈ ∆ k. In case (a), by construction
of ∆ k, there exists (p 1,?m,p 2) ∈ ∆ such that L i(v) = pκ 11 and L i+1(v) = pκ 22 for some
κ 1,κ 2∈{0}∪({r,b}×[1,n]) Hence, (L′ i(v),?m,L′ i+1(v))∈∆.
In case (b), we show that there is no p ∈ Q such that (L′ i(v),?m,p) ∈ ∆. Assume by
contradiction that this is the case, and denote L i(v)=pκ
1
and (p 1,?m,p 2)∈∆. If κ=0, then
by definition of ∆ k, (pκ 1,?m,pr 2,1 )∈∆
k
and we reach a contradiction. If κ=(r,j) for some
1≤j ≤k, by definition of ∆ k,
(p( 1r,j) ,?m,p( 2r,j)
)∈∆
k
and again, we reach a contradiction.
If κ = (b,j), by definition of ∆ k:
(p( 1b,j) ,?m,p( 2r,j+1)
) ∈ ∆ k and we reach a contradiction.
Finally, if κ = (b,k) then, by definition of ∆ k:
(p( 1b,k) ,?m,p( 2r,k)
) ∈ ∆ k and we reached a
contradiction.
Hence, there is no transition (p 1,?m,p 2)∈∆ for some p 2∈Q.
WeconcludethatC i′ →C i′ +1. Hence,thereisanexecutionC 0′ →∗C n′ ofP withL n(v f)=q
f
and q is coverable in P. ◀
f
C Undecidability proof of Cover (Section 4)
Wereducethecoverabilityproblemofa Minskymachineto theCoverprobleminbroadcast
networks with 6-phase-bounded protocols.
Minsky Machines.
A Minsky Machine M is a tuple M =(Loc,Trans,ℓ 0,ℓ f,x 1,x 2) such that Loc is a finite state
of locations, ℓ in∈Loc, ℓ
f
∈Loc, x 1,x
2
are two counters and Trans is a finite set of transitions
such that Trans⊆Loc×{inc(x i),dec(x i),test(x i)∣i=1,2}×Loc. We denote a configuration
of M by a tuple (ℓ,x 1,x 2) where ℓ ∈ Loc and x 1,x 2 ∈ N are values of the two counters
(respectively x 1 and x 2). Let (ℓ,x 1,x 2) and (ℓ′,x′ 1,x′ 2) be two configurations, and t∈Trans.
We note (ℓ,x 1,x 2)—→t (ℓ′,x 1,x 2) with t=(ℓ,op,ℓ′ ) and one of the following conditions holds:
op=inc(x i) for some i∈{1,2} and x′ i=x i+1 and x′ 3−i=x 3−i;
op=dec(x i) for some i∈{1,2} and x′ i=x i−1 and x′ 3−i=x 3−i;
op=test(x i) for some i∈{1,2} and x′ i=x i=0 and x′ 3−i=x 3−i.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyThehaltingproblemasksifthereisasequenceoftransitionst 1,...,t
n
suchthat(ℓ in,0,0)—t →1
(ℓ 1,x1 1,x1 2)—t →2 ⋯—t →n (ℓ f,xn 1,xn 2) for xi 1,xi 2 ∈N for all 1≤i≤n and xn 1 =xn 2 =0. It is known
to be undecidable. We denote X for the set of counters {x 1,x 2}.
C.1 Definition of P.
Let M =(Loc,Trans,ℓ in,ℓ f,x 1,x 2) be a Minsky Machine. The protocol P of the reduction
is described in Figure 14 and is defined on a finite alphabet Σ that we define now. We
start by defining OP={test x,todo x+1,todo x−1,todo x+1,todo
x−1
∣x∈X}. Next, for 0≤i≤2,
we define OPi = {opi ∣ op ∈ OP} and OKi = {donei op ∣ op ∈ OP}. We can now define the
alphabet Σ={done, 0, 1, 2}∪⋃0≤i≤2OPi ∪OKi. We also define for 0≤i≤2 two operations:
i⊖1=(i−1) mod3 and i⊕1=(i+1) mod3.
A transition from a sub protocol (an orange box) to a state means that from any states
of the sub protocol, there is an outgoing transition with the same label and to the same
state. Hence, any state q of P M has outgoing transitions (q,?1, ), (q,?2, ) and (q,?0, ).
The main idea is to build a protocol that will ensure, dur(cid:47)ing an ini(cid:47)tialization pha(cid:47)se,
a specific organization among processes depicted in Figure 15. In particular, after the
initialization phase, processes will be organized as line v ,v ,...,v with the first process v
0 1 n 0
in a state ℓ corresponding to the initial location of the machine, the last process v in a
in n
state qtail, and for 1≤i<n, process v
i
is on state zbi where b i=i mod3. This way, a process
v
i
(for some 0≤i<n) can distinguish between its two neighbors (intuitively between its right
and left). For instance, if n<5, process v
4
is on a state z1 and has its left neighbor v
3
on z0
and its right neighbor v on a state z2.
5
P M, P
tail
and P
i
for 0≤i≤2 will be defined on the same alphabet of messages Σ.
We describe P M =(QM,∆M ) in Figure 16, this is where the machine is simulated: the
process v evolves in the sets Loc, we will see that if it takes a transition of the machine
0
which should not be taken (a false test to 0, a decrement not possible, or an increment
not feasible because of lack of processes), then other processes will fail in their execution,
and q will not be covered.
f
We describe P 1 = (Q1,∆1 ) in Figure 18. The processes evolving on P 1 will simulate
counters’ values, each of them representing one unit of one of the counter: when the
process is on x1 [resp. x1] it represents a unit of counter x [resp. x ].
1 2 1 2
P
2
and P
3
are obtained from P
1
by replacing each j ∈{0,1,2} appearing in the protocol
(states and transitions) by j⊕1 for P
2
and j⊖1 for P 0. As in P 1, processes evolving on
P
2
or P
0
will simulate counters’ values: for x ∈X, a process on x2 or x0 represents one
unit of x.
WedescribeP tail=(Qt,∆t )inFigure17. Theprocessv
n
willcheckthatalltheoperations
have been correctly executed. When it will receive message "done" (first sent by the
process P ), it will reach state q .
M f
State is a deadlock state (there is no outgoing transitions from ). In order for
P to be p(cid:47)hase-bounded, we actually duplicate state as much as need(cid:47)ed so there is no
contradictions (one state per reception phase).(cid:47)For instance, if there are two receptions
transitions (q,?m, ), (q′,?m′, ) with q and q′ not in the same phase, we duplicate into
two states , ′ su(cid:47)ch that (q,?m(cid:47), ), and (q′,?m′, ′ ). For ease of notation, when ref(cid:47)erring
to any of th(cid:47)os(cid:47)e deadlock states, w(cid:47)e use . (cid:47)
As a result, we get the following lem(cid:47)ma.
▶ Lemma C.1. P is 6-phase-bounded.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany?Σ
?Σ
(cid:47)?1 !!$ ?0,1,2
q 1 q 2 ℓ in P M
!!0
qi
!!i
qi
?i⊕1
qi
!!$
zi P i
(cid:47)?0,1,2
1 2 3
?i⊖1 for i=0,1,2
?Σ ?Σ ?m,m≠$
q in (cid:47)
?Σ ?Σ
?1 (cid:47)qtail !!2 (cid:47)qtail ?$ (cid:47)qtail P tail q f ?0,1,2
1 2
(cid:47)
Figure 14 Description of P, the protocol of the reduction.
v 0∶ℓ
in
v 1∶z1 v 2∶z2 v 3∶z0 v 4∶z1 ... v n−1∶z1 v n∶qtail
Figure 15 Particular shape of configurations from which we can simulate the Minsky machine.
ℓ
!!todo0
x+1 q t !!todo
x+10
ℓ′ ℓ !!todo0 x−1 q t !!todo x−10 ℓ′
?m,
?m, ?m, ?m,
m∉{todo1 , ?m, ?m,
m∉OK1 x+1 m∉OK1 m∉{todo1 ,
done 1} m∉OK1 x−1 m∉OK1
x+1 done 1}
x−1
(b) Translation of a decrement transition t =
((cid:47)a) Translation(cid:47)of a decrement tr(cid:47)ansition t = ((cid:47)ℓ,dec(x),ℓ′). (cid:47) (cid:47)
(ℓ,inc(x),ℓ′).
!!test0 !!test 0
ℓ x q t x ℓ′
!!done
ℓ qM
?m, ?m, ?m, f f
m∉OK1 m≠test1 m∉OK1
x (d) Endofthesimulation.
(c) Translation of a test transition t =
((cid:47)ℓ,test(x),ℓ′). (cid:47) (cid:47)
Figure 16 Description of P .
M
?op1
?m,∀m∈Σ
qtail qt
op
?op1
?op1
(cid:47)∀op∈{todo x+1,todo x−1∣ ?done ∀op∈{done x+1,done x−1, (cid:47)
x∈X}
test ∣x∈X}
q x
f
Figure 17 Description of P .
tail
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany!!op1
?m ?m
z1 r o1
p
∀op∈OP
m∉(OP0 ∪OK2 ) !!op1 for all m∉{op0,op2 }
(cid:47)
!!todo1
(cid:47)
x+1
?m
q1
m∉{todo x+10 ,done x+12 } x
1
(cid:47) !!done
x+1
?test0 x,?m
x1
!!op1
r o1 p,x
?m
∀op∈OP∖{test x}
m∉(OP0 ∪OK2
) !!op1
m∉{op0,op2
}
(cid:47)
!!todo1
(cid:47)
x−1
?m
q′1
m∉{todo x−10 ,done x−12 } x
1
(cid:47) !!done
x−1
!!op1
?m ?m
z1 r o1
p
∀op∈OP
m∉(OP0 ∪OK2
) !!op1
m∉{op0,op2
}
(cid:47) (cid:47)
?done
!!done
d1 d′1
?m,∀m∈Σ
Figure 18 Description of P . We draw two s(cid:47) tates z1 for readability’s sake. P is obtained by
1 2
replacing each j∈{0,1,2} by j⊕1 and P by replacing each j∈{0,1,2} by j⊖1.
0
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyProof. We give the partition of states satisfying the 6-phase-bounded protocols condition.
Q 0={q in};
Qb 1={q 1} and Qr 1={q 1i ∣i∈{0,1,2}}∪{q 1tail }∪{ };
Qb 2={q 2i ∣i∈{0,1,2}}∪{q 2tail } and Qr 2={q 2}∪{(cid:47)};
Qb 3={ℓ,q t,q fM ∣ℓ∈Loc,t∈Trans} and Qr 3={q 3i ∣(cid:47)i∈{0,1,2}}∪Qt ∪{ };
Qb 4={q∈Qi ∖ ,di,d′ii∈{0,1,2}} and Qr 4={ }; (cid:47)
Qb 5=∅ and Qr 5(cid:47)={di ∣i∈{0,1,2}}∪{ }; (cid:47)
Qb 6={d′i ∣i∈{0,1,2}} and Qr 6={ }.(cid:47)
(cid:47)
◀
Note that P is also k-phase-bounded for any k > 6 by taking Qr 7 = { }, Qb 7 = ∅ and
Qy j =∅ for any j ≥8 and y∈{r,b}. (cid:47)
In the rest of this section, we denote b i=i mod3 for all i∈N.
C.2 Completeness of the Reduction.
▶LemmaC.2. Ifthereisatransitionsequencet 1,...t
n
suchthat(ℓ in,0,0)—t →1 (ℓ 1,x1 1,x1 2)—t →2
⋯—t →n (ℓ f,0,0), then there exist C ∈I,C′ =(Γ′,L′ )∈C, such that C →∗ C′ and there exists
v∈V(Γ′ ) such that L′ (v)=q f.
Proof. Wedenotebym′themaximalvaluereachedbycountersduringthemachineexecution,
i.e. m′ =max 1≤i≤n(xi 1+xi 2). We define m as m′ +1. We suppose wlog that m mod3=1, if
it is not the case, we redefine m as the first integer greater than m equal to 1 modulo 3.
Define Γ=(V,E) such that: V ={v 0,v 1,...,v m,v m+1} and E ={(v i,v i+1)∣0≤i<m+1},
and take C 0=(Γ,L 0) where for all v∈V, L 0(v)=q in.
We define the following sequence of configurations: C
0
—v —0, —t →0 C
1
—v —1, —t →1 ... —v —m —+1 —,t —m —+ →1
C
m+2—v —0, —t →′
0 C
m+2—v —1, —t →′
1
⋯—vm —, —t′
m →C
2m+3
where:
t
i=⎧ ⎪⎪⎪
⎨
( (q qi 1bn i,, !! !! b0 i, ,q q1 2b)
i)
f fo or
r
i 1= ≤0
i≤m
⎪⎪⎪ ⎩ (q 1tail,!!2,qtail ) for i=m+1.
and
t′
i={
( (q q2 3bi, ,!! !$ !$, ,ℓ zin bi)
)
f fo or
r
i 1= ≤0
i≤m.
Denote C m+2 = (Γ,L m+2) and C 2m+3 = (Γ,L 2m+3), it holds that: L m+2(v 0) = q 2, and
L m+2(v i)=q 3bi forall1≤i≤mandL m+2(v m+1)=q 2tail. And: L 2m+3(v 0)=ℓ in,L 2m+3(v m+1)=
qtail and for all 1≤i≤m, L 2m+3(v i)=zbi.
We will now build C 0′ →+ C 1′ →+ ...→+ C n′ such that for all 0≤i≤n, C i′ =(Γ,L′ i), and:
L′ i(v 0)=ℓ i, L′ i(v m+1)=qtail, and xi 1=∣{v∣L′ i(v)=xj 1,0≤j ≤2}∣, xi 2=∣{v∣L′ i(v)=xj 2,0≤j ≤
2}∣, and for all 1≤j ≤m, L′ i(v j)∈{zbj,xb 1j,xb 2j}.
For i=0, we take C 0′ =C 2m+3. By construction, it respects the conditions. Assume we
built C i′ for some 0≤i<n, and consider (ℓ i,xi 1,xi 2)—ti —+ →1 (ℓ i+1,xi 1+1,xi 2+1 ). For readability’s
sake,wenotet=(ℓ,op,ℓ′ )andwerenamexi 1,xi 2,xi 1+1,xi 2+1 byx 1,x 2,x′ 1,x′ 2,finallywerename
C′ by C.
i
By induction hypothesis, C = (Γ,L) is such that L(v 0) = ℓ, L(v m+1) = qtail and x 1 =
∣{v ∣ L(v) = xj 1,0 ≤ j ≤ 2}∣, x 2 = ∣{v ∣ L(v) = xj 2,0 ≤ j ≤ 2}∣, and for all 1 ≤ j ≤ m,
L(v j)∈{zk,xk 1,xk
2
∣k=j mod3}. We distinguish the following cases:
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyop=inc(x) with x∈X, then by definition of m, x 1+x 2<m−1. Hence, ∣{v∣L(v)=xj 1,0≤
j ≤2}∣+∣{v ∣L(v)=xj 2,0≤j ≤2}∣<m−1, and so there exists v f ∈{v 1,...,v m−1} such
that L(v f)∉{xj 2,xj 1∣0≤j ≤2} with 1≤f ≤m. Let us denote f the first such index. By
hypothesis, L(v f)∈{zk,xk 1,xk 2} for k=f mod3, hence L(v f)=zk.
We denote y the counter such that {x,y}={x 1,x 2}. We also denote p
i
∶=L(v i), and p′
i
the state such that:
p′
i=⎧ ⎪⎪⎪⎪⎪⎪
⎨
⎪⎪⎪⎪⎪⎪
⎩
r
qr
r
xii
i
bb
b
bnn
n
ii
i
icc
c x,x
xx
x
i
ii
i
f
ff
f
p
ip
p
ii
i
===
=
fyz xb bbi ii, ,,i ii≠ ≠≠f
ff
Consider the following sequence:
C0 —v —0, —(ℓ —,! —!to —d —o0 x —+1 —,q —t →) C1 —v —1, —(p —1 —,!! —to —d —ob x —+1 1 —,p —′ 1 →) C2 —v —0, —(q —t, —!!t —o —do —x+ —1 —0, —ℓ′ →) C3 —v —2, —(p —2 —,!! —to —d —ob x —+2 1 —,p —′ 2 →)
C4 —v —1, —(p —′ 1 —,!! —to —do —x+ —1 —b1 —,p —1 →) C5 —v —3, —(p —3 —,!! —to —d —ob x —+3 1 —,p —′ 3 →) C6 —v —2, —(p —′ 2 —,!! —to —do —x+ —1 —b2 —,p —2 →)
C7 —v —4, —(p —4 —,!! —to —d —ob x —+4 1 —,p —′ 4 →) ⋯—v —f− —1, —(p —f —−1 —,! —!to —d —o xb —+f 1 —−1 —,p —′ f− —1 →) C2(f−1) —v —f− —2 —,( —p′ f —−2 —,! —!t —od —o —x+ —1b —f− —2 —,p —f− —2 →)
C2f−1 —v —f, —(p —f —,!! —to —d —ob x —+f 1 —,p —′ f →) C2f —v —f− —1 —,( —p′ f —−1 —,! —!t —od —o —x+ —1b —f− —1 —,p —f− —1 →)
C2f+1 —v —f+ —1 —,(p —f —+1 —,! —!d —on —e —x+ —1b —f+ —1 —,p —′ f+ —1 →) C2f+2 —v —f, —(p —′ f —,!! —d —on —ex —+1 —bf —, —xb —f →)
C2f+3 —vf —+ —2, —(p —f+ —2 —,!! —do —n —ex —+1 —bf —+ —2, —p′ b —f+ —2 →) ⋯—v —m —,( —pm —, —!! —do —n —ex —+1 —bm —, —p′ m —→)
C2m —v —m —−1 —,( —p′ m —− —1, —!! —do —n —ex —+1 —bm —− —1, —pm —− —1 →) C2m+1 —v —m —,(p —′ m —, —!!d —o —ne —x+ —1b —m —,p —b —m →) C2m+2
Note that if f = 1, v 1 broadcasts incb x1 and done x+1b1, and every vertices except v 0
broadcast overlined messages as well. Furthermore, as f ≤m−1, v
m
always broadcasts
todo x+1bm ⋅done x+1bm, hence L2m (v m+1)=qt and L2m+2 (v m+1)=qtail. At the end of
todox+1
the sequence, C2m+2 =(Γ,L2m+2 ) is such that L2m+2 (v 0)=ℓ′, L2m+2 (v m+1)=qtail, and,
L2m+2 (v f)=xbf and for all 1≤i≤m, i≠f, L2m+2 (v i)=L(v i).
op=dec(x), the sequence is analogous, this time we justify the existence of one process
on a state xj for some 0≤j ≤2 by induction hypothesis.
op = test(x), the only difference is that the propagated message does not change, all
processes can propagate the message as no processes is on a state xi for some 0≤i≤2
(this is true by induction hypothesis).
Hence, we built a sequence of configurations C 0′ →+C 1′ →+ ⋯→+C n′ such that C n′ =(Γ,L n)
with L n(v 0)=ℓ f, L n(v m+1)=qtail and for all 0≤i≤m, L n(v i)=zbi. Finally, we build the se-
quenceleadingtothefinalconfiguration,fromC n′: C n′ —v —0, —(ℓ —f —,!! —do —n —e, —q fM —→) C n′ +1—v —1, —(d —b1 —, —!!d —o —ne —,d —′b —1 →)
C n′ +2 —v —2, —(d —b2 —, —!!d —o —ne —,d —′b —2 →) ⋯ —v —m —,( —db —m —,! —!d —on —e —,d —′bm —→) C n′ +m+1. Denote C n′ +m+1 = (Γ,L n+m+1), it
holds that L n+m+1(v m+1)=q f. ◀
C.3 Correctness of the Reduction.
This subsection is devoted to prove the following lemma.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany▶ Lemma C.3. If there exist C ∈ I, C′ = (Γ′,L′ ) ∈ C such that C →∗ C′ and there exists
v ∈V(Γ′ ) such that L′ (v)=q f, then there exists a transition sequence t 1,...,t n such that
(ℓ in,0,0)—t →1 (ℓ 1,x1 1,x1 2)—t →2 ⋯—t →n (ℓ f,0,0).
We say that a process v∈V(Γ) is active if it broadcasts (at least) one message during the
execution. We denote C 0→C 1→⋯→C
n
where for each 0≤i≤n, C i=(Γ,L i), C 0=C and
C n=C′. Furthermore, we denote v
f
the process covering q f. Lastly, for sake of readability,
for C,C′ ∈ C, m ∈ Σ and v ∈ V(Γ), we denote C —v —, →a C′ when there exists a transition
(q,!!a,q′ )∈∆ for some q,q′ ∈Q such that C —v —,( —q, —!!a —,q —′ →) C′.
C.3.1 First step: Structure.
In a first step we prove that from the execution between C and C′, one can extract a set
of vertices V = {v 0,v 1,...,v m,v m+1} for some m ∈ N forming a line (i.e. for all 0 ≤ i ≤ m,
⟨v i,v i+1⟩∈E(Γ)). And such that v
m+1
covers q
f
and neighbors of vertices in V which are
not in V are not active (i.e. they do not broadcast anything). This subsubsection is devoted
to prove the following lemma.
▶ Lemma C.4. There exists V ={v 0,v 1,...,v m,v m+1}⊆V(Γ), such that for all 0≤i≤m,
⟨v i,v i+1⟩ ∈ E(Γ) and ∃j 0,j 1,...,j m such that L j0(v 0) = ℓ in, L jm(v m+1) = qtail and for all
1≤i≤m, L ji(v i)=zbi and for all other vertex v∈V(Γ)∖V which is a neighbor of a vertex
v′ ∈V, v is not active. Furthermore, m mod3=1.
Byconstructionoftheprotocol, v receivesmessage"done"fromaprocessv beforereaching
f 1
q . This process again either sends "done" from state ℓ or receives it before broadcasting it
f f
from a new process v
2
(note that v 2≠v
f
as "done" can be sent only once and v
f
broadcasts
it after the broadcast of v ). In the second case, we can reiterate the reasoning. We do so
1
until finding a process (let us denote it v ) sending "done" from ℓ and we note v ,...,v
m+1 f 1 m
the intermediate processes. The process v exists as there is a finite number of processes.
m+1
Furthermore, ⟨v f,v 1⟩∈E(Γ) and for all 0≤i<m, ⟨v i,v i+1⟩∈E(Γ). We rename v
i
by v
m+1−i
for all 1 ≤ i ≤ m+1, and v f by v m+1. Denote V = {v 0,...,v m+1}. Note that there exists
j
0
<j
m+1
such that L j0(v 0)=ℓ
in
as v
0
broadcasts "done" from ℓ f, and L jm+1(v m+1)=qtail
as v reaches state q from qtail after v reached ℓ . Furthermore, observe that for all
m+1 f 0 f
v∈V ∖{v 0,v m+1}, there exists i∈{0,1,2} such that there exists j 1<j with L j(v)=zi.
We get the two following lemmas.
▶ Lemma C.5. v has only one active neighbor before broadcasting "done".
0
▶ Lemma C.6. v has only one active neighbor before receiving "done".
m+1
Indeed, otherwise, v
0
(or v m) has two neighbors sending two messages i 1,i
2
∈{0,1,2}, by
construction of P, one of the message will bring v in . With a similar argument, we get
0
the following lemma. (cid:47)
▶ Lemma C.7. Let v k ∈ V for some 1 ≤ k ≤ m, v k has only two active neighbors before
broadcasting "done".
We can now prove the following lemma.
▶ Lemma C.8. There exist j 0<j 1<⋯<j m, such that for all 0≤k≤m+1, C
jk
—v —k, —b →k C jk+1.
Furthermore m+1=2 mod3.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyProof. We prove the lemma by induction on 0≤k≤m+1. For k=0, it follows directly from
the construction of P and the fact that there exists j such that L j(v 0)=ℓ
f
(v
0
is the first
process to broadcast "done"). Denote j
0
such that C
j0
—v —0, →0
C j0+1.
Assume the property to hold for some 1≤k≤m+1 and denote j 0<j 1<⋯<j
k
such that
for all 0≤k′ ≤k, C
j k′
—v k —′, —b k →′ C
j
k′+1.
Case k+1<m+1. As k+1<m+1, by construction of V, there exists i∈{0,1,2} such
that there exists j with L j(v k+1)=zi. By Lemma C.7, v
k+1
has exactly two active neighbors,
which are by construction of V, v
k
and v k+2. Denote i
k+1
∈{0,1,2} the integer such that
v
k+1
receives "done" from zik+1. By induction hypothesis, C
jk
—v —k, —b →k C jk+1. We distinguish
two cases: (a) k=0 and (b) k>0.
Subcase (a) k =0. Assume v
k+1
broadcasts i
k+1
from an index j <j 0. Observe that
L j(v 0) = q in and so L j+1(v 0) = q 1ik+1 which contradicts the fact that v 0 broadcasts "done"
from ℓ f, hence, j 0 < j, and so L j0(v k+1) = q in, and L j0+1(v 1) = q 11. Hence i k+1 = 1 and
k+1=1.
Subcase k >0. Consider v k−1, by induction hypothesis j
k−1
<j
k
with C
jk−1
—v —k− —1, —bk —− →1
C
jk−1+1
and C
k
—v —k, —b →k C k+1. Hence, as by Lemma C.7, v
k
has only two active neighbors, only
v
k+1
canbroadcast(b k+1) mod3oncev
k
broadcastb k. Hence,i k+1=(b k+1) mod3=b k+1.
Hence there exists j k+1>j
k
such that C
jk+1
—v —k+ —1, —bk —+ →1 C jk+1+1.
Case k+1=m+1. By construction of V, there exists j m′
+1
such that L
j′
(v m+1)=qtail.
m+1
By Lemma C.6, v has exactly one active neighbor and this neighbor broadcasts "1". As
m+1
m≥1, consider v m. By induction hypothesis, and construction of P, there exists a unique
j
m
such that C
jm
—vm —, —bm
→C jm+1. Hence, b
m
=m mod3=1, finally there exists j
m+1
>j
m
such that C
jm+1
—v —m —+1 —, →2 C jm+1+1. ◀
We are now ready to prove Lemma C.4.
Proof of Lemma C.4. Let V ={v 0,...,v m+1} such that, there exist j 0,j 1,...,j m+1 with
L j0(v 0)=ℓ f,L jm(v m+1)=qtail andforall1≤k≤m,thereexistsi∈{0,1,2}withL jk(v k)=zi.
From Lemma C.8 there exists j 0′ <⋅⋅⋅<j m′
+1
with C
j′
—b →k C
j′
for all 0≤k≤m+1, and
k k+1
(m+1) mod3=2. Furthermore, L j′(v 0)=q
1
and L j′+1(v 0)=q 2. In the same way, for all
1 1
1 ≤ k ≤ m, L j k′ +1(v k) = q 2bk and L j k′ +1+1(v k) = q 3bk. Lastly, L j m′ +1+1(v m+1) = q 2tail. Hence, by
construction of P, there exist j 0′′...j m′′,j m′′
+1
such that L j′′(v i)=zbi for all 1≤i≤m, and
L j′′(v 0)=ℓ
in
and L
j′′
(v m+1)=qtail. i □
0 m+1
C.3.2 Second step: the simulation.
We are now ready to extract the execution of the machine from the execution between C
and C′. Fix V ={v 0,...,v m+1} the set of vertices from Lemma C.4. We forget about nodes
not in V, as they are useless for v to cover q : either they are neighbors of some node in V
f f
and so they are inactive, either they are not connected to v through an inactive neighbor,
f
or they are not connected to v .
f
∗
Let C,C′ ∈ C and v ∈ V(Γ), we denote C —∣ →v C′ whenever C = C′ or there exist
(u 1,t 1),...(u N,t N), with N ∈ N and for all 1 ≤ i ≤ N, u i ∈ V(Γ)∖{v}, t i ∈ ∆, and
C 1—u —1 —,t →1 —u —2 —,t →2 ⋯—u —N —,tN →C′.
Let op∈OP, we denote the set OK(op) as follows:
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyOK(todo x+1)={todo x+1,done x+1} for some x∈X;
OK(todo x−1)={todo x−1,done x−1} for some x∈X;
OK(done x+1)={done x+1} for some x∈X;
OK(done x−1)={done x−1} for some x∈X;
OK(test x)={test x} for some x∈X.
We denote Act={x+1,x−1,x=0∣x∈X}.
We start by some observations.
▶ Lemma C.9. For all 0 < i < m+1, the word broadcast by v i belongs to the language
E i=b i⋅$⋅(∑op∈OP,ok∈OK(op)opbi⋅okbi)∗ ⋅done. Furthermore, the word broadcast by v
0
belongs
to the language E 0=0⋅$⋅(∑op∈{todo
,todo
,test∣x∈X}(op0 ⋅op0 ))∗ ⋅done.
x+1 x−1 x
Proof. Follows from the construction of V and P. ◀
We denote n i the index from which v i broadcasts "done" for all 0 ≤ i ≤ m. It holds that
n 0<⋯<n
m
by construction of V.
▶ Lemma C.10. For all 0 ≤ i < m, 0 < j 1 < j 2 ≤ n i, op ∈ OP, ok ∈ OK(op), such that
∗
C j1 —v —i, —op —b →i C j1+1—∣v →i C j2 —v —i, —ok —b →i C j2+1 there exists a unique j 1<j 3<j 2 such that C j3 —vi —+1 —,w →
C
j3+1
for some w∈Σ. Furthermore, if ok=op 2, then w=opb 2i+1.
Proof. We denote b∶=b
i+1
for readability’s sake, and denote ok=op 2. Recall that n i<n
i+1
and b=b i⊕1. Hence:
if op 2=todo
x+1
for some x∈X, then L j2(v i+1)∈{r ob
p
2,r ob p,x 21,r ob p,x 22,q xb };
if op 2=todo
x−1
for some x∈X, then L j2(v i+1)∈{r ob
p
2,r ob p,x 21,r ob p,x 22,q x′b };
otherwise, L j2(v i+1)∈{r ob
p
2,r ob p,x 21,r ob p,x 22}.
Indeed, otherwise, L j2+1(v i+1)= as (L j2(v i+1),?op 2bi, )∈∆ b. Furthermore:
(cid:47) (cid:47)
if op=test
x
for some x∈X, then L j1(v i+1)∈{zb,yb ∣y∈X∖{x}};
otherwise, L j1(v i+1)∈{zb,yb ∣y∈X}.
Indeed, otherwise, L j2+1(v i+1)= as(L j1(v i+1),?opbi, )∈∆ b. Notethatanypathbetween
L j1+1(v i+1) and L j2(v i+1) requi(cid:47)res at least one broad(cid:47)cast from v i+1, and in particular a
broadcast of opb 2. Hence, there exists j 1<j 3<j
2
such that C
j3
—vi —+1 —,o —p →b 2 C j3+1, consider the
smallest such index. We now show that this is the unique index between j and j from
1 2
which v broadcasts something.
i+1
If there exists j 1 < j 4 < j 3 such that C j4 —vi —+1 —,w → C j4+1 for some w ∈ Σ, and take j 4 the
largestsuchindex. Byconstructionofj
4
andj 3,L j4+1(v i+1)∈{zb,yb ∣y∈X},andsow∈OKb.
Hence,itholdsthatL j4(v i)∉{r ob pi 2,r ∗ob pi, 2x1,r ob pi, 2x2,q xbi,q x′bi},asotherwise,(L j4(v i),?w, ). This
contradicts the fact that C
j1+1
—∣v →i C
j4
and C
j1
—v —i, —op —b →i C j1+1. With a similar ar(cid:47) gument,
there is no j 3<j 5≤j
2
such that C
j5
—vi —+1 —,w →C
j5+1
for some w∈Σ.
◀
▶ Lemma
∗
C.11. For all 0≤i<m, 0<j
1
<j
2
≤n i, op∈OP, w ∈Σ, such that C
j1
—v —i, —op —b →i
C
j1+1
—∣v →i C
j2
—vi —,w →C j2+1, there exists a unique j
1
<j
3
<j
2
such that C
j3
—v —i+ —1, —w →′ C
j3+1
for
some w′ ∈Σ. Furthermore, w′ =ok′b with ok′ ∈OK(op).
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyProof. We denote b∶=b i+1 for readability’s sake. Note that from Lemma C.9, w ∈OPbi ∪
{done}. Recall that n i < n i+1 and b = b i⊕1. Hence, L j2(v i+1) ∈ {zb,xb 1,xb 2}, as otherwise
L j2+1(v i+1)= , hence (L j2(v i+1),?w, )∈∆ b. Furthermore,
if op=tod(cid:47) o
x+1
for some x∈X, then(cid:47) L j1(v i+1)∈{r ob p,r ob p,x1,r ob p,x2,q xb };
if op=todo
x−1
for some x∈X, then L j1(v i+1)∈{r ob p,r ob p,x1,r ob p,x2,q x′b };
otherwise, L j1(v i+1)∈{r ob p,r ob p,x1,r ob p,x2}.
Note that any path between L j1(v i+1) and L j2(v i+1) requires at least one broadcast from
v
i+1
of a message w′, and if w′ is the last broadcast from v
i+1
before reaching L j2(v i+1), it
holds that:
if op=todo x+1, then w′ ∈{todo x+1b ,todob x+1};
if op=todo x−1, then w′ ∈{todo x−1b ,todob x−1};
otherwise, w′ =opb.
Hence w′ =ok′b with ok′ ∈OK(op). We now show that j
3
is the unique index between j
1
and
j from which v broadcasts something. Remember that it has been chosen as the greatest
2 i+1
such index.
If there exists j 1 < j 4 < j 3 such that C j4 —v —i+ —1, —w →′′ C j4+1 for some w′′ ∈ Σ, and take j 4
the largest such index. By construction of j
3
and j 4, L j4+1(v i+1)∈{r ob p,r ob p,x,q xb,q x′b ∣x∈X},
and so w′′ ∈ OPb. Hence, it holds that L j4(v i) ∉ {r ob pi,r ob pi,x ∣ op ∈ OP,x ∈ X}, as otherwise,
∗
(L j4(v i),?w, ). This contradicts the fact that C j1+1—∣v →i C
j4
and C
j1
—v —i, —op —b →i C j1+1.
◀
(cid:47)
▶ Lemma C.12. Let 0 < j 10 < j 20 < n 0 and op ∈ {todo x+1,todo x−1,test x ∣ x ∈ X} such that
C j0 —v —0, —w →0 C j0+1 —∣v →0 ∗ C j0 —v —0, —w →0′ C j0+1 and w 0 = op0 and w 0′ = op0. Then there exists a
1 1 2 2
unique sequence of indices j 11,j 21,...,j 1m,j 2m such that for all 1≤i≤m:
j 1i−1 <j 1i <j 2i−1 <j 2i <n i, and
C
ji
—v —i, —w →i C ji+1→∗C
ji
—v —i, —w →i′ C
ji+1
for some w i,w i′ ∈Σ, and
1 1 2 2
if w i−1=op ibi−1 for some op i∈OP, then w i=opb ii and w i′ =okb ii with ok i∈OK(op i).
Proof. Let 0 < j 10 < j 20 < n 0 and op ∈ {todo x+1,todo x−1,test x ∣ x ∈ X} such that C j0 —v0 —,o —p →0
∗ 1
C j0+1—∣v →0 C
j0
—v0 —,o —p →0 C j0+1.
1 2 2
We build the sequence of indexes j1,j1,...,jm,jm and the sequence of operations
1 2 1 2
op 1,...,op m such that w i = opb ii and w i′ = okb ii with ok i ∈ OK(op i) inductively. Using
Lemma C.10, there exists a unique j 10 <j 11 <j 20 such that C
j1
—v —1, —w →1 C
j1+1
for some w 1∈Σ,
1 1
and it holds that w
1
=op1. As j 20 <n 0, there exists j 20 <n≤n
0
such that C
n
—v —0, →u C
n+1
for
some u∈Σ. Using Lemma C.11, there exists a unique j 20 <j 21 <n such that C
j1
—v —1, —w →1′
C
j1+1
2 2
for some w 1′ ∈Σ with w 1′ =ok1
1
and ok 1∈OK(op).
Define op 1 =op. We found a unique pair of indexes j 11,j 21 such that j 10 <j 11 <j 20 <j 21 ≤
n 0<n
1
andC
j1
—v —1, —w →1 C j1+1→∗C
j1
—v —1, —w →1′ C
j1+1
forsomew 1,w 1′ ∈Σ. Furthermore, w 0′ =op0
1 1 2 2
and w 1=op1
1
and w 1′ =okb
1
with ok 1∈OK(op 1).
Assumewehavebuiltj 11,j 21,...,j 1k,j 2k forsomek<m. AnddenoteC
jk
—v —k, —op —b
k
→k
C
jk+1
and
1 1
C
jk
—v —k, —ok —b
k
→k
C
jk+1
with ok
k
=op′ k. Using Lemma C.10, there exists a unique j 1k <j 1k+1 <j 2k
2 2
such that C
j 1k+1
—vk —+ —1, —w —k+ →1 C
j 11+1
for some w k+1∈Σ. Furthermore w k+1=op′ kbk+1.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyAs j 2k < n k, there exists j 2k < n ≤ n k such that C n —vk —, →u C n+1 for some u ∈ Σ. Using
LemmaC.11,thereexistsauniquej 2k <j 2k+1 <n≤n
k
<n
k+1
suchthatC
jk+1
—vk —+ —1, —w —k′ + →1 C
jk+1+1
2 2
for some w k′ +1∈Σ. Furthermore, w k′ +1=ok′b and ok′ ∈OK(op′ k).
◀
Let 0 < j 10 < j 20 < n 0 and op ∈ {todo x+1,todo x−1,test x ∣ x ∈ X} such that C j0 —v0 —,o —p →0
∗ 1
C j0+1—∣v →0 C
j0
—v0 —,o —p →0 C j0+1. WedenoteSeq(j 10,j 20 )theuniquesequenceofindexesj 11,j 21,...,
1 2 2
jm,jm defined in the previous lemma.
1 2
▶ Lemma C.13. If op=test x for some x∈X, then for all 1≤i≤m, L ji(v i)=L ji+1(v i)∈
1 2
{zbi,ybi ∣y≠x}.
Proof. FromLemmaC.12,asOK(test x)={test x},itholdsthatforall1≤i≤m,C
ji
—vi —,t —es —tb x →i
1
C ji+1, and C
ji
—v —i, —te —st —xb →i C ji+1. As C ji+1—∣v →i ∗ C ji, by construction of the protocol, we have
1 2 2 1 2
that that L ji(v i)=L ji+1(v i)∈{zbi,ybi ∣y≠x}. ◀
1 2
▶ Lemma C.14. If op=todo
x+1
for some x∈X, then, there exists a unique 1≤p≤m such
that L jp(v p) = zbp, L jp+1(v p) = xbp, and for all 1 ≤ i ≤ m, i ≠ p, it holds that L ji(v i) =
1 2 1
L ji+1(v i)∈{zbi,xb 1i,xb 2i}.
2
Proof. Denote op 0,...,op m∈OP, ok 0,...,ok m∈OK as defined in Lemma C.12.
We start by oberving the following: Let 0 ≤ i < m such that op i = done x+1, then
op i+1 = done x+1 and ok i+1 = done x+1. Indeed, it holds that ok i = done x+1 by definition of
OK(done x+1), hence . by Lemma C.12, op i+1=done x+1, and so ok i+1=done
x+1
by definition
of OK(done x+1).
As a consequence, L ji+1(v i+1)=L ji+1+1(v i+1)∈{zbi+1,xb 1i+1,xb 2i+1}.
1 2
Now let 0 < i ≤ m, such that op i = todo x+1, then op i−1 = todo x+1 and ok i−1 = todo x+1.
Indeed, by Lemma C.12, as op
i
=todo x+1, it must be that ok
i−1
=todo x+1. And from C.9,
ok i−1∈OK(op i−1). Note that the only op∈OP such that todo
x+1
∈OP(op) is todo x+1, hence
op i−1=todo x+1.
As a consequence, L ji−1(v i+1)=L ji−1+1(v i−1)∈{zbi−1,xb 1i−1,xb 2i−1}.
1 2
Recall that op 0 = todo x+1 and observe that op m = done x+1, as otherwise, necessarily
L j 1m+1(v m+1)= . As a consequence, there exists a unique 0<p<m such that op p=todo x+1
andop p+1=don(cid:47)e
x+1
anditholdsthatforalli<p,op i=todo x+1andforalli>p,op i=done x+1.
Observethat,fromLemmaC.12,asop p+1=done x+1,ok p=done x+1,andsobyconstruction
of P, it holds that L jp(v p)=zbp, L jp+1(v p)=xbp.
1 2 ◀
▶ Lemma C.15. If op=todo
x−1
for some x∈X, then, there exists a unique 1≤p≤m such
that L jp(v p) = xbp, L jp+1(v p) = zbp, and for all 1 ≤ i ≤ m, i ≠ p, it holds that L ji(v i) =
1 2 1
L ji+1(v i)∈{zbi,xb 1i,xb 2i}.
2
Proof. Same proof as Lemma C.14. ◀
We now associate to j 10,j 20 two configurations prec(j 10,j 20 ) = (ℓ,x 1,x 2), succ(j 10,j 20 ) =
(ℓ′,x′ 1,x′ 2) of the machine as follows:
ℓ=L j0(v 0), x 1=∣{i∣L ji(v i)=xb 1i,1≤i≤m}∣, x 2=∣{i∣L ji(v i)=xb 2i,1≤i≤m}∣;
1 1 1
ℓ′ =L j0+1(v 0), x′ 1=∣{i∣L ji+1(v i)=xb 1i,1≤i≤m}∣, x′ 2=∣{i∣L ji+1(v i)=xb 2i,1≤i≤m}∣.
2 2 2
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany▶ Lemma C.16. prec(j 10,j 20 )—→succ(j 10,j 20 )
Proof. Denote op 0,...,op m∈OP, ok 0,...,ok m∈OK as defined in Lemma C.12.
Observe that by construction, L j0(v 0)=ℓ, L j0+1(v 0)=ℓ′ for some ℓ,ℓ′ ∈Loc.
1 2
If op 0=todo x+1, then by construction, there exists t=(ℓ,inc(x),ℓ′ )∈Trans. Furthermore,
by Lemma C.14, there exists a unique 1 ≤ p < m such that L jp(v p) ≠ L jp+1(v p) and
1 2
L jp+1(v p)=xbp and L jp(v p)=zbp. Denote i∈{1,2} such that x=x i and prec(j 10,j 20 )=
(ℓ,2 x 1,x 2). Hence, succ(1 j 10,j 20 )=(ℓ′,x′ 1,x′ 2) with x′ i=x i+1, and x′ 3−i=x 3−i.
Ifop 0=test x,thenbyconstruction,thereexistst=(ℓ,test(x),ℓ′ )∈Trans. Denotei∈{1,2}
such that x = x i By Lemma C.13, for all 1 ≤ k ≤ m, L jk(v k) = L jk+1(v k) ∈ {zbk,xb 3k −i}.
1 2
Hence, if prec(j 10,j 20 )=(ℓ,x 1,x 2), then x i=0. Denote succ(j 10,j 20 )=(ℓ′,x′ 1,x′ 2), it holds
that x′ 1=x 1, x 2=x′
2
and x′ i=x i=0.
Ifop 0=todo x−1, thenbyconstruction, thereexistst=(ℓ,dec(x),ℓ′ )∈Trans. Furthermore,
by Lemma C.15, there exists a unique 1 ≤ p < m such that L jp(v p) ≠ L jp+1(v p) and
1 2
furthermore, L jp+1(v p) = zbp and L jp(v p) = xbp. Denote i ∈ {1,2} such that x = x i and
prec(j 10,j 20 )=(ℓ,2 x 1,x 2). Hence, succ(1 j 10,j 20 )=(ℓ′,x′ 1,x′ 2) with x′ i=x i−1, and x′ 3−i=x 3−i.
◀
We now denote j < j 1,0 < j 2,0 < ⋯ < j 1,k < j 2,k < n 0 for some k ∈ N the indices such
that: C
0
—∣v →0 ∗ C
j
—v —0, →0 C
j+1
—∣v →0 ∗ C
j1,0
—v —0, —op —0 →0 C
j1,0+1
—∣v →0 ∗ C
j2,0
—v —0, —op —0 →0 C
j2,0+1
—∣v →0 ∗
C j1,1⋯C
j2,k
—v —0, —op —k →0 C j2,k+1—∣v →0 ∗ C
n0
withop0,...,opk ∈{todo x+1,todo x−1,test x∣x∈{x 1,x 2}}.
▶ Lemma C.17. prec(j 1,0,j 2,0)=(ℓ in,0,0).
Proof. Denote Seq(j 1,0,j 2,0)=j 11,j 21,...,j 1m,j 2m.
First note that by construction, L j0(v 0)=ℓ in.
1 ∗ ∗ ∗
In fact: for all 1≤i≤m, it holds that C
0
—∣v →i C
xi
—vi —,b →i C
xi+1
—∣v →i C
yi
—v —i, →$ C
yi+1
—∣v →i
C for some indices x ,y . Assume this is not the case and take the smallest index p such
ji i i
1
that this is not the case: there exists at least two indices from which it broadcasts b and
p
$ as L jp(v p) ∈ {zp,xp 1,xp 2}. Assume now, there are more than two indices from which v p
1 ∗ ∗
broadcasts, i.e. there exist x
p
<y
p
<z
p
such that C
0
—∣v →p C
xp
—v —p, —b →p C
xp+1
—∣v →p C
yp
—v —p, →$
∗
C yp+1 —∣v →p C zp —vp —,w → C zp+1 →∗ C j 1p. By construction of the protocol, w ∈ OPbp. If p = 1,
then L zp(v 0)=ℓ in, and so L zp+1(v 0)= which contradicts the existence of j 1,0. Assume
p > 1, then L zp(v p−1) = zbp−1 and so L zp(cid:47)+1(v p−1) = which contradicts the fact that vp−1
broadcasts "done". (cid:47)
∗ ∗ ∗
Hence,forall1≤i≤m,itholdsthatC 0—∣v →i C
xi
—vi —,b →i C xi+1—∣v →i C
yi
—v —i, →$ C yi+1—∣v →i C
j 1i
forsomeindicesx i,y i. Asaconsequence,L ji(v i)=zbi,andsoprec(j 1,0,j 2,0)=(ℓ in,0,0). ◀
1
▶ Lemma C.18. For all 0≤i<k, succ(j 1,i,j 2,i)=prec(j 1,i+1,j 2,i+1).
Proof. Let 0 ≤ i < k such that succ(j 1,i,j 2,i) ≠ prec(j 1,i+1,j 2,i+1). Denote succ(j 1,i,j 2,i) =
(ℓ,x 1,x 2) and prec(j 1,i+1,j 2,i+1)=(ℓ′,x′ 1,x′ 2). Denote Seq(j 1,i,j 2,i)=j 11,j 21,...,j 1m,j 2m and
∗
Seq(j 1,i+1,j 2,i+1)=i1 1,i1 2,...,im
1
,im
2
. Byconstruction,C j2,i+1—∣v →0 C
j1,i+1
hence,ℓ=ℓ′. Hence,
thereexists1≤p≤msuchthatL jp+1(v p)≠L ip(v p). Considerthefirstsuchindexp. ByC.12,
2 1
L jp+1(v p) ∈ {zbp,xb 1p,xb 2p}. Again, by C.12, L ip(v p) ≠ and so there exists j 2p +1 ≤ j < ip 1
2 1
such that C j —vp —,w → C j+1. Take j the first such inde(cid:47)x, by construction of P, w ∈ OPbp.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyIf p = 1, then L j+1(v 0) = , as w ∈ OPbp and L j+1(v 0) = L j1,i(v 0) = ℓ. If p > 1, then
L j(v p−1)=L jp−1+1(v p−1)∈{(cid:47)zbp−1,xb 1p−1,xb 2p−1}. Hence, L j+1(v p−1)= which contradicts the
2
existence of ip−1. (cid:47) ◀
1
We are now ready to prove Lemma C.3:
Proof of Lemma C.3. We found a sequence of indices j <j 1,0<j 2,0<⋯<j
1,k
<j
2,k
<n
0
such that:
prec(j 1,0,j 2,0)=(ℓ in,0,0) (Lemma C.17)
for all 0≤j ≤k, prec(j 1,j,j 2,j)—→succ(j 1,j,j 2,j) (Lemma C.16)
for all 0≤i<k, succ(j 1,i,j 2,i)=prec(j 1,i+1,j 2,i+1) (Lemma C.18)
succ(j 1,k,j 2,k)=(ℓ f,x 1,x 2) for some x 1,x 2∈N, as L j2,k(v 0)=L n0(v 0)=ℓ f.
Puttingeverythingtogether,wegetasequence(ℓ in,0,0)—→succ(j 1,0,j 2,0)—→succ(j 1,1,j 2,1)—→
⋯—→succ(j 1,k,j 2,k)=(ℓ f,x 1,x 2). □
D Proofs of Section 5
D.1 Proof of Lemma 5.1
Proof of Lemma 5.1. Assume there exists Γ = (V,E) in Graphs, C = (Γ,L) ∈ I and
D =(Γ,L′ )∈CP and v ∈V(Γ) such that C →∗ D and L′ (v)=q f. Thanks to Theorem 2.4,
we can assume that Γ∈Trees and without loss of generality that v=ϵ (i.e. it the root of the
tree). We consider the execution:
C 0—v —1, —δ →1 C 1—v —2, —δ →2 C 2—v —3, —δ →3 ⋯—v —n, —δ →n C
n
such that C 0 = C and C n = D and C i = (Γ,L i) for all i ∈ [0,n]. Note in particular that
L n(ϵ)=q f. Without loss of generality we can as assume that ∣v n∣≤1 otherwise it means
that the last step of this execution does not affect the root node and hence we could have
stop it at C . We denote by m the number of steps in this executions labelled by the
n−1
root node or the node at height 1 whose label in the previous step belongs to Q 0∪Qb 1,
i.e. m = ∣{i ∈ [1,n] ∣ v i = ϵ or (∣v i∣ = 1 and L i−1(v i) ∈ Q 0 ∪Qb 1)}∣. Intuitively m is the
number of steps in the execution, which can affect the root node or which an internal
move of a node at height 1 which stays in the Q 0∪Qb
1
component. Note that since we are
dealing with 1-phase-bounded protocol if for some i∈[1,n] and some nodes v∈V, we have
L i(v)∉Q 0∪Qb
1
then L j(v)∉Q 0∪Qb
1
for all j ∈[i,n]. We consider then the configuration
Γ′ ∈Stars which is a restriction of the tree Γ to nodes of height at most one, i.e. Γ′ =(V′,E′ )
with V′ ={v∈V ∣∣v∣≤1} and E′ ={(v,v′ )∈E ∣v,v′ ∈V′ }.
We will show how to build an execution of length m from C′ = (Γ′,L′ 0) ∈ I to a
configuration D′ = (Γ′,L′′′ ) with L′′′ (ϵ) = q f. For this matter we consider an injective
function f ∶[1,m]↦[1,n] which select m indices of the step of the previously introduced
execution keeping only the one labelled by nodes in V′. Formally f is the unique injective
function respecting the following conditions:
for all i∈[1,m],v f(i)=ϵ or (∣v f(i)∣=1 and L f(i)−1(v f(i))∈Q 0∪Qb 1) ;
for all i,j ∈[1,m], if i<j then f(i)<f(j).
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanySince v n∈V′, we have f(m)=n. We shall now show that there exists an execution of the
form:
C 0′ —v —f( —1) —,δ —f( —1 →) C 1′ —v —f( —2) —,δ —f( —2 →) C 2′ —v —f( —3) —,δ —f( —3 →) ⋯—vf —(m —) —,δ —f( —m →) C m′
where C 0′ = (Γ′,L′ 0) and for all i ∈ [1,m] we have C i′ = (Γ′,L′ i) with L′ i satisfying the
following condition: L′ i(ϵ) = L f(i)(ϵ) and for all v ∈ V′ ∖{ϵ}, if L f(i)(v) ∈ Q0 ∪Qb 1 then
L′ i(v)=L f(i)(v). We shall now see how to build this execution by induction. First note that
if we extend f to 0 by setting f(0) = 0 for i = 0, we have that L′ 0(ϵ) = L f(0)(ϵ) = q in and
for all v ∈ V′ ∖{ϵ}, L′ 0(v) = L f(0)(v) = q in and q in ∈ Q0. Now assume that we have build
v ,δ v ,δ v ,δ v ,δ
C 0′ ——f( —1) ——f( —1 →) C 1′ ——f( —2) ——f( —2 →) C 2′ ——f( —3) ——f( —3 →) ⋯—f —(i —) —f —(i →) C i′ with C i′ =(Γ′,L′ i) with L′ i satisfying
the following condition: L′ i(ϵ)=L f(i)(ϵ) and for all v∈V′ ∖{ϵ}, if L f(i)(v)∈Q0 ∪Qb
1
then
L′ i(v)=L f(i)(v). Consider the node v f(i+1), we have two cases:
1. v f(i+1)=ϵ. Since between C
f(i)
and C
f(i+1)−1
the root node did not perform an internal
action, nor any broadcast and none of the node at height 1 performed a broadcast, we
deducethatL f(i+1)−1(v f(i+1))=L f(i)(v f(i+1))=L′ i(v f(i+1)),hencefromC i′ thetransition
v ,δ
δ
f(i+1)
can be taken from the root node. And we have C i′ ——f( —i+ —1) ——f( —i+ —1 →) C i′
+1
with
C i′ +1 = (Γ′,L′ i+1). Note that we have necessarily L′ i+1(ϵ) = L f(i+1)(ϵ). And for all
v ∈V′ ∖{ϵ}, if L f(i+1)(v)∈Q0 ∪Qb 1, it means that the action of the root node did not
affect v then L f(i+1)(v)=L f(i+1)−1(v) and by the same reasoning as we did for the root
node, since L f(i+1)−1(v)∈Q0 ∪Qb
1
, we have L f(i+1)−1(v)=L f(i)(v)=L′ i(v). But in the
transition from C′ to C′ the same action still not affect v, this allows us to deduce that
i i+1
L′ i+1(v)=L′ i(v). Hence L′ i+1(v)=L f(i+1)(v).
2. v f(i+1)≠ϵ. In that case ∣v f(i+1)∣=1 and L f(i+1)−1(v f(i+1))∈Q 0∪Qb 1. Here again we can
deducethatL f(i+1)−1(v f(i+1))=L f(i)(v f(i+1))=L′ i(v f(i+1)),hencefromC i′ thetransition
δ
f(i+1)
can be taken from the node v f(i+1). Hence we have C i′ —v —f( —i+ —1) —,δ —f( —i+ —1 →) C i′
+1
with
C i′ +1=(Γ′,L′ i+1). Consider v∈V′ ∖{ϵ}, if v=v f(i+1), it is clear that L′ i+1(v)=L f(i+1). If
v≠v f(i+1)andL f(i+1)(v)∈Q0 ∪Qb 1,wecandeducethatL′ i+1(v)=L′ i(v)becausetheaction
ofnodeatheight1doesnotaffecttheothernodeatheight1,andL f(i+1)(v)=L f(i+1)−1(v)
for the same reason, and L f(i+1)−1(v)=L f(i)(v) by definition of f and L f(i)(v)=L′ i(v).
Hence L′ i+1(v)=L f(i+1)(v). If v =ϵ, we can show that L′ i(v)=L f(i)(v)=L f(i+1)−1(v)
and this allows us to deduce that L′ i+1(v)=L f(i+1)(v).
We have hence proven that we can build the execution C 0′ —v —f( —1) —,δ —f( —1 →) C 1′ —v —f( —2) —,δ —f( —2 →)
v ,δ v ,δ
C 2′ ——f( —3) ——f( —3 →) ⋯—f —(m —) ——f( —m →) C m′ where C m′ =(Γ′,L′ m) such that L′ m(ϵ)=L f(m)(ϵ)=L n(ϵ)=
q . □
f
D.2 Proof of Lemma 5.2
Proof of Lemma 5.2. Let (q,Λ)∈Qb ×2Qb. We consider F subset of Qb ×2Qb, built according
to the following rules:
Initially, F =∅;
for all transitions (q,τ,q′ )∈∆, add (q′,Λ) to F;
for all transitions (q,!!m,q′ ) ∈ ∆, add (q′,Λ′ ) to F where Λ′ = Λ∖{q′′ ∈ Λ ∣ ∃q′′′ ∈
Q.(q′′,?m,q′′′ )∈∆};
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyfor all transitions (q′,τ,q′′ )∈∆, with q′ ∈Λ add (q,Λ∪{q′′ }) and (q,(Λ∖{q′ })∪{q′′ })
to F (the latter case being here to deal with the case where in the configuration with
broadcast-print (q,Λ) there is a single node labelled with q′);
for all transitions (q′,!!m,q′′ )∈∆ such that q′ ∈Λ and there does not exist q′′′ ∈Q with
(q,?m,q′′′ )∈∆, add (q,Λ∪{q′′ }) and (q,(Λ∖{q′ })∪{q′′ }) to F .
It is clear that F can be built in polynomial time and a case analysis allows to show
F ={(q′,Λ′ )∣(q,Λ)⇒(q′,Λ′ )}. □
D.3 Proof of Lemma 5.3
Proof of Lemma 5.3.
(i) LetC 1=((V 1,E 1),L 1),C 1′ =((V 1,E 1),L 1)andC 2=((V 2,E 2),L 2)bestar-configurations
such that C 1—v, →δ C 1′ and C 1⪯C 2. First note that if v≠ϵ and L 1(v)∉Qb, then C 1′ ⪯C
2
and C 2→∗C 2. If v=ϵ, then L 2(v)=L 1(v) by definition of ⪯, hence we have C 2—v, →δ C 2′
and one can show that C 1′ ⪯C 2′ (the root node have obviously the same label and if some
nodes at height one are affected because of a broadcast from C to C′, their label will go
1 1
out of Qb in C′ and the nodes with the same label will be affected similarly going to C′).
1 2
If v ≠ϵ and L 1(v)∉Qb, then there exists a node v′ ∈V 2∖{ϵ} such that L 2(v′ )=L 1(v)
and we have C
2
—v —′, →δ C 2′ with C 1′ ⪯C 2′ (here if δ is a broadcast it should affect the root
node from C and C similarly and does not affect the other nodes).
1 2
(ii) AssumeC 1=((V 1,E 1),L 1),C 1′ =((V 1,E 1),L 1)andC 2=((V 2,E 2),L 2)areb-configurations
such that C 1 —v, →δ C 1′ and bprint(C 1) = bprint(C 2) and C 1 ⪯ C 2. From the previous
point, we easily deduce that there exists a b-configuration C 2′ such that C 1′ ⪯ C 2′ and
C
2
→∗ C 2′ . However it might be the case that bprint(C 1′ )≠bprint(C 2′ ). In that case,
we have necessarily bprint(C 1′ )=(q,Λ 1) and bprint(C 2′ )=(q,Λ 2) with Λ 1 ⊂Λ 2. This
happens if v≠ϵ is the only node labelled by L 1(v)∈Qb in C
1
and in C
2
there are strictly
more than 1 node labelled by L 1(v). Assume {v′ ∈ V 2 ∣ L 2(v) = L 1(v)} = {v 1,...,v k}
thentheexecutionC
2—v —1, →δ
C
2,1—v —2, →δ
C
2,2—v —3, →δ
C
2,3⋯—v —k, →δ
C
2,k
isavalidexecution. Note
that along this execution the state of the root node does not change, because C′ is a
1
b-configuration hence C
1
—v, →δ C 1′ with v ≠ϵ does not affect the root node (otherwise it
would perform a reception and its state would not be in Qb anymore). Furthermore we
have C 1′ ⪯C 2′
,k
and C 2→∗C 2′
,k
and bprint(C 1′ )=bprint(C 2′ ,k).
(iii) LetC =((V,E),L),beab-configurationsuchthatC in→∗C forsomeinitialconfiguration
C in and such that bprint(C) = (q,Λ). Let N ∈ N. We assume that Λ = {q 1,...,q k}.
There exist k nodes u 1,...,u
k
in V ∖{ϵ} such that L(u i)=q
i
for all i∈[1,k]. Assume
furthermore that we have an execution of the form:
C 0—v —1, —δ →1 C 1—v —2, —δ →2 C 2—v —3, —δ →3 ⋯—v —n, —δ →n C
n
with C 0 = C in and C n = C. Here again since C is a b-configuration and q i ∈ Qb
for all i ∈ [1,k] , none of the transitions δ i performed by a node v i different than ϵ
changes the state of ϵ and none of the transitions performed by ϵ changes the states
of nodes u 1,...,u k. We build an initial star configuration C i′ n = ((V′,E′ ),L′ in) where
V′ =V ∪{w 1,1,w 1,2,...,w 1,N,w 2,1,w 2,2,...,w 2,N,...,w k,1,w k,2,...,w k,N} with w i,j is a
nodeofdepthonesuchthatw
i,j
=max(v∈V∖{ϵ})+(i−1)∗N+jandE′isdefinedsuchthat
(V′,E′ ) is a star with root ϵ. Now we build an execution from C i′ n to C′ =((V′,E′ ),L′ )
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyfollowing the same steps as the execution from C
in
to C and replacing each step —vℓ —,δ →ℓ
with v ℓ=u
i
for some i∈[1,k], by the sequence —vℓ —,δ →ℓ —w —i, —1, —δ →ℓ ⋯—w —i, —N —,δ →ℓ . It is easy to see
that at the end bprint(C)=bprint(C′ )=(q,Λ) and ∣{v∈V′ ∖{ϵ}∣L′ (v)=q′ }∣≥N for
all q′ ∈Λ.
□
D.4 Proof of Lemma 5.4
Proof of Lemma 5.4. Let (q,Λ)∈Qb ×2Qb. First assume that there exist two b-configurations
C in∈I and C such that C in→∗C and bprint(C)=(q,Λ). Hence there exists an execution
of the form C 0→C 1→⋯→C n with C 0=C in and C n=C. Let (q i,Λ i)=bprint(C i) for all
i∈[0,n]. Bydefinitionof⇒,wehave(q 0,Λ 0)⇒(q 1,Λ 1)⇒⋯⇒(q n,Λ n),hence(q 0,Λ 0)⇒∗
(q n,Λ n). Since C
0
is an initial configuration and (q 0,Λ 0)=bprint(C 0), we have q
0
=q
in
and Λ 0∈{∅,{q in}} and by definition we have (q n,Λ n)=bprint(C n)=bprint(C)=(q,Λ).
Now assume that (q in,Λ in)⇒∗ (q,Λ) with Λ in∈{∅,{q in}}. Hence we have (q 0,Λ 0)⇒
(q 1,Λ 1) ⇒ ⋯ ⇒ (q n,Λ n) with (q 0,Λ 0) = (q in,Λ in) and (q n,Λ n) = (q,Λ). We reason by
induction on n to show that for all i∈[0,n], there exist two b-configurations C in∈I and C i
such that C in→∗C
i
and bprint(C i)=(q i,Λ i). If n=0, then it is clear that there exists an
initial b configuration C in∈I such that bprint(C in)=(q 0,Λ 0) and C in→∗C in.
Suppose the property holds for i ∈ [0,n−1] and let us prove it still holds for i+1.
By induction hypothesis, there there exist two b-configurations C in ∈ I and C i such that
C in→∗C
i
and bprint(C i)=(q i,Λ i).
Since(q i,Λ i)⇒(q i+1,Λ i+1),thereexiststwob-configurationsC i′ =((V i′,E i′ ),L′ i)andC
i+1
such that C i′ →C i+1 and bprint(C i′ )=(q i,Λ i) and bprint(C i+1)=(q i+1,Λ i+1). We let N =
max q′∈Qb(∣{v∈V i′ ∣L i(v)=q′ }∣). Since C
in
→∗ C
i
and bprint(C i)=(q i,Λ i), using Lemma
5.3.(iii), there exists an initial configuration C i′ n and a b-configuration C i′′ =((V i′′,E i′′ ),L′ i′ )
such that C i′ n →∗ C i′′ and bprint(C i′′ ) = (q i,Λ i) and ∣{v ∈ V i′′ ∣ L′ i′ (v) = q′ }∣ ≥ N for all
q′ ∈Λ i. By definition we have C i′ ⪯C i′′. By Lemma 5.3.(ii), there exists a b-configuration
C i′ +1 such that C i+1⪯C i′ +1 and bprint(C i+1)=bprint(C i′ +1)=(q i+1,Λ i+1) and C i′′ →∗C i′ +1.
We deduce that we have C i′ n→∗C i′
+1
and bprint(C i′ +1)=(q i+1,Λ i+1). □
D.5 Unary VASS and the control state reachability problem
We present here the syntax and semantics of (unary) Vector Addition System with States
(VASS). In our context a VASS V is a tuple (S,X,T) where: S is a finite set of control
states, X is a finite set of variables taking their value in the natural and T is a finite set
of transitions of the form (s,a,s′ ) with s,s′ ∈S and a∈{x++,x−−∣x∈X}∪{skip}. A
configuration of such a VASS is a pair (s,ν) with s ∈ S and ν ∶ X ↦ N. We define the
transition relation ▷ between VASS configurations as follows: (s,ν)▷ (s′,ν′ ) iff there exists
a transition (s,a,s′ ) in T one of the following condition holds:
a=skip and ν =ν′, or,
a=x++ and ν′ (x)=ν(x)+1 and ν′ (x′ )=ν(x′ ) for all x′ ∈X∖{x}, or,
a=x−− and ν′ (x)=ν(x)−1 and ν′ (x′ )=ν(x′ ) for all x′ ∈X∖{x}.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyRemark that if ν(x)=0 then it is not possible to take the transition (s,x−−,s′ ) from (s,ν).
We denote by ▷∗ the reflexive and transitive closure of ▷. The control state reachability
problem for VASS can be defined as follows:
VASSControlReach
Input: A VASS V =(S,X,T), an initial configuration (s ,ν ) and a state s ∈S;
in in f
Question: Does there exist ν′∶X↦N such that (s ,ν )▷∗(s ,ν′) ?
in in f
From [17,20], we know that VASSControlReach is ExpSpace-complete.
D.6 Proof of Lemma 5.5
Proof of Lemma 5.5. Let (q,Λ) ∈ Qb ×2Qb. From the 1-phase-bounded protocol P =
(Q,Σ,q in,∆), we build a VASS V =(S,X,T) as follows:
S =Q∪(Q×δ)∪{s in};
X =Qb;
T is the smallest set verifying the following conditions:
(s in,q′ ++,s in)∈T for all q′ ∈Λ (initialisation phase adding processes in Λ);
(s in,skip,q)∈T;
for all (q 1,τ,q 2)∈∆, we have (q 1,skip,q 2)∈T (central node does an internal action);
forallδ=(q 1,τ,q 2)∈∆withq 1∈Qbandallq′ ∈Q,wehave(q′,q 1−−,(q′,δ)),((q′,δ),q 2+
+,q′ )∈T (node at height one does an internal action);
forallδ=(q 1,!!m,q 2)∈∆and(q′,?m,q′′ )∈∆,wehave(q′,q 1−−,(q′′,δ)),((q′′,δ),q 2+
+,q′′ )∈T (node at height one broadcasts a message received by the root);
forallδ=(q 1,!!m,q 2)∈∆andallq′ ∈Qsuchthattheredeosnotexistq′′ inQverifying
(q′,?m,q′′ )∈∆, we have (q′,q 1−−,(q′,δ)),((q′,δ),q 2++,q′ )∈T (node at height one
broadcasts a message not received by the root).
Intuitively, the control state of the VASS tracks the state of the root whereas the
counters count how many processes are in states Qb. One can verify that there exist a
b-configuration C and a star-configuration C f = (Γ f,L f) such that bprint(C) = (q,Λ)
and L f(ϵ) = q f and C →∗ r C f iff there exists ν′ ∶ X ↦ N such that (s in,ν in) ▷∗ (q f,ν′ )
where ν in(q)=1 for all q ∈Λ and ν in(q)=0 for all q ∈Qb ∖Λ. We have hence shown that
given (q,Λ) ∈ Qb ×2Qb, proving whether there exist a b-configuration C = (Γ f,L) and a
star-configuration C f =(Γ f,L f) such that bprint(C)=(q,Λ) and L f(ϵ)=q f and C →∗ r C f
reduces to the control state reachability problem for VASS, VASSControlReach, which
is ExpSpace-complete.
□
D.7 Proof of Theorem 5.6
Thanks to Theorems 2.4 and 5.1, we have to prove that given 1-phase-bounded-protocol
P = (Q,Σ,q in,∆) and q f ∈ Q, deciding whether there exists Γ ∈ Stars, C = (Γ,L) ∈ I and
D=(Γ,L′ )∈CP such that C →∗D and L′ (ϵ)=q f is an ExpSpace-complete problem.
WebeginwiththeupperboundprovidinganNExpSpacealgorithm. LetP =(Q,Σ,q in,∆)
be a 1-phase-bounded protocol and q
f
∈Q. We first guess a broadcast-print (q,Λ)∈Qb ×2Qb
and show we have (q in,Λ in)⇒∗ (q,Λ) with Λ in∈{∅,{q in}}. This boils down to a reachabil-
ityqueryinthegraph(Qb ×2Qb,⇒)whichcanbeachievedinNPSpacethankstoLemma5.2
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyandbecausethenumberofverticesinthisgraphissmallerthan∣Q∣∗2∣Q∣. ThankstoSavitch’s
theorem, we can do this reachability query in PSpace. Then we look for a b-configuration
C′ = (Γ f,L) and a star-configuration C f = (Γ f,L f) such that bprint(C) = (q,Λ) and
L f(ϵ)=q
f
and C →∗
r
C f. Thanks to Lemma 5.5, this can be done in ExpSpace. The overall
procedure gives rise to an NExpSpace algorithm and using again Savitch’s theorem, we
obtain an ExpSpace-algorithm.
Let us show that this algorithm is complete. Assume there exist Γ∈Stars, C =(Γ,L)∈I
andD=(Γ,L′ )∈CP suchthatC →∗DandL′ (ϵ)=q f. Sincetheprotocolis1-phase-bounded,
there exists a b-configuration C′ such that C →∗C′ →∗ r D. If q f ∉Qb, take for C′ =(Γ,L′′ )
the last configuration in the execution C →∗ D such that L′′ (ϵ) ∈ Qb and otherwise take
C′ = D. Thanks to Lemma 5.4, if bprint(C′ ) = (q,Λ), we have (q in,Λ in) ⇒∗ (q,Λ) with
Λ in∈{∅,{q in}}.-AsL′ (ϵ)=q
f
andC′ →∗
r
D,wecanconcludethatouralgorithmiscomplete.
We shall now show it is sound. Assume there exists (q,Λ) ∈ Qb × 2Qb such that
(q in,Λ in) ⇒∗ (q,Λ) with Λ in ∈ {∅,{q in}} and such that there exist a b-configuration
C′ = (Γ f,L) and a star-configuration C f = (Γ f,L f) verifying bprint(C′ ) = (q,Λ) and
L f(ϵ) = q f and C′ →∗ r C f. Thanks to Lemma 5.4, there exist two b-configurations
C in ∈ I and C = ((V,E),L) in C such that C in →∗ C and bprint(C) = (q,Λ). We de-
note by N = max q′∈Qb(∣{v ∈ V ∣ L(v) = q′ }∣). Using Lemma 5.3.(iii), there exists an
initial configuration C i′ n and a b-configuration C′′ = (Γ′′,L′′ ) such that C i′ n →∗ C′′ and
bprint(C) = bprint(C′′ ) = (q,Λ) and ∣{v ∈ V(Γ′ )∖{ϵ} ∣ L′ (v) = q′ }∣ ≥ N for all q′ ∈ Λ.
But we have then that C′ ⪯ C′′. Thanks to Lemma 5.3.(i) applied to each transition of
the execution C′ →∗ r C f, we deduce that there exists C f′ = (Γ′ f,L′ f) such that C f ⪯ C f′
and C′′ →∗ C f′, Since C f ⪯ C f′ and L f(ϵ) = q f we deduce that L′ f(ϵ) = q f. Since we have
C i′ n→∗C′′ →∗C f′, our algorithm is sound.
It remains to prove the lower bound. For this matter, we provide a reduction from
VASSControlReach,thecontrolstatereachabilityproblemforVASS.Theintuitionbeing
that the root node keeps track of the states in S and the other nodes represent the value
of the counters, the value of X at a certain time being the number of processes in state
x . Then the nodes encoding the counters will only perform broadcast saying whether they
1
increment or decrement a counter and if at some point the root node receives an action on
a counter, it is not suppose to do according to its control state, it will go in an error state
err from which it will not be able to reach the final state anymore. Let V =(S,X,T) be a
VASS, (s in,ν in) an initial configuration and s f ∈S. Without loss of generality we assume
that ν in(x)=0 for all x∈X. We build the following broadcast protocol P =(Q,Σ,q in,∆)
with:
Q={q in,err}∪S∪{x 0,x 1∣x∈X};
Σ={x++,x−−∣x∈X};
∆ is the smallest set satisfying the following conditions:
(q in,τ,s in) belong to ∆;
for all m∈Σ, (q in,?m,err) belong to ∆;
for all x∈X, (q in,τ,x 0) belong to ∆;
(x 0,!!x++,x 1) and (x 1,!!x−−,x 0) are in ∆ for all x∈X;
for all (s,x++,s′ )∈T, we have (s,?x++,s′ )∈∆;
for all (s,x−−,s′ )∈T, we have (s,?x−−,s′ )∈∆;
for all (s,skip,s′ )∈T, we have (s,τ,s′′ )∈∆;
for all s∈S and all x∈X, if there does not exist s′ ∈S such that (s,x++,s′ )∈T then
(s,?x++,err)∈∆;
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyfor all s∈S and all x∈X, if there does not exist s′ ∈S such that (s,x−−,s′ )∈T then
(s,?x−−,err)∈∆.
Note that P is 1-phase bounded (the transitions leaving a state in {x 0,x 1 ∣ x ∈ X} only
perform broadcasts and the the transitions leaving a state in {s ∣ s ∈ S} only perform
receptions or internal actions). We can then show that there exists Γ∈Stars, C =(Γ,L)∈I
and D=(Γ,L′ )∈CP such that C →∗ D and L′ (ϵ)=s f iff there exists ν′ ∶X ↦N such that
(s in,ν in)▷∗ (s f,ν′ ).
E Proofs of Section 6
E.1 Proofs of Section 6.1
We recall the definition of simple paths. A simple path between u and u′ in a topology
Γ = (V,E) is a sequence of distinct vertices v 0,...,v k such that u = v 0, u′ = v k, and for
all 0≤i<k, (v i,v i+1)∈E. Its length is denoted d(v 0,...,v k) and is equal to k. In a tree
topology Γ′, for two vertices u,u′, there exists a unique simple path between u and u′, hence
we denote d(u,u′ ) to denote the length of the unique path between u and u′. Furthermore,
for all vertex u, d(ϵ,u)=∣u∣.
E.1.1 Proof of Lemma 6.2.
Given (P,q f) a positive instance of Cover [Trees], we let f(P,q f) the minimal number of
processes needed to cover q
f
with a tree topology and we fix Γ=(V,E) a tree topology such
that ∣V∣=f(P,q f) and that covers q f. Let v∈V(Γ) and (C i =(Γ,L i))0≤i≤n configurations
such that C 0∈I, C 0→C 1→...→C
n
and L n(v)=q f. We assume wlog that v is the root of
the tree, i.e. v=ϵ.
For all u∈V(Γ), wedefine b(u) as thefirst index 0≤i<n from which u takesa broadcast
transition, and ∞ if it never broadcasts anything.
WedefineΓ[u]asthetreetopologyobtainedfromΓbyremovinguandallu′ ∈V(Γ)which
admitsuasaprefix. Moreformally,Γ[u]=(V′,E′ )withV′ =V ∖{w∈V ∣w=u⋅w′,w′ ∈N∗ }
and E′ =E∩(V′ ×V′ ).
We establish the following lemma before proving Lemma 6.2.
▶ Lemma E.1. For all u∈V(Γ)∖{ϵ}, b(u)≠∞. Moreover, for all u 1,u 2∈V(Γ)∖{ϵ} such
that u 2=u 1⋅x for some x∈N, it holds that b(u 1)>b(u 2).
Proof. We first prove the first part of the lemma. Assume there exists u∈V(Γ) such that
u≠v and u does not broadcast anything during the execution. Take Γ′ =Γ[u]=(V′,E′ ).
From C 0′ = (Γ′,L′ 0) ∈ I, we make the processes in V(Γ′ ) perform the same sequence of
transitions as in the original execution. The remaining parent of u can perform the same
sequence of transitions as it never receives anything from u.
Now we prove the second part of the lemma. Assume for the sake of contradiction that
thereexistu 1,u 2∈V(Γ)∖{ϵ}suchthatu 2=u 1⋅xforsomex∈N,andb(u 1)<b(u 2). Fromthe
first part of the lemma, b(u 1)≤b(u 2)<n. We show now that q
f
is covered with Γ′ =Γ[u 2].
For that, we will define by induction configurations C 0′ =(Γ′,L′ 0), ..., C n′ =(Γ′,L′ n) such
that C 0′ ∈I, C 1′,...,C n′ ∈C and C 0′ →∗C 1′ →∗ ⋯→∗C n′. We will prove that, for all 0≤k≤n,
P(k)∶ for all v′ ∈V(Γ′ )∖{u 1}, L′ k(v′ )=L k(v′ ), and if L k(u 1)∉Qr 2, L′ k(u 1)=L k(u 1).
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyFor k=0, C 0′ is uniquely defined, and obviously, for all v′ ∈V(Γ′ ), L′ 0(v′ )=L 0(v′ ). Let
0≤k<n, and assume we have built C 0′,...,C k′ ∈C and that P(k) holds. Let u∈V(Γ), t∈ ∆
u,t
such that C
k
—→C k+1.
If t=(q,τ,q′ ), we define L′
k+1
as follows.
L′ k+1(u′ )=⎧ ⎪⎪
⎨
⎪⎪
⎩q L′
′ k(u′ )
oif thu e′ r= wu isea .nd L′ k(u)=L k(u)
First case: L′ k(u)=L k(u). Then L′ k(u)=q, and it follows immediately that C k′ —u, →t
C k′ +1. Also, let v′ ∈ V(Γ′ )∖{u 1}. By induction hypothesis, L′ k(v′ ) = L k(v′ ) hence
if v′ ≠ u, L′ k+1(v′ ) = L′ k(v′ ) = L k(v′ ) = L k+1(v′ ) by definition of C k —u, →t C k+1. Also,
L′ k+1(u) = L k+1(u) by definition of C k —u, →t C k+1. If L k+1(u 1) ∉ Qr 2 and u ≠ u 1, then
L k(u 1)=L k+1(u 1)∉Qr 2, and L′ k+1(u 1)=L′ k(u 1)=L k(u 1)=L k+1(u 1). If u=u 1, then by
construction L′ k+1(u 1)=q′ =L k+1(u 1). Then P(k+1) holds.
Second case: L′ k(u)≠L k(u). Then C k′ +1=C k′ and C k′ →∗C k′ +1. Moreover, since P(k)
holds, it implies that u=u
1
and L k(u 1)∈Qr 2. Then L k+1(u 1)∈Qr
2
and P(k+1) holds
by induction hypothesis.
If t=(q,!!m,q′ ), we differentiate three cases.
1. if u∈V(Γ′ ), and u≠u 1, we let C k′ +1=(Γ′,L′ k+1) defined as follows:
L′ k+1(u′ )=L k+1(u′ ) for all u′ ∈V(Γ′ )∖{u 1}
L′ k+1(u
1)=⎧ ⎪⎪⎪⎪⎪⎪⎪⎪
⎨
⎪⎪⎪⎪⎪⎪⎪⎪
⎩LpL
L
′
k′ k
k+
((
1
uu
(
11
u
))
1)
oii
i
ff
f
thuu
u
e11
1
r∈∉
∈
wNN
N
isΓΓ
Γ
e′′
′
.((
(
uu
u
))
) ,a Ln
′
kd (uL 1′ k )(u ≠1 L) k= (uL 1k )(u a1 n)
d there exists (L′ k(u 1),?m,p)∈∆
First, we show that C k′ —u, →t C k′ +1. By induction hypothesis, L k(u′ ) = L′ k(u′ ) for
all u′ ∈ V(Γ′ )∖{u 1}. Then L′ k(u) = L k(u) = q and L′ k+1(u) = q′. For all u′ ≠ u 1,
L′ k+1(u′ )=L k+1(u′ )andL k(u′ )=L′ k(u′ ). Ifu 1∉N Γ′(u),thenL′ k+1(u 1)=L′ k(u 1),and
C k′ —u, →t C k′ +1. Otherwise, if L′ k(u 1) = L k(u 1), then L′ k+1(u 1) = L k+1(u 1) and u 1 has
behavedcorrectly, henceC k′ —u, →t C k′ +1. Ifu 1∈N Γ′(u)andL′ k(u 1)≠L k(u 1), theneither
there exists a transition (L′ k(u 1),?m,p)∈∆ and L′ k+1(u 1)=p or L′ k+1(u 1)=L′ k(u 1).
In any case, C k′ —u, →t C k′ +1.
Let v′ ∈ V(Γ′ )∖{u 1}. By definition, L′ k+1(v′ ) = L k+1(v′ ). If L k+1(u 1) ∉ Qr 2 then as
P is 2-phase bounded, L k(u 1)∉Qr
2
and so by induction hypothesis L′ k(u 1)=L k(u 1).
Then, by construction of L′ k+1(u 1): either u 1 ∉ N Γ′(u) and so L′ k+1(u 1) = L′ k(u 1) =
L k(u 1)=L k+1(u 1), or u 1∈N Γ′(u) and L′ k+1(u 1)=L k+1(u 1).
2. If u=u 1, note that, as (L k(u 1),!!m,L k+1(u 1))∈∆, by definition of 2-phase-bounded
protocols, L k(u 1) ∉ Qr 2. Hence, by induction hypothesis, L′ k(u 1) = L k(u 1) = q. We
then simply let L′ k+1(u′ ) = L k+1(u′ ) for all u′ ∈ V(Γ′ ). As C k → C k+1, and by the
induction hypothesis, C k′ → C k′ +1. Moreover, by construction, for all u′ ∈ V(Γ′ ),
L′ k(u′ )=L′ k+1(u′ ) hence P(k+1) holds.
3. If u∉V(Γ′ ), we let C k′ +1=C k′ and then C k′ →∗C k′ +1. If u≠u 2, then N Γ(u)∩V(Γ′ )=∅.
Indeed, u = u 2 ⋅w for w ∈ N+, hence u[−1] = u 2 ⋅w′ ∉ V(Γ′ ) and for every x ∈ N,
u⋅x∉V(Γ′ ). Hence, for u′ ∈V(Γ′ ), L k+1(u′ )=L k(u′ ). Then, P(k+1) holds.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyIf u = u 2, its only neighbor in V(Γ′ ) is u 1. Furthermore, as b(u 1) < b(u 2) ≤ k, u 1
alreadybroadcastsomemessages,andasP is2-phase-bounded,L k(u 1)∈Qb 1∪Qb
2
∪Qr 2.
Either L k+1(u 1)=L k(u 1), and since L′ k+1(u 1)=L′ k(u 1), the induction property still
holds, or (L k(u 1),?m,L k+1(u 1))∈∆. Then, as P is 2-phase-bounded, L k+1(u 1)∈Qr 2,
and the induction property holds too.
Then L′ n(ϵ) = L n(ϵ) (since u 1 ≠ ϵ), and L′ n(ϵ) = q f. Hence we found a tree topology
Γ′ =(V′,E′ ) with ∣V′ ∣<∣V∣ with which q f is coverable. This is not possible as ∣V∣=f(P,q f),
hence b(u 1)>b(u 2). ◀
We are now ready to prove Lemma 6.2.
Proof of Lemma 6.2. Assumethereexistsu∈V(Γ)suchthat∣u∣>∣Q∣+1. Forall1≤i≤∣u∣,
we denote v
i
the prefix of u of length i. By definition of a tree topology, for al 1≤i≤∣u∣,
v i∈V(Γ). Let 1≤i≤n, from Lemma E.1 we know that 0≤b(v i)<n. Hence, we can denote
q
i
the state from which v
i
performs its first broadcast, i.e. C
b(vi)
—v —i, —(q —i, —!!m —i —,q —i′ →) C
b(vi)+1
for
some m i∈Σ and q i′ ∈Q.
As ∣u∣>∣Q∣+1, there exists 1<i
1
<i
2
≤∣u∣ such that q
i1
=q i2. Note that we take two
such nodes in v ,...,v instead of in v ,...,v . We will see later that we need v to not
2 ∣u∣ 1 ∣u∣ i1
have ϵ as neighbor in order to apply Lemma E.1 on v and its neighbor v .
i1 i1−1
FromLemmaE.1,b(v i1)>b(v i2). TakeΓ′ =(V′,E′ )definedasthetreetopologyobtained
from Γ by only keeping processes u such that (1) the unique path between path from u to v
does not contain v , i.e. v is not a prefix of u, or (2) the unique path between u and v
i1 i1
contains v , i.e. v is a prefix of u. We also add an edge between v and the remaining
i2 i2 i2
parent of v . To stay consistent with the definition of our tree topology, we also rename
i1
nodes. Moreformally: V′ =V∖{u∈V ∣v
i1
is a prefix of u}∪{v i1⋅w∣w∈N∗ and v
i2
⋅w∈V},
and E′ ={(w,w⋅x)∣x ∈N,w∈V′,w⋅x∈V′ }. Let w∈V′, we let
tr∶V′ →V
tr∶w↦⎧ ⎪⎪ ⎨w if v i1 is not a prefix of w in V′
⎪⎪ ⎩v i2⋅w′ if w=v i1⋅w′ in V′ for some w′ ∈N∗.
Note that for all u 1,u 2∈V(Γ′ ), such that (u 1,u 2)≠(v i1−1,v i1), it holds that: (u 1,u 2)∈
E(Γ′ ) if and only if (tr(u 1),tr(u 2))∈E(Γ).
We prove the existence of an execution covering q with Γ′ in three steps.
f
First step.
W ane ds Cta i′rt =b (y Γ′b ,Lu ′ iil )d ,in fog rC a0 l′ l= u( ∈Γ V′, (L Γ′ 0 ′) ),∈ LI ′ i, (uC )1′, =.. L. i, (C trb′ ((v ui )2 )) .∈ WC esu nc oh wth pa rt ovf eor ba yll in0 d≤ uci ti≤ onb( tv hi2 a) t,
C 0′ →∗C 1′ →∗ ⋯→∗C b′ (vi2). Let k≥0, and assume that we have proved that C 0′ →∗C k′.
u,t
Assume that C
k
—→C k+1.
if t = (q,τ,q′ ) and there exists v ∈ V(Γ′ ) such that tr(v) = u, then by construction,
L′ k(v)=L k(v)=q and L′ k+1(v)=L k+1(u)=q′. For all other nodes v′ ∈V(Γ′ ), L′ k+1(v′ )=
L k+1(tr(v′ ))=L k(tr(v′ ))=L′ k(v′ ) as tr is injective. Hence, C k′ —v, →t C k′ +1.
if t = (q,τ,q′ ) and there is no v ∈ V(Γ′ ) such that tr(v) = u, then for all v ∈ V(Γ′ ),
L′ k+1(v)=L k+1(tr(v))=L k(tr(v′ ))=L′ k(v) and so C k′ +1=C k′.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyif t=(q,!!m,q′ ) and there v ∈V(Γ′ ) such that tr(v)=u, then by construction, L′ k(v)=
L k(v)=q and L′ k+1(v)=L k+1(u)=q′. Furthermore, for all nodes v′ such that (v′,v)∈
E(Γ′ ), then either (tr(v′ ),tr(v)) ∈ E(Γ′ ) or {v,v′ } = {v i1−1,v i1}. In the first case, as
C k —tr —(v —), →t C k+1, either (L′ k(v′ ),?m,L′ k+1(v′ )) ∈ ∆ or L′ k(v′ ) = L′ k+1(v′ ) and there is no
p∈Q such that (L′ k(v′ ),?m,p)∈∆. In the latter case, recall that k <b(v i2) and, from
Lemma E.1, b(v i2)<⋯<b(v i1)<b(v i1−1). Hence, u∉{v i2,v i1−1}. Hence, v∉{v i1−1,v i1},
and we reach a contradiction.
Allothernodesu′notneighborsofvaresuchthatL′ k+1(u′ )=L k+1(tr(u′ ))and(tr(u′ ),tr(v))∉
E(Γ′ ), as v∉v i1. Hence, L′ k+1(u′ )=L k+1(tr(u′ ))=L k(tr(u′ ))=L′ k(u′ ).
Hence C k′ —v, →t C k′ +1.
if t = (q,!!m,q′ ) and there is no v ∈ V(Γ′ ) such that tr(v) = u, hence u = v i1 ⋅x for
some x ∈ N∗ and v i2 is not a prefix of u. We prove that for all v ∈ V(Γ), it holds
that L k+1(tr(v)) = L k(tr(v)). Assume this is not the case, then (tr(v),u) ∈ E(Γ). If
tr(v) is a parent of u and so tr(v) = v i1−1 and u = v i1. With Lemma E.1 it implies
u,t
that k < b(v i2) < b(u), which is absurd as C k —→ C k+1. If u is a parent of tr(v), then
tr(v) = v i2 and u = v i2−1. For the same reason, we get k < b(v i2) < b(u), which is
u,t
absurd as C k —→ C k+1. Hence (tr(v),u) ∉ E(Γ) and L k+1(tr(v)) = L k(tr(v)). Hence,
L′ k+1(v)=L k+1(tr(v))=L k(tr(v))=L′ k(v) for all v∈V(Γ′ ) and so C k′ =C k′ +1.
Hence C 0′ →∗C b′
(vi2)
where for all u∈V(Γ′ ), L′ b(vi2)(u)=L b(vi2)(tr(u)).
Second step.
wN eex et n, sw ue rebu thil ad tC fob′ ( rvi a2 l) l+ b1 (, vC ib 2′ ( )vi ≤2) k+2 ≤,. b. (. v, iC 1)b′ ,(v ifi1 w) e∈C letsu Cch k′ t =h (a Γt ′C ,Lb′ ( ′ kv )i2 ,)→∗ ⋯→∗C b′ (vi1). Moreover,
for all u∈V(Γ′ ) such that u=tr(u),L′ k(u)=L k(u)
and L′ k(v i1)=q i2.
L
b(uO i2b )s (e tr r(v ue )t )h ,a at n, dfr to hm ent Lhe
′
b(vfi i2r )s (t vs i1te )p =, LC bb′ (( vu i2i2 )) (ti rs (vs iu 1)c )h =th La bt (vif 2o )r (va il 2l )u =∈
q
iV 2.(Γ S′ o), thL e′ b( iu ni d2) u( cu t) ion=
hypothesis holds for k=b(v i2).
Now, let b(u i2)≤k<b(u i1) and assume that we have built C b′ (ui2), ..., C k′. Let v∈V(Γ)
and t=(q,α,q′ ) such that C k —v, →t C k+1. If there is no u∈V(Γ′ ) such that tr(u)=v, or if the
only u∈V(Γ′ ) such that tr(u)=v is such that u≠v, then we let C k′ +1=C k′.
If α = τ, we know that for all u′ ∈ V(Γ)∖{v}, L k+1(u′ ) = L k(u′ ), hence, by induction
hypothesis, if u′ =tr(u′ ), we have that L′ k+1(u′ )=L k+1(u′ ), and L′ k+1(v i1)=q i2.
If α =!!m for some m ∈ Σ, then the neighbors of v may have changed state. Since
k < b(v i1), we know that u ≠ v i1. Hence, u = v i1 ⋅w for some w ∈ N+ and then, for all
u′ ∈V(Γ′ ), if u′ =tr(u′ ), then u′ ∉N Γ(v). Thus, for all u′ ∈V(Γ′ ) such that u′ =tr(u′ ),
L k+1(u′ )=L k(u′ ) and then L′ k+1(u′ )=L k+1(u′ ). Moreover, L′ k+1(v i1)=L′ k(v i1)=q i2.
Assume now that v=tr(v). By definition, v
i1
is not a prefix of v in V′.
If α = τ, we let L′ k+1(v) = q′ and, for all u ∈ V(Γ′ )∖{v}, L′ k+1(u) = L k+1(u) = L k(u).
By induction hypothesis, L′ k(v)=L k(v), hence (L′ k(v),τ,L′ k+1(v))∈∆ and C k′ —v, →t C k′ +1.
Moreover, for all u∈V(Γ′ ) such that u=tr(u), L′ k+1(u)=L k+1(u). Also, v ≠v i1 hence
L′ k+1(v i1)=L′ k(v i1)=q i2.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyIf α=!!m, let L′ k+1(v)=q′ and, for all u∈N Γ′(v), if tr(u)=u, let L′ k+1(u)=L k+1(u). For
all other u∈V(Γ′ ), let L′ k+1(u)=L′ k(u). First, we show that C k′ —v, →t C k′ +1. By induction
hypothesis, L′ k(v)=L k(v), hence (L′ k(v),!!m,L′ k+1(v))∈∆. Let u∈N Γ′(v) and assume
that tr(u) ≠ u. It means that u = v i1 ⋅w for some w ∈ N∗. Since v = tr(v), we also
know that v i1 is not a prefix of v. If v = u⋅x then v = v i1 ⋅w⋅x, which is impossible
since u i1 is not a prefix of v. If u = v⋅x, then either v i1 is also a prefix of v which is
impossible, or u=v
i1
and then v
i1
=v⋅x. This means that v =v i1−1, the father of v i1.
By Lemma E.1, it would mean that b(v)=b(v i1)<b(v) but k<b(v i1) and v broadcasts
a message from C k. This leads to a contradiction. Hence, for all u∈N Γ′(v), tr(u)=u,
and then, for all u∈N Γ′(v), L′ k+1(u)=L k+1(u). By induction hypothesis, L k(u)=L′ k(u),
then either L k(u)=L k+1(u) and there is no (L′ k(u),?m,p)∈∆, or (L′ k(u),?m,L′ k+1(u)).
Hence C k′ —v, →t C k′ +1. Moreover, by induction hypothesis, for all u ∈ V(Γ′ ) such that
tr(u) = u, L′ k(u) = L k(u). Then, if u ∈ N Γ′(v), L′ k+1(u) = L k+1(u), and otherwise,
L′ k+1(u) = L′ k(u) = L k(u). Let again u such that u = tr(u) and (u,v) ∉ E(Γ′ ), then
(tr(u),tr(v))∉E(Γ), hence (u,v)∉E(Γ). Then u∉N Γ(v) and L k+1(u)=L k(u). Hence,
for all u ∈ V(Γ′ ) such that u = tr(u), L′ k+1(u) = L k+1(u). Since v i1 ≠ tr(v i1), and since
v≠v i1, L′ k+1(v i1)=L′ k(v i1)=q
i2
by induction hypothesis.
In this part of the execution, we have forgotten the transitions issued by nodes u=v i1⋅w
for w∈N+ in V(Γ). The configuration we reach is such that L′ b(vi1)(v i1)=q
i2
and correspond
to the states reached in C in the rest of the tree. This will allow us to reach q . The
b(vi1) f
subtree rooted in v might visit different states than in the original execution, but this will
i1
not influence the states visited by the root, thanks to the fact that the protocol is 2-phase
bounded.
Third step.
F Mi on ra el oly v, erw ,e wb eu ei nld suC reb′ ( tv hi1 a) t,C fob′ r(v ai1 ll)+ b1 (, v. i. 1. ), ≤C n k′ ≤∈ nC ,s iu fc wh et lh ea tt CC k′b′ =(v (i1 Γ) ′,→ L∗
′
k)C ,b′ (vi1)+1 →∗ ⋯ →∗ C n′.
for all u∈V(Γ′ ) such that u=tr(u),L′ k(u)=L k(u)
and L′ k(v i1)=L k(v i1) or L k(v i1)∈Qr 2.
Processes u∈V(Γ′ ) such that u=tr(u), perform the same sequence of transitions than
between C and C and process v broadcasts the sequence of messages broadcast by
t ah lre easa dm ye den fiob n( dv eei d1 i) n anΓ d. sF ao tn r ism fia eslly thw ee inb du uil cd tii t o1 h ne ps re oq pu ee rn tc ye
.
b Ay ssi un mdu ec wti eon hao vn eb b( uv i i1 lt) C≤ ′k≤n ,. ..C .b ,′ ( Cvi ′1) fois
r
some b(v i2)≤k<n such that: for all u∈V(Γ′ ) with u=tr(u), it holds
thatb( Lvi
′ k1
()
u)=L
kk
(u),
and, furthermore either L′ k(v i1)=L k(v i1) or L k(v i1)∈Qr 2.
Denote C k —u, →t C k+1 with t=(q,α,q′ ) and α∈{τ}∪!!Σ.
First, if α = τ and u = tr(u) or u = v i1, then define L′ k+1 as follows: if L′ k(u) = L k(u),
define L′ k+1(u)=q′ and L′ k+1(u′ )=L′ k(u′ ) for all other nodes, otherwise L′ k+1=L′ k.
If L′ k(u)=L k(u), L k(u)=q and so we immediately get that C k′ →C k′ +1. Furthermore,
for all u′ ∈ V(Γ′ )∖{u}, it holds that L′ k+1(u′ ) = L′ k(u′ ). If u′ ≠ v i1 and u′ = tr(u′ ),
by induction hypothesis, L′ k+1(u′ )=L′ k(u′ )=L k(u′ )=L k+1(u′ ). Furthermore, either
u=v
i1
and L′ k+1(v i1)=L k+1(v i1), or u≠v
i1
and as L k+1(v i1)=L k(v i1), it holds that
L′ k+1(v i1)=L k+1(v i1) or L k+1(v i1)=L k(v i1)∈Qr 2.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyIf L′ k(u) ≠ L k(u), by induction hypothesis u = v i1 and L k(v i1) ∈ Qr 2. As P is 2-
phase-bounded, for all p such that (L k(v i1),τ,p) ∈ ∆, it holds that p ∈ Qr 2. Hence,
L k+1(v i1)∈Qr
2
and the induction property holds.
Note that if u≠tr(u) and u≠v i1, for all u′ such that u′ =tr(u′ ) or u′ =v i1, it holds that
L k+1(u′ )=L k(u′ ), hence by taking C k′ +1=C k′, the induction property holds.
In the following, we assume that α=!!m for some m∈Σ. We start by defining C k′ +1, then
we prove that C k′ →∗C k′
+1
and finally we prove that C k′
+1
respects the induction property.
We build C′ depending on u.
k+1
1. if tr(u)=u and u≠v i1−1, then let L′ k+1(u′ )=L k+1(u′ ) for all u′ such that tr(u′ )=u′,
and L′ k+1(u′ )=L′ k(u′ ) for all other nodes.
2. ifu=v i1−1,thenletL′ k+1(u′ )=L k+1(u′ )forallu′ suchthattr(u′ )=u′,andL′ k+1(u′ )=
L′ k(u′ ) for all other nodes u′ ≠v i1. It is left to define L′ k+1(v i1). If L′ k(v i1)=L k(v i1),
then define L′ k+1(v i1)=L k+1(v i1), otherwise if there exists (L′ k(v i1),?m,p)∈∆, define
L′ k+1(v i1)=p, and else define L′ k+1(v i1)=L′ k(v i1).
3. if u = v i1, then let L′ k+1(v i1) = L k+1(v i1) = q′, and let L′ k+1(u′ ) = L k+1(u′ ) for all u′
such that tr(u′ ) = u′. Furthermore, for all other nodes u′, if (v i1,u′ ) ∈ E(Γ′ ), then
if there exists (L′ k(u′ ),?m,p) ∈ ∆, let L′ k+1(u′ ) = p, otherwise L′ k+1(u′ ) = L′ k(u′ ). If
(v i1,u′ )∉E(Γ′ ), then L′ k+1(u′ )=L′ k(u′ ).
4. otherwise, C k′
+1
=C k′.
We prove now that in all cases 1, 2 and 3, it holds that C k′ →C k′ +1.
In case 1, observe that as u ≠ v i1−1 and tr(u) = u, then all neighbors u′ ∈ N Γ′(u) are
such that tr(u′ )=u′. Indeed, if v
i1
is not a prefix of u, it is not a prefix of its parent (if
any), and for x∈N, v
i1
is a prefix of u⋅x if and only if u⋅x=v i1, i.e. u=v i1−1. Hence,
for all (u′,u) ∈ E(Γ′ ), it holds that (tr(u′ ),tr(u′ )) = (u,u′ ) ∈ E(Γ), and by induction
hypothesis L′ k(u′ ) = L k(u′ ). Therefore, as C k → C k+1, (L′ k(u′ ),?m,L′ k+1(u′ )) ∈ ∆ or
there is no transition labeled by ?m from L′ k(u′ ) and L′ k+1(u′ )=L′ k(u′ ). Furthermore,
(L′ k(u),!!m,L′ k+1(u)) ∈ ∆. Let u′ ∈ V(Γ′ ) which is not a neighbor of u, and such that
tr(u′ ) =u′. Then, u′ ∉N Γ(u), and by induction hypothesis L′ k(u′ ) =L k(u′ ). As C k →
C k+1,L k(u′ )=L k+1(u′ ). AndsobydefinitionofL′ k+1,L′ k+1(u′ )=L k+1(u′ )=L′ k(u′ ). Let
u′ ∈V(Γ′ ) which is not a neighbor of u and such that tr(u′ )≠u′. Then, by definition of
L′ k+1, L′ k+1(u′ )=L′ k(u′ ). Hence C k′ →C k′ +1.
Incase2,theonlydifferenceisthatv
i1
isnowaneighborofthebroadcastingnodeu=v i1−1.
If L′ k(v i1)=L k(v i1), then we defined L′ k+1(v i1)=L k+1(v i1). As (v i1−1,v i1)∈E(Γ) and
C k → C k+1, then (L′ k(v i1),?m,L′ k+1(v i1)) ∈ ∆ or there is no transition labeled by ?m
from L′ k(v i1) and L′ k+1(v i1)=L′ k(v i1). Hence, C k′ →C k′ +1. Otherwise, L′ k(v i1)≠L k(v i1),
and by definition of L′ k+1, either (L′ k(v i1),?m,L′ k+1(v i1))∈∆, or L′ k+1(v i1)=L′ k(v i1) and
there is no transitions (L′ k(v i1),?m,p)∈∆ for some p∈Q. Hence, C k′ →C k′ +1.
In case 3, note that by definition of a 2-phase-bounded protocol, L k(v i1) ∉ Qr 2 as
(L k(v i1),!!m,q′ ) ∈ ∆. Hence, by induction hypothesis, L′ k(v i1) = L k(v i1) and so v i1
can perform the broadcast of m from C′. Furthermore, by induction hypothesis, its par-
k
ent v i1−1 is such that L′ k(v i1−1)=L k(v i1−1) and, by definition, L′ k+1(v i1−1)=L k+1(v i1−1).
As (v i1−1,v i1) ∈ E(Γ), and C k → C k+1, either (L k(v i1−1),?m,L k+1(v i1−1)) ∈ ∆ or there
is no transitions (L k(v i1−1),?m,p) ∈ ∆ for some p ∈ Q. For other neighbors u′ of v i1,
u′ ≠ tr(u′ ) and by construction of L′ k+1, (L′ k(u′ ),?m,L′ k+1(u′ )) ∈ ∆, or there is no re-
ception transitions labeled by ?m from L′ k(u′ ) and L′ k+1(u′ ) = L′ k(u′ ). Other nodes
u′ which are not neighbors of v i1 are either such that u′ = tr(u′ ), and it holds that
L′ k+1(u′ ) = L k+1(u′ ) = L k(u′ ) = L′ k(u′ ), as (u′,v i1) ∉ E(Γ). Or u′ ≠ tr(u′ ) and by con-
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanystruction, L′ k+1(u′ )=L′ k(u′ ). Hence it holds that C k′ →C k′ +1.
Weprovenowthatinallcases1,2,3and4,C′ satisfiestheinductionproperty,i.e. forall
k+1
u∈V(Γ′ ) such that tr(u)=u, it holds that L′ k+1(u)=L k+1(u), and L′ k+1(v i1)=L k+1(v i1)
or L k+1(v i1)∈Qr 2. In case 1, the first part is trivial by construction. As (u,v i1)∉E(Γ),
L k+1(v i1)=L k(v i1), hence either L′ k+1(v i1)=L′ k(v i1)=L k(v i1)=L k+1(v i1) by induction
hypothesis, or L k+1(v i1)=L k(v i1)∈Qr 2.
In case 2, either L′ k+1(v i1) = L k+1(v i1) or L′ k(v i1) ≠ L k(v i1). In the latter case, by
induction hypothesis, L k(v i1) ∈ Qr 2, and so, as P is 2-phase-bounded, L k+1(v i1) ∈ Qr 2.
Case 3 is direct from the definition of L′ .
k+1
In case 4, for all u′ ∈ V(Γ′ ) such that u′ = tr(u′ ), L k+1(u′ ) = L k(u′ ) as (u′,u) ∉ E(Γ).
Hence, L′ k+1(u′ )=L′ k(u′ )=L k(u′ )=L k+1(u′ ). However, if u=v i1+1, v
i1
might change its
statebetweenC
k
andC k+1uponreceptionofm. Ifitdoesso,(L k(v i1),?m,L k+1(v i1))∈∆.
As k>b(v i1) and P is 2-phase-bounded, v i1 already went through its broadcasting phase,
and L k+1(v i1)∈Qr 2, and so the induction property holds.
Conclusion.
Hence we found an execution covering q f with a tree topology Γ′ =(V′,E′ ) and ∣V′ ∣<∣V∣. It
contradicts the fact that ∣V∣=f(P,q f).
□
E.1.2 Proof of Theorem 6.3
Proof of Theorem 6.3. WeprovethedecidabilitybyreducingbothCoverandCover [Trees]
to Cover [K−BP]. Let P a protocol and q
f
a state of P. Assume that there is a topology
Γ with which q is coverable. Then, by Theorem 2.4, there exist a tree topology Γ′ with
f
wich q
f
is coverable. Assume that ∣V∣=f(P,q f). Then, each simple path in Γ′ has a length
bounded by 2(∣Q∣+1). Indeed, let u 1,u 2∈V(Γ′ ), as Γ′ is a tree topology, the unique simple
path between u
1
and u
2
either contains ϵ and d(u 1,u 2)=∣u 1∣+∣u 2∣, or there exists u∈N+
such that u
1
=u⋅u′
1
and u
2
=u⋅u′ 2, and u′
1
and u′
2
have no common prefix. In the latter
case, the length of the simple path between u
1
and u
2
is ∣u′ 1∣+∣u′ 2∣<∣u 1∣+∣u 2∣. In both cases,
d(u 1,u 2)≤∣u 1∣+∣u 2∣, and hence from Lemma 6.2, d(u 1,u 2)≤2(∣Q∣+1). Then q
f
is coverable
in a 2(∣Q∣+1)-bounded path topology.
Conversely,assumethatthereexistsa2(∣Q∣+1)-boundedpathtopologyΓwithwhichq
f
is
coverable. Then,immediately,thereisatopologywithwhichq iscoverable. ByTheorem2.4,
f
there also exists a tree topology with which q is coverable. Theorem 6.1 allows to conclude
f
to decidability of both Cover and Cover [Trees]. □
E.2 Proofs of Section 6.2
E.2.1 Proof of Lemma 6.4
Let q f ∈Q be a coverable state. We fix Γ with V(Γ)={v 1,...,v ℓ} the line topology such
that there exist ρ=C 0 →⋯→C n with C n =(Γ,L n) and L n(v N)=q f for some v N ∈V(Γ).
We suppose wlog that N ≥3 and N ≤ℓ−2, otherwise, we can just add artificial nodes not
issuing any transition in the execution.
We start by proving the following lemma.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany▶ Lemma E.2. There exists ρ′ =C 0′ →∗C n′ such that C n′ =(Γ,L′ n) with L′ n(v N)=q f, and
for all 1≤i≤N −2, t last(v i,ρ′ )≤b first(v i+1,ρ′ );
for all N +2≤i≤ℓ, t last(v i,ρ′ )≤b first(v i−1,ρ′ ).
E.2.1.1 Proof of Lemma E.2.
To prove Lemma E.2, we give two symmetric lemmas.
▶ Lemma E.3. Let ρ=C 0→∗C with C =(Γ,L) and 1≤K <ℓ. There exists ρ′ =C 0→∗C′
such that C′ =(Γ,L′ ), and
for all v∈{v K+1,...,v ℓ}, L′ (v)=L(v);
for all 1≤i≤K−1, t last(v i,ρ′ )≤b first(v i+1,ρ′ );
for all K ≤i≤ℓ, t last(v i,ρ′ )≤b first(v i+1,ρ′ ) if and only if t last(v i,ρ)≤b first(v i+1,ρ).
Proof. We show that we can build ρ
K
by induction on K: for K =1, there is nothing to do
v0,t0 v1,t1 vn−1,tn−1
andρ 1=ρ. Let1<K <ℓ,andassumewehavebuiltρ K−1=C 0———→C 1———→⋯—————→C
n
such that C n=(Γ,L n) and:
for all v∈{v K,...,v ℓ}, L n(v)=L(v);
for all 1≤i≤K−2, t last(v i,ρ K−1)≤b first(v i+1,ρ K−1);
for all K ≤i≤ℓ, t last(v i,ρ K−1)≤b first(v i+1,ρ K−1) if and only if t last(v i,ρ)≤b first(v i+1,ρ).
If t last(v K−1,ρ K−1)≤b first(v K,ρ K−1), there is nothing to do.
Assume t last(v K−1,ρ K−1)>b first(v K,ρ K−1), then t last(v K−1,ρ K−1)≥0 and v
K−1
issues at
least one transition in ρ
K−1
after b first(v K,ρ K−1). Let
⎧ ⎪⎪min{j >b first(v K,ρ K−1)∣C j —vK —− —1, →t C j+1 for some t∈∆} if b first(v K−1,ρ K−1)≤b first(v K,ρ K−1)
j 1=⎨
⎪⎪ ⎩min{j ≥0∣C
j
—v —i, →t
C
j+1
for some t∈∆ and for some 1≤i≤K−1} otherwise.
We now build the following sequence of configurations C′ ,...C′:
j1 n
C j′
1
=C j′ 1+1=C j1;
for j 1+1≤j <n, C j′ +1=(Γ,L′ j+1) and
L′ j+1(v)=L j+1(v) for all v∈{v K+1,...,v ℓ},
L′ j+1(v)=L′ j(v) for all v∈{v 1,...,v K−2},
L′ j+1(v K−1) is defined as follows: if vj =v K and tj is a broadcast transition of some
message m ∈ Σ, and (L′ j(v K−1),?m,p) ∈ ∆ for some p ∈ Q, then L′ j+1(v K−1) = p,
otherwise L′ j+1(v K−1)=L′ j(v K−1);
L′ j+1(v K) is defined as follows:
∗ if vj =v K+1 and L′ j(v K)≠L j(v K) and tj is a broadcast transition of some message
m∈Σ, and (L′ j(v K),?m,p)∈∆ for some p ∈Q, then L′ j+1(v K)=p;
∗ if vj =v
K+1
and L′ j(v K)=L j(v K), then L′ j+1(v K)=L j+1(v K);
∗ if vj =v
K
and L′ j(v K)=L j(v K), then L′ j+1(v K)=L j+1(v K);
∗ otherwise, L′ j+1(v K)=L′ j(v K).
At j 1, actions of process v K−1 (and hence actions of all processes in {v 1,...,v K−1}
will have no influence any more on {v K+1,...,v ℓ}, either because v
K
has emitted its first
broadcast, and thus will only receive messages from {v 1,...,v K−1} in its last reception phase
(then will never feed it to v ), or because anyway the first broadcast of v happens to
K+1 K−1
late (after the first broadcast of v ). In order to prove the induction step, we have just built
K
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanya sequence of configurations that ignore subsequent actions of {v 1,...,v K−1}, starting from
j , while still being an execution. The state of the protocol in which v is during this part
1 K
of the execution is either faithful to what it was in ρ , or v is in its last reception phase.
K−1 K
Formally, we now prove that, for all j 1+1≤j ≤n,
1. P 1(j): eitherC j′ −1—v —j− —1, —tj —− →1 C j′ andvj−1 ∈{v K,...,v ℓ}orC j′ =C j′ −1andvj−1 ∈{v 1,...v K},
2. P 2(j): L′ j(v K)=L j(v K) or L j(v K)∈Qr 2.
WeproveP 1(j)andP 2(j)byinductiononj. Forj =j 1+1,P 1(j)triviallyholdsasC j′ 1+1=
C j′
1
and C
j1
—v —i, →t C
j1+1
for 1≤i≤K−1, by construction. Let us prove now that P 2(j 1+1)
holds: recall first that L′ j1+1(v K) = L′ j1(v K) = L j1(v K). Since C j1 —v —i, →t C j1+1, for some
1≤i≤K−1, either L j1+1(v K)=L j1(v K) and P 2(j) holds, or (L j1(v K),?m,L j1+1(v K))∈∆
and t = (p,!!m,q). In that case C j1 —vK —− —1, →t C j1+1. Since either j 1 > b first(v K,ρ K−1) if
b first(v K−1,ρ K−1) ≤ b first(v K,ρ K−1), or b first(v K−1,ρ K−1) > b first(v K,ρ K−1) and C j1 —vK —− —1, →t
C
j1+1
with t=(p,!!m,q), then in any case j 1>b first(v K,ρ K−1). Since P is 2-phase-bounded,
L j1(v K)∈Qb 1∪Qb 2∪Qr
2
and so L j1+1(v K)∈Qr 2. Hence P 2(j) holds.
Letnowj 1+1≤j <nsuchthatP 1(j)andP 2(j)hold. Wemakethefollowingobservation.
▶ObservationE.4. LetC 1—v, →t C 1′ withC 1=(Γ,L 1)andC 1′ =(Γ,L′ 1). ConsiderC 2=(Γ,L 2),
C 2′ = (Γ,L′ 2) two configurations such that, for all u ∈ {v}∪N(v), L 2(u) = L 1(u) and
L′ 2(u)=L′ 1(u), and for all u∉{v}∪N(v), L′ 2(u)=L 2(u). Then C 2—v, →t C 2′.
Theinductionstepisprovedbyacaseanalysisovervj ∈V(Γ). (RecallthatC
j
—v —j, —t →j C j+1.)
Assume vj ∈ {v K+2,...,v ℓ}. Then {vj }∪N(vj ) ⊆ {v K+1,...,v ℓ}, and by construction
of C j′ and C j′ +1, for all v ∈ {vj }∪N(vj ), L′ j(v) = L j(v) and L′ j+1(v) = L j+1(v). Then,
nodes of {vj }∪N(vj ) behave in the same way than in ρ K−1. Let v ∉ {vj }∪N(vj )
and v ∈ {v 1,...,v K}. In that case, either v ∈ {v 1,...,v K−2}, and by construction,
L′ j+1(v)=L′ j(v),orv∈{v K−1,v K},andsincevj ∉{v K−2,v K−1,v K,v K+1},byconstruction,
L′ j+1(v) = L′ j(v). Let v ∉ {vj }∪N(vj ) such that v ∈ {v K+1,...,v ℓ}. In that case,
L′ j+1(v) = L j+1(v) = L j(v) = L′ j(v). This allows us to conclude that C j′ —v —j, —t →j C j′ +1
thanks to Observation E.4, and so P 1(j+1) holds. By P 2(j), either L′ j(v K)=L j(v K)
and we have just proved that L′ j+1(v K)=L′ j(v K), and that L j(v K)=L j+1(v K). Then
L′ j+1(v K)=L j+1(v K)andP 2(j+1)holds. OrL j(v K)∈Qr
2
andsinceL j(v K)=L j+1(v K),
L j+1(v K)∈Qr 2. Hence, P 2(j+1) holds.
Assume that vj = v K+1, or that vj = v K and L′ j(v K) = L j(v K). By construction,
L j+1(vj ) = L′ j+1(vj ) and L j(vj ) = L′ j(vj ). Observe that vj has at most two neighbors
v,v′ such that:
v=v
K+2
or v=v K+1, and so by construction L j+1(v)=L′ j+1(v) and L j(v)=L′ j(v);
v′ =v
K
orv′ =v K−1. Ifv′ =v K−1orv′ =v
K
andL′ j(v K)≠L j(v K),thenbyconstruction
eithertj isabroadcasttransitionofsomemessagem∈Σand(L′ j(v′ ),?m,L′ j+1(v′ ))∈∆.
Or L′ j+1(v′ )=L′ j(v′ ). If v′ =v K and L′ j(v K)=L j(v K), then L′ j+1(v K)=L j+1(v K) by
definition.
Furthermore, for all v ∉{vj }∪N(vj ), either v ∈{v K+2,...,v ℓ} and L′ j+1(v)=L j+1(v)=
L j(v)=L′ j(v), or v∈{v 1,...,v K−2} and L′ j+1(v)=L′ j(v), or v=v K−1 (if vj =v K+1), and
L′ j+1(v)=L′ j(v). This allows us to conclude (with Observation E.4) that C j′ —v —j, —t →j C j′
+1
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germanyand so P 1(j +1) holds. For P 2(j +1), if vj = v K and L′ j(v K) = L j(v K), then by
constructionL′ j+1(v K)=L j+1(v K)andsoP 2(j+1)triviallyholds. Ifvj =v K+1,theneither
L′ j(v K)=L j(v K)andsobyconstruction,L′ j+1(v K)=L j+1(v K),orL′ j(v K)≠L j(v K)and
so by induction hypothesis L j(v K)∈Qr 2, and since P is 2-phase-bounded, L j+1(v K)∈Qr 2.
Assumethatvj =v
K
andL′ j(v K)≠L j(v K). Then,byP 2(j),L j(v K)∈Qr 2. Hence,tisan
internal transition (it cannot be a broadcast), and so L j+1(v)=L j(v)=L′ j(v)=L′ j+1(v)
for all v∈{v K+1,...,v ℓ}, and L′ j+1(v)=L′ j(v) for all v∈{v 1,...v K−2}, and L′ j+1(v K−1)=
L′ j(v K−1) and L′ j+1(v K) = L′ j(v K). As a consequence, C j′ +1 = C j′ and P 1(j+1) holds.
Furthermore, by induction hypothesis, L j(v K)∈Qr
2
and so, as P is 2-phase-bounded, it
holds that L j+1(v K)∈Qr
2
and we have proved P 2(j+1).
Finally,assumethatvj ∈{v 1,...,v K−1}. Then,forallv∈{v K+1,...,v ℓ},L j+1(v)=L j(v),
andL′ j+1(v)=L j+1(v)andL′ j(v)=L j(v)byconstruction. Forallvj ∈{v 1,...,v K−1,v K},
L′ j+1(v) = L′ j(v) and so C j′ +1 = C j′ and P 1(j) holds. Furthermore, either L j(v K) =
L j+1(v K)or(L j(v K),?m,L j+1(v K))∈∆andvj =v K−1andtj =(L j(v K−1),!!m,L j+1(v K−1)).
In the first case, by P 2(j), either L j(v K) = L′ j(v K) and then L j+1(v K) = L j(v k) =
L′ j(v K)=L′ j+1(v K), or L j(v K)=L j+1(v K)∈Qr
2
and so P 2(j+1) holds. In the second
case, j > b first(v K,ρ K−1). Indeed, either b first(v K−1,ρ K−1) ≤ b first(v K,ρ K−1) and then
j > j 1 > b first(v K,ρ K−1), or j ≥ b first(v K−1,ρ K−1) > b first(v K,ρ K−1). By definition of a
2-phase-bounded protocol, L j(v K)∈Qb 1∪Qb 2∪Qr
2
hence, L j+1(v K)∈Qr
2
and so P 2(j+1)
holds.
Hence, P 1(j) and P 2(j) holds for all j 1+1≤j ≤n.
WebuildasequenceofconfigurationsC 0′ →∗C 1′ →∗C n′ bylettingC i′ =C
i
forall0≤i≤j 1.
Let us show now that C′,...,C′ that we have defined form the expected execution ρ .
0 n K
Let v∈{v K+1,...,v ℓ}. By construction L′ n(v)=L n(v). By induction hypothesis (on K),
L n(v)=L(v).
Since P 1(j) holds for all j 1 +1 ≤ j ≤ n, t last(v K−1,ρ K) < j 1 and, by definition of j 1,
it implies that t last(v K−1,ρ K) ≤ b first(v K,ρ K). Let 1 ≤ i < K −1. By induction hy-
pothesis, t last(v i,ρ K−1) ≤ b first(v i+1,ρ K−1). If b first(v K−1,ρ K−1) ≤ b first(v K,ρ K−1), then
t last(v K−2,ρ K−1) ≤ b first(v K−1,ρ K−1) ≤ b first(v K,ρ K−1) < j 1. Thus, t last(v K−2,ρ K) =
t last(v K−2,ρ K−2) ≤ b first(v K−1,ρ K−1) = b first(v K−1,ρ K). Since, for all 1 ≤ i < K − 2,
b first(v i+1,ρ K−1) ≤ t last(v i+1,ρ K−1) < j 1, and by induction hypothesis, t last(v i,ρ K−1) ≤
b first(v i+1,ρ K−1),wededucethatt last(v i,ρ K)=t last(v i,ρ K−1)≤b first(v i+1,ρ K−1)=b first(v i+1,ρ K).
If now b first(v K−1,ρ K−1) > b first(v K,ρ K−1), then by P 1(j), t last(v,ρ K) = −1, for all
v∈{v 1,...,v K−1}. Obviously then, for all 1≤i≤K−1, t last(v i,ρ K)≤b first(v i+1,ρ K).
LetK+1≤i≤ℓ. Then,byP 1(j),t last(v i,ρ K)≤b first(v i+1,ρ K)ifandonlyift last(v i,ρ K−1)≤
b first(v i+1,ρ K−1) if and only if, by induction hypothesis, t last(v i,ρ)≤b first(v i+1,ρ).
◀
By symmetry, we get the following lemma.
▶ Lemma E.5. Let ρ=C 0→∗C with C =(Γ,L) and 1<K ≤ℓ. There exists ρ′ =C 0→∗C′
such that C′ =(Γ,L′ ), and
for all v∈{v 1,...,v K−1}, L′ (v)=L(v);
for all K+1≤i≤ℓ, t last(v i,ρ′ )≤b first(v i−1,ρ′ );
for all 1≤i≤K, t last(v i,ρ′ )≤b first(v i−1,ρ′ ) if and only if t last(v i,ρ)≤b first(v i−1,ρ).
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyWe are now ready to prove Lemma E.2.
Proof of Lemma E.2. From ρ = C 0 →∗ C with C = (Γ,L) we apply Lemma E.3 for
K =N −1 and we get an execution ρ′ =C 0′ →∗C′ such that C′ =(Γ,L′ ) and
for all v∈{v N,...,v ℓ}, L′ (v)=L(v);
for all 1≤i≤N −2, t last(v i,ρ′ )≤b first(v i+1,ρ′ );
for all N −1≤i≤ℓ, t last(v i,ρ′ )≤b first(v i+1,ρ′ ) if and only if t last(v i,ρ)≤b first(v i+1,ρ).
Next, from ρ′, we apply Lemma E.5 for K =N +1 and we get an execution ρ′′ =C 0′′ →∗C′′
such that C′′ =(Γ,L′′ ) and
for all v∈{v 1,...,v N}, L′′ (v)=L′ (v);
for all N +2≤i≤ℓ, t last(v i,ρ′′ )≤b first(v i−1,ρ′′ );
for all 1≤i≤N +1, t last(v i,ρ′′ )≤b first(v i−1,ρ′′ ) if and only if t last(v i,ρ′ )≤b first(v i−1,ρ′ ).
Hence, ρ′′ covers q
f
as L′′ (v N)=L′ (v N)=L(v N)=q
f
and
for all N +2≤i≤ℓ, t last(v i,ρ′′ )≤b first(v i−1,ρ′′ );
for all 1≤i≤N −2, t last(v i,ρ′′ )≤b first(v i+1,ρ′′ ).
□
E.2.1.2 Proof of Lemma 6.4
WearenowreadytoproveLemma6.4. Webeginwiththreeobservationsthatholdregardless
of whether P is 2-phase-bounded or not. In a line Γ = (V,E) with V = {v 1,...v ℓ} and
E ={⟨v i,v i+1⟩∣1≤i<ℓ}, we define the distance between two nodes v i,v
j
as d(v i,v j)=∣j−i∣.
▶ Observation E.6. Let C,C′ ∈C, and u,v∈V(Γ) such that d(v,u)≥3. If C —u, →t C 1—v —,t →′ C′
for two transitions t,t′ ∈∆ and a configuration C 1 ∈C, then there exists C 2 ∈C such that
C —v —,t →′ C 2—u, →t C′.
▶ Observation E.7. Let C,C′ ∈ C, and u,v ∈ V(Γ) such that d(u,v) ≥ 2. Then if C —u, →t
C 1 —v —,t →′ C′ for two transitions t,t′ ∈ ∆ with one of the two transitions internal and a
configuration C 1∈C, then there exists C 2∈C such that C —v —,t →′ C 2—u, →t C′.
▶ Observation E.8. Let C,C′ ∈ C, and u,v ∈ V(Γ). Then if C —u, →t C 1 —v —,t →′ C′ for two
internal transitions t,t′ ∈∆ and a configuration C 1 ∈C, then there exists C 2 ∈C such that
C —v —,t →′ C 2—u, →t C′.
v0,t0 v1,t1 vn−1,tn−1
For the rest of this proof we let ρ=C
0
———→C
1
———→⋯—————→C
n
be the execution
obtained from Lemma E.2. We define j 1∶=t last(v N−3,ρ)+1 and j 2=t last(v N+3,ρ)+1.
▶ Lemma E.9. Let 0 ≤ j < j 1 be the maximal index such that C j —v —j, —t →j C j+1, for some
vj ∈{v N−1,v N,...,v ℓ} then, C 0→∗C j —v —j+ —1, —tj —+ →1 C j′ +1→∗C j′ 1−2—v —N —−3 —,t —j →1 C j′ 1−1—v —j, —t →j C j1.
Proof. Let 0 ≤ j < j 1 be the maximal index such that C j —v —j, —t →j C j+1 for some v ∈
{v N−1,v N,...v ℓ}.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyRecallthatj 1=t last(v N−3,ρ)+1,andrecallthatt last(v N−3,ρ)≤b first(v N−2,ρ),henceeither
b first(v N−2,ρ) = −1 and so it never broadcast anything, either j 1 ≤ b first(v N−2,ρ). In both
cases, v does not broadcast anything between C and C .
N−2 0 j1
As j is maximal, for all j <k<j 1, vk ∈{v 1,...,v N−2} and if vk =v N−2, tk is internal. We
prove by induction that for all j ≤k<j 1:
P(k): there exists C j′ +1,...,C k′ such that C
j
—v —j+ —1, —tj —+ →1 C j′ +1→⋯—v —k, —t →k C k′ —v —j, —t →j C k+1.
For k=j, the induction property trivially holds.
Let j ≤k <j 1−1 such that C
j
—v —j+ —1, —tj —+ →1 C j′ +1⋯—v —k, —t →k C k′ —v —j, —t →j C k+1. Let C
k+1
—v —k+ —1, —tk —+ →1
C .
k+2
First case: vj = v N−1. Then, since j ≤ k+1 ≤ j 1−1 = t last(v N−3,ρ) ≤ b first(v N−2,ρ) ≤
t last(v N−2,ρ)≤b first(v N−1,ρ), byLemmaE.2, tj cannotbeabroadcastandisthusaninternal
transition. If vk+1 ∈{v 1,...,v N−3}, then d(v N−1,vk+1 )≥2 and we apply Observation E.7, to
get that there exists C k′
+1
such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2. If vk+1 =v N−2, then tk+1
is internal and we can hence apply Observation E.8 to get that there exists C′ such that
k+1
C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
Second case: vj = v N. Then, if vk+1 ∈ {v 1,...v N−3} and so d(v N,vk+1 ) ≥ 3: We can
apply Observation E.6 to get that there exists C k′
+1
such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
Otherwise, vk+1 = v N−2 and tk+1 is internal and d(v N,v N−2) = 2 and so we can apply
Observation E.7 to get that there exists C k′
+1
such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
Thirdcase: vj ∈{v N+1,...v ℓ}. Thend(vj,vk+1 )≥3andsowecanapplyObservationE.6
to get that there exists C k′
+1
such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
◀
▶ Lemma E.10. Let j 1 ≤ j < j 2 the maximal index such that C j —v —j, —t →j C j+1, for some
vj ∈ {v N−2,v N−1,v N,v N+1}, then, C j1 →∗ C j —v —j+ —1, —tj —+ →1 C j′ +1 —v —j+ —2, —tj —+ →2 ⋯ → C j′ 2−2 —v —N —+3 —,t —j →2
C j′ 2−1—v —j, —t →j C j2.
Proof. Let j 1 ≤ j < j 2 be the maximal index such that C j —v —j, —t →j C j+1 for some v ∈
{v N−2,v N−1,v N,v N+1}.
Recall that j 1 = t last(v N−3,ρ)+1, and that t last(v N−3,ρ) ≥ b first(v N−3,ρ) ≥ t last(v N−4,ρ),
and so by a simple inductive reasoning: j 1>t last(v,ρ) for all v∈{v 1,...,v N−3}. Hence, for
all j 1≤k<j 2, vk ∉{v 1,...,v N−3}.
Hence, as j is maximal, for all j < k < j 1, vk ∈ {v N+2,...,v ℓ}. We prove by induction
that for all j ≤k<j 2, there exist C j′ +1,...C k′ such that C
j
—v —j+ —1, —tj —+ →1 C j′ +1→⋯C k′ —v —j, —t →j C k+1.
For k = j, the induction property trivially holds. Let j ≤ k < j 2−1 such that there exist
C j′ +1,...C k′ with C
j
—v —j+ —1, —tj —+ →1 C j′ +1→⋯C k′ —v —j, —t →j C k+1. Denote C k+1—v —k+ —1, —tk —+ →1 C k+2.
First case: vj = v N+1. Then, t last(v N+2,ρ) ≤ b first(v N+1,ρ) by Lemma E.2, and
t last(v N+3,ρ) ≤ b first(v N+2,ρ) ≤ t last(v N+2,ρ). Since k+1 ≤ j 2 −1 = t last(v N+3,ρ), k+1 ≤
t last(v N+3,ρ)≤b first(v N+1,ρ), and so, tj cannot be a broadcast, and is an internal transition.
If vk+1 ∈{v N+3,...v ℓ} then d(v N+1,vk+1 )≥2 and we can apply Observation E.7 to get that
there exists C k′ +1 such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1 —v —j, —t →j C k+2. Otherwise, vk+1 = v N+2. Recall
that j 2 = t last(v N+3,ρ)+1 and that k+1 ≤ t last(v N+3,ρ) ≤ b first(v N+2,ρ), hence tk+1 is an
internal transition. Hence we can apply Observation E.8 to get that there exists C′ such
k+1
that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanySecond case: vj = v N. Then, if vk+1 ∈ {v N+3,...v ℓ} and so d(v N,vk+1 ) ≥ 3, we can
apply Observation E.6 to get that there exists C k′
+1
such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
Otherwise, vk+1 = v N+2 and tk+1 is internal and d(v N,v N+2) = 2 and so we can apply
Observation E.7 to get that there exists C k′
+1
such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
Thirdcase: vj ∈{v N−2,v N−1}. Thend(vj,vk+1 )≥3andsowecanapplyObservationE.6
to get that there exists C k′
+1
such that C k′ —v —k+ —1, —tk —+ →1 C k′ +1—v —j, —t →j C k+2.
◀
We are now ready to prove Lemma 6.4.
Proof of Lemma 6.4. Let j 1(ρ)∶=t last(v N−3,ρ)+1 and j 2(ρ)=t last(v N+3,ρ)+1. We let
i 1,...i k theindices0≤i 1<⋯<i k <j 1(ρ)suchthatC ij —v —,t →j C ij+1 forsomev∈{v N−1,...,v ℓ}
and t
j
∈∆ We denote EarlyActions[ρ] the number of such indices.
We build inductively ρ 0,ρ 1,...ρ k such that for all j, ρ j =C 0→∗Cj =(Γ,Lj ) with:
P 1(j): Lj (v N)=q f, and
P 2(j): EarlyActions[ρ j]=k−j, and
P 3(j): the order of Lemma E.2 is preserved, i.e. for all 1 ≤ i ≤ N −2, t last(v i,ρ j) ≤
b first(v i+1,ρ j) and for all N +2≤i≤ℓ, t last(v i,ρ j)≤b first(v i−1,ρ j).
For j =0, define ρ 0=ρ. It trivially satisfies the induction properties.
Let 0≤j <k and assume we have built ρ
j
satisfying P 1(j), P 2(j) and P 3(j) and denote
it ρ j = C 0j —v —0, —t →0 C 1j —v —1, —t →1 ⋯ —v —n− —1 —tn —− →1 C nj = (Γ,Lj n). Let i be the maximal index such that
i < j 1(ρ j) and C i —vi —,t →i C i+1 for some vi ∈ {v N−1,...,v ℓ} and t ∈ ∆. From Lemma E.9,
there exists C i′ +1,...C j′
1(ρj)−1
such that C 0j →∗C ij —v —i+ —1, —ti —+ →1 C i′ +1—v —i+ —2, —ti —+ →2 ⋯→C j′ 1(ρj)−1—vi —,t →i
C jj 1(ρj), hence we define ρ j+1=C 0j →∗C ij —v —i+ —1, —ti —+ →1 C i′ +1→∗C j′ 1(ρj)−1—vi —,t →i C jj 1(ρj)→∗C n. By
construction P 1(j+1) holds. Furthermore, j 1(ρ j+1)=t last(v N−3,ρ j+1)+1=j 1(ρ j)−1 and so
EarlyActions[ρ j+1]=EarlyActions[ρ j]−1=k−j−1 and so P 2(j+1) holds.
We denote vi =v r. Recall that v
r
∈{v N−1,...,v ℓ}. Observe that for all 1≤k≤ℓ, it holds
that:
if k<ℓ and k∉{r−1,r}, then t last(v k,ρ j+1)≤b first(v k+1,ρ j+1) if and only if t last(v k,ρ j)≤
b first(v k+1,ρ j);
if k>0 and k∉{r,r+1}, then t last(v k,ρ j+1)≤b first(v k−1,ρ j+1) if and only if t last(v k,ρ j)≤
b first(v k−1,ρ j).
Hence, by P 3(j), for all 1≤k≤N −2, if k∉{r−1,r} t last(v k,ρ j+1)≤b first(v k+1,ρ j+1) and for
all N +2≤k≤ℓ, if k∉{r,r+1}, t last(v k,ρ j)≤b first(v k−1,ρ j).
Let now 1≤k≤N −2, such that k∈{r−1,r}. As N −1≤r≤ℓ, k=N −2 and r=N −1.
As j 1(ρ j) > i ≥ 0, from P 3(j), we get that j 1(ρ j)−1 = b first(v N−3,ρ j) ≤ t last(v N−3,ρ j) <
b first(v r−1,ρ j) ≤ t last(v r−1,ρ j) < b first(v r,ρ j). Hence t last(v r−1,ρ j+1) = t last(v r−1,ρ j), and
b first(v r,ρ j+1)=b first(v r,ρ j).
Let now N +2 ≤ k ≤ ℓ, such that k ∈ {r,r+1}, hence, N +1 ≤ r ≤ ℓ. If k = r, then
notice that either t last(v r,ρ j) > i or t last(v r,ρ j) = i. In the first case, as for all i < i 2 <
j 1(ρ j), vi2 ∉ {v N+1,...,v ℓ}, it holds that t last(v r,ρ j) > j 1(ρ j+1), and so t last(v r,ρ j+1) =
t last(v r,ρ j), and, from P 3(j), j 1(ρ j) ≤ t last(v r,ρ j+1) ≤ b first(v r−1,ρ j) = b first(v r−1,ρ j+1). If
t last(v r,ρ j)=i, then t last(v r,ρ j+1)=j 1(ρ j)−1. As for all i<i 2<j 1(ρ j), vi2 ∉{v N+1,...,v ℓ},
itholdsthatt last(v r,ρ j)≤j 1(ρ j)−1≤b first(v r−1,ρ j)=b first(v r−1,ρ j+1). Hence,t last(v r,ρ j+1)≤
b first(v r−1,ρ j+1).
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyIfk=r+1,then,asforalli<i 2<j 1(ρ j),vi2 ∉{v N+1,...,v ℓ},itholdsthatt last(v k,ρ j+1)=
t last(v k,ρ j) and if ti is internal, b first(v r,ρ j+1) = b first(v r,ρ j). Otherwise, b first(v r,ρ j) ≤
b first(v r,ρ j+1). From P 3(j), it holds that t last(v k,ρ j+1) = t last(v k,ρ j) ≤ b first(v k−1,ρ j) ≤
b first(v k−1,ρ j+1). Hence P 3(j+1) holds.
Hence, we build ρ k such that ρ k = C 0k →∗ C jk 1(ρk) →∗ C nk and P 1(k), P 2(k) and P 3(k)
hold.
With the same reasoning between C and C , and applying this time Lemma E.10, we
j1 j2
finally get an execution ρ′ =C 0′ →∗C j′ 1(ρ′)→∗C j′ 2(ρ′)→∗C n′ such that:
for all 1≤i≤N −2, t last(v i,ρ′ )≤b first(v i+1,ρ′ );
for all N +2≤i≤ℓ, t last(v i,ρ′ )≤b first(v i−1,ρ′ ).
nodes issuing transitions between C 0′ and C j′ ′ belong to {v 1,...,v N−3,v N−2} and v N−2
only performs internal transitions (because j 11 (ρ′ )=t last(v N−3,ρ′ )+1≤b first(v N−2,ρ′ );
nodes issuing transitions between C j′ ′ and C j′ ′ belong to {v N+2,v N+3,...,v ℓ} and v N+2
1 2
only performs internal transitions;
It is left to prove that in C j′ 2(ρ′)→∗C n′, only nodes in {v N−2,v N−1,v N,v N+1,v N+2} issue
transitions. Assume a node v ∉ {v N−2,v N−1,v N,v N+1,v N+2} issues a transition between
C t laj′ s2 t( (ρ v′) ,ρa ′ )nd ≤tC lan s′ t, (vh Ne −n 3c ,e ρ′b )y <d je 1fi (ρn ′i )ti <on j 2, (t ρla ′s )t( av n, dρ′ w) e≥ rej a2 c( hρ′ a). coE ntit rh ader ictv io∈ n.{v O1 r,. v.. ∈v {N v− N3 +} 3,a .n .d .vs ℓo }
and so t last(v,ρ′ )≤t last(v N+3,ρ′ )<j 2(ρ′ ) and we reach a contradiction. □
E.2.2 Completeness of the algorithm
This part is dedicated to prove the following lemma.
▶ Lemma E.11. If q
f
is coverable with a line topology, then there exist q 1,q 2∈H such that
C
q1,q2
→∗C and C =(Γ 5,L) with L(v 3)=q f.
If q
f
is coverable, then let ρ=C 0→∗C
j1
→∗C
j2
→∗C
n
be the execution obtained from
Lemma 6.4 with j 1=b first(v N−3,ρ)+1 and j 2=b first(v N+3,ρ)+1. We denote C i=(Γ,L i) for
all 0≤i≤n.
We start by proving that L j1(v N−2)∈H and L j2(v N+2)∈H. We need three preliminaries
lemmas.
▶ Lemma E.12. For all 0≤j ≤b first(v 1,ρ), (L j(v 1),q in)∈S.
Proof. We prove the lemma by induction on j. For j =0, L 0(v 1)=q
in
and by construction
vj,tj
(q in,q in) ∈ S. Let 0 ≤ j < b first(v 1,ρ) such that (L j(v 1),q in) ∈ S. Denote C j ———→ C j+1.
Observe that either L j(v 1) = L j+1(v 1) (and there is nothing to do), or vj ∈ {v 1,v 2}. As
j <b first(v 1,ρ), from Item 1 of Lemma 6.4, it holds that j <b first(v 1,ρ)≤b first(v 2,ρ). Hence tj
is internal and if vj =v 2, L j(v 1)=L j+1(v 1). Otherwise, vj =v
1
and (L j(v 1),q in)∈S. Hence,
(L j+1(v 1),q in)∈S by definition of S.
◀
We adopt the convention that L −1(v)=q
in
for all v. We prove the following lemma by
induction on k.
▶ Lemma E.13. For all 1 < k ≤ N −2, if L bfirst(vk−1,ρ)(v k−1) ∈ H, then L j(v k) ∈ H for all
b first(v k−1,ρ) ≤j ≤b first(v k,ρ).
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyProof. Let 1<k≤N −2 such that L bfirst(vk−1,ρ)(v k−1)∈H, we prove the lemma by induction.
For ease of readability, denote jk−1 =b first(v k−1,ρ) and jk =b first(v k,ρ). By definition of H,
there exists q∈Q such that (L jk−1(v k−1),q)∈S.
First let us show that for all 0 ≤ j ≤ jk−1, (L j(v k),L jk−1(v k−1)) ∈ S: for j = 0, as
(L jk−1(v k−1),q)∈S,bydefinitionofS,(q in,L jk−1(v k−1))∈S. Letnow0≤j <jk−1anddenote
C j —v —j, —t →j C j+1. Recall that in ρ, as j <jk−1 ≤j 1, it holds that vj ∈{v 1,...v N−2} (Item 1 of
Lemma 6.4). Furthermore, as j <jk−1, then j <b first(v,ρ) for all v∈{v k−1,...,v N−2} (Item 2
of Lemma 6.4). Hence, either tj is an internal transition, or vj ∈{v 1,...v k−2}. In the latter
case, L j+1(v k) = L j(v k). Otherwise, either vj ≠ v k and so L j+1(v k) = L j(v k) and there is
nothingtodo,orvj =v
k
andso(L j(v k),τ,L j+1(v k))∈∆andso,as(L j(v k),L jk−1(v k−1))∈S,
(L j+1(v k),L jk−1(v k−1))∈S by definition of S.
Hence(L jk−1(v k),L jk−1(v k−1))∈S. Wenowprovethatforalljk−1 ≤j ≤jk,(L j(v k),L j(v k+1))∈
S. As we just proved it for j = jk−1, let jk−1 ≤ j < jk, and denote C j —v —j, —t →j C j+1. Note
that from Lemma 6.4, we get that (a) vj ∈ {v 1,...,v N−2} as j < b first(v k,ρ) ≤ j 1; (b) as
j ≥jk−1, it holds that j ≥t last(v,ρ) for all v ∈{v 1,...,v k−2}, hence vj ∉{v 1,...,v k−2}; and
(c) if vj ∈{v k,...v N−2}, then tj is an internal transition as j <b first(v k,ρ)≤b first(v,ρ) for all
v∈{v k,...v N−2}.
Overall, we get that either vj =v k−1, or vj ∈{v k,...,v N−2} and tj is internal. In the first
case, all cases (tj is an internal transition, tj is a broadcast transition and the message is
received by v , or tj is a broadcast transition and the message is not received by v ) are
k k
covered by our definition of S. In the latter case, either vj ≠v
k
and v
k
and v
k−1
remain on
the same states, or vj =v
k
and this case is covered by our definition of S (tj is internal).
◀
Hence, as L bfirst(v1,ρ)(v 1)∈H from Lemma E.12, by applying inductively Lemma E.13, we get
that L j(v N−2)∈H for all b first(v N−3,ρ) ≤j ≤b first(v N−2,ρ). As j
1
=b first(v N−3,ρ)+1, then
L j1(v N−2)∈H.
With a similar reasoning on v and between C and C , we get the following lemma.
N+2 j1 j2
▶ Lemma E.14. L j1(v N−2)∈H and L j2(v N+2)∈H.
vj2,tj2 vj2+1,tj2+1
Denote q 1 = L j1(v N−2) and q 2 = L j2(v N+2). Denote C j2 ————→ C j2+1 ——————→
⋯—v —n− —1, —tn —− →1 C n. RecallthatfromItem1ofLemma6.4,vj2,...vn−1 ∈{v N−2,v N−1,v N,v N+1,v N+2}.
DenoteC
q1,q2
=(Γ 5,L q1,q2),andobservethatL q1,q2(v i)=L j2(v N−3+i)forall1≤i≤5. Hence,
v0,t0 v1,t1 vn−j2−1,tn−j2−1
C q1,q2 =C 0′ ——2 —→2 C 1′ ——2 —→2 ⋯—2 —————2 ——→C n′ −j2 where for all 0 ≤j ≤n−j 2: C j′ =(Γ 5,L′ j)
and L′ j(v i) = L j2+j(v N−3+i) for all 1 ≤ i ≤ 5. And for all 0 ≤ j < n−j 2: tj 2 = tj2+j
and if vj2+j = v N−3+i for some 1 ≤ i ≤ 5, then v 2j = v i. Hence, C q1,q2 →∗ C n′ −j2 with
L′ n−j2(v 3)=L n(v N)=q f. This concludes the proof of Lemma E.11.
E.2.3 Correctness of the algorithm
This part is devoted to prove the following lemma.
▶ Lemma E.15. If there exist q 1,q 2∈H, v∈V(Γ 5), such that C
q1,q2
→∗C and C =(Γ 5,L)
with L(v)=q f, then there exist Γ∈Lines, C 0 ∈I, C′ =(Γ,L′ )∈C such that C 0 →∗ C′ and
L′ (v)=q f.
We start by proving the following lemma.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany▶ Lemma E.16. For all q∈H, there exists k∈N such that q is coverable with a line topology
Γ=({v 1,...,v k},{⟨v i,v i+1⟩∣1≤i<k}) and vertex v 1.
Proof. We will in fact prove that for all (q 1,q 2) ∈ S, there exists Γ q1,q2 ∈ Lines such that
V(Γ q1,q2)={v 1,...,v k}, E(Γ q1,q2)={⟨v i,v i+1⟩∣1≤i<k} for some k∈N with k≥2 and there
exists C 0∈I, C =(Γ q1,q2,L) with C 0→∗C and L(v 1)=q
1
and L(v 2)=q 2.
Denote S 0,...,S
K
the subsets defined by the algorithm to build S. We have that S =S N.
We prove the property to be true for all (q 1,q 2)∈S
i
by induction on 0≤i≤N. For i=0,
S 0 = {(q in,q in)}, this is trivial: define Γ qin,qin = ({v 1,v 2},{⟨v 1,v 2⟩}) and take the initial
configuration C =(Γ qin,qin,L 0) with L 0(v 1)=L 0(v 2)=q in. Let 0≤i<K, and assume we
proved the property to be true for all (q 1,q 2)∈S i. Let (q 1,q 2)∈S i+1∈S i.
if there exists (q 1,p 2) ∈ S i such that (p 2,τ,q 2) ∈ ∆, let Γ q1,p2 ∈ Lines, and C 0 and
C =(Γ q1,p2,L) obtained from the induction hypothesis such that C 0→∗C and L(v 1)=q
1
and L(v 2) = p 2. Then, C —v2 —,( —p —2, —τ, —q2 →) C′ and C′ = (Γ q1,p2,L′ ) with L′ (v 1) = q 1 and
L′ (v 2)=q 2;
if there exists (p 1,q 2)∈S
i
such that (p 1,τ,q 1)∈∆, the reasoning is the same as in the
previous case;
if there exists (p 1,p 2)∈S
i
and m∈Σ such that (p 1,?m,q 1)∈∆ and (p 2,!!m,q 2)∈∆, we
use a similar reasoning as in the previous cases;
if there exists (q 1,p 2)∈S
i
and m∈Σ such that(p 2,!!m,q 2)∈∆ and m∉R(q 1), we use a
similar reasoning as in the previous cases;
ifthereexistsq
3
suchthat(q 2,q 3)∈S
i
andq 1=q in,thenletΓ q2,q3,C
0
andC =(Γ q2,q3,L)
obtainedfromtheinductionhypothesissuchthatC 0→∗C andL(v 1)=q
2
andL(v 2)=q 3.
Define Γ q1,q2 = ({v 1′ }∪V(Γ q2,q3),{⟨v 1′,v 1⟩}∪E(Γ q2,q3)). Denote C 0 —v —0, —t →0 ⋯ —v —n− —1, —tn —− →1
C n=C. Recall that as L n(v 1)∈H, L n(v 1)∈Q 0∪Qr 1, hence for all 0≤i≤n−1, if vi =v
1
then ti is internal. Hence, there exists C 0′...C n′ such that C 0′ —v —0, —t →0 ⋯—v —n− —1, —tn —− →1 C n′ and:
for all 0 ≤ i < n−1, with C i′ = (Γ q1,q2,L′ i) and C i = (Γ q2,q3), and for all v ∈ V(Γ q2,q3),
L′ i(v)=L i(v) and L′ i(v 1′ )=q in. Hence L′ n(v 1′ )=q
in
and L′ n(v 1)=q 2.
◀
We are now ready to prove Lemma E.15.
Proof of Lemma E.15. Let q 1,q 2∈H, from Lemma E.16, let Γ q1 =({v 1,...,v k},{⟨v i,v i+1⟩∣
1≤i<k}), and Γ
q2
=({v 1′,...,v n′ },{⟨v i′,v i′ +1⟩∣1≤i<n}) the two line topologies such that
q
1
is coverable with v
1
and q
2
with v 1′. Denote C
0
→∗ C with C =(Γ q1,L) and L(v 1)=q
1
and C 0′ →∗ C′ with C′ =(Γ q2,L′ ) and L′ (v 1′ )=q 2. As q 1,q 2 ∈H and H ⊆Q 0∪Qr 1, v 1 does
not broadcast anything between C and C and v′ does not broadcast anything between C′
0 1 0
and C′.
Define Γ=(V,E) such that V =V(Γ q1)∪V(Γ q2)∪{u 2,u 3,u 4} and E =E(Γ q1)∪E(Γ q2)∪
{⟨v 1,u 2⟩,⟨u 2,u 3⟩,⟨u 3,u 4⟩,⟨u 4,v 1′ ⟩}. Note that v
1
and v 1′ are not neighbors, and that each
node in V(Γ q1) [resp. in V(Γ q2)] has the same neighborhood as before, except for v 1, and v 1′
which have an additional new neighbor, respectively u 2 and u 4. Denote C 0′′ =(Γ,L′ 0′ ) with
L′ 0′ (v)=q
in
for all v∈V(Γ).
Denote C 0 —v —1, —t →1 C 1 —v —2, —t →2 ⋯—v —n1 —,t —n →1 C n1 =C and C 0′ —v —′1, —t′ →1 C 1′ —v —′2, —t′ →2 ⋯—v —′n —2, —t′ —n →2 C n′
2
=
C′. Then C 0′′ —v —1, —t →1 C 1′′ —v —2, —t →2 ⋯ —v —n1 —,t —n →1 C n′′ 1 —v —′1, —t′ →1 C n′′ 1+1 —v —′2, —t′ →2 ⋯ —v —′n —2, —t′ —n →2 C n′′ 1+n2 with
C n′′ 1+n2 = (Γ,L′ n′ 1+n2) and L′ n′ 1+n2(v) = L n1(v) for all v ∈ V(Γ q1) and L′ n′ 1+n2(v) = L′ n2(v)
for all v ∈ V(Γ q2) and L′ n′ 1+n2(v) = q in for all v ∈ {u 2,u 3,u 4}. Hence L′ n′ 1+n2(v 1) = q 1 and
L′ n′ 1+n2(v 1′ )=q 2.
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,GermanyFinally, rename Γ 5 = ({u 1,u 2,u 3,u 4,u 5},{⟨u i,u i+1⟩ ∣ 1 ≤ i < 5}), and v 1 by u 1 and v 1′
by u 5. Denote C q5 1,q2 —u —1, —δ →1 C 15 —u —2, —δ →2 ⋯ —u —n3 —,δ —n →3 C n5 3. Denote C q5 1,q2 = (Γ 5,L q1,q2) and
C n5 3 = (Γ 5,L5 n3) Note that for all u ∈ V(Γ 5), L q1,q2(u) = L′ n′ 1+n2(u). Hence, C n′′ 1+n2 —u —1, —δ →1
C n′′ 1+n2+1 —u —2, —δ →2 ⋯ —u —n3 —,δ —n →3 C n′′ 1+n2+n3 with C n′′ 1+n2+n3 = (Γ,L′ n′ 1+n2+n3) and L′ n′ 1+n2+n3(v) =
L n1(v) for all v∈{u 1,u 2,u 3,u 4,u 5}. Hence L′ n′ 1+n2+n3(u 3)=q f.
□
©L.GuillouandA.SangnierandN.Sznajder;
licensedunderCreativeCommonsLicenseCC-BY4.0
LeibnizInternationalProceedingsinInformatics
SchlossDagstuhl–Leibniz-ZentrumfürInformatik,DagstuhlPublishing,Germany