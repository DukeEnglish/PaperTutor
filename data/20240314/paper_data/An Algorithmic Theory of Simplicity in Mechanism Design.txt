An Algorithmic Theory of Simplicity in Mechanism Design
Diodato Ferraioli Carmine Ventre
Abstract
A growing body of work in economics and computation focuses on the trade-off between imple-
mentabilityand simplicity in mechanism design. Thegoal istodevelop atheorythat not onlyallows to
designanincentivestructureeasytograspforimperfectlyrationalagents,butalsounderstandtheensu-
inglimitationsontheclassofmechanismsthatenforceit. Inthiscontext,theconceptofOSPmechanisms
hasassumedaprominentrolesincetheyprovablyaccountfortheabsenceofcontingentreasoningskills,
aspecific cognitive limitation. Forsingle-dimensional agents, it is known that OSPmechanisms need to
use certain greedy algorithms. In this work, we introduce a notion that interpolates between OSP and
SOSP, a more stringent notion where agents only plan a subset of their own future moves. We provide
analgorithmic characterization ofthisnovelclass ofmechanismsfor single-dimensional domains andbi-
naryallocation problems,thatpreciselymeasurestheinterplaybetweensimplicityandimplementability.
We build on this to show how mechanisms based on reverse greedy algorithms (a.k.a., deferred accep-
tance auctions) are algorithmically more robust to imperfectly rationality than those adopting greedy
algorithms.
1 Introduction
A set of agents need to determine an outcome that will affect each of them. In these cases, a mechanism is
designedto interactwiththe agentsandcompute anoutcomebasedonthe decisionsmade during the inter-
action. In its more general form, the mechanism can be modelled as an extensive-form game. To guarantee
properties on the quality of the solution computed (e.g., optimality for an objective function of interest)
mechanisms are required to provide incentives for the agents to behave in a predictable and desirable way.
For example, in dominant-strategy incentive-compatible mechanisms, it is pointwise optimal for the agents
to behave correctly and truthfully report their private information to the mechanism. This property can
howeverbetooweakforcertainagents,asobservedexperimentally[7,19]. Inparticular,differentextensive-
form implementations of the mechanism can lead to different degrees of strategic confusion. Consider, for
example, software agents that take decisions during the execution of the mechanism. These agents could
take actions that are irrationalfrom the economic point of view when they have been “badly” programmed,
either because the programmermisunderstood the incentive structure inplace ordue to computationalbar-
riers preventing from comparing payoffs for each strategy adopted by the other agents [25]. A less complex
decision process would be guaranteed by associating one outcome/payoff to each possible action taken by
the agent, since she would simply need to rank her own actions independently of the behavior of the other
agents. This is the idea behind obviously strategyproof (OSP) mechanisms [22]. OSP is a stronger notion
of incentive-compatibility that takes a conservative view and requires honesty to be an obviously dominant
strategy: theworstpayoffthatcanbe achievedbychoosingitisnotworsethanthebestpossiblepayoffthat
canbe obtainedwitha differentstrategy,where worstandbestarechosenoverthe possible strategiesofthe
remaining agents.
OSPisshowntocapturetheincentivesofaspecificformofimperfectrationality—absenceofcontingent
reasoning skills. From the computational point of view, OSP is known to be intimately linked with greedy
algorithms for single-dimensional agents: OSP is equivalent to certain well-defined combinations of greedy
algorithmsthataresuitablymonotoneintheagent’sprivateinformation[13,17]. Thisalgorithmiclensallows
tofocusonthe qualityofthesolutionsoutputbyOSPmechanisms,measuredintermsoftheapproximation
1
4202
raM
31
]TG.sc[
1v01680.3042:viXraguarantee to a given objective function, and conclude that these monotone greedy algorithms can perform
well for some binary allocation problems [13] but, in general, less well for richer solution spaces [17].
Does OSP encapsulate strategic simplicity in mechanismdesign? Consider agentswith limited foresight,
who can only devise a plan for their next k moves (their planning horizon) but cannot anticipate what they
will do after that. It may not be simple enough for agents to go beyond that horizon in their reasoning; in
chess,forexample, ifwhite canalwayswin, anywinning strategyis obviouslydominantbut requiresto look
at many movesin the future meaning that the strategicchoices in chess arefar fromobvious[27]. Similarly,
software agents may need more data to be “retrained” and get a more granular picture of the scenarios
that go beyond their k-th future move and plan accordingly. What is simplicity in mechanism design for
these agents? OSP would result simple for agents with infinite planning horizons(e.g., agents who need not
retrain and have all the data available from the beginning). A solution concept called Strong OSP (SOSP)
hasbeenrecentlyintroducedintheliteraturetodefinesimplicity foragentswhocannotforecastanyoftheir
own future moves [27] (e.g., those who need to retrain after each move). Is there a notion that interpolates
between these two extremes? Do we, in case, get a large class of implementable mechanisms the longer the
planning horizons of the agents are?
1.1 Our Contribution
We introduce the notion of k-step OSP mechanisms to capture the incentive compatibility of agents who
decidetheirnextmovebyonlyplanningforthesubsequentkstepsandleavetheremainingmovesundecided.
Thus, OSP correspondsto the case in which k =∞ since, when determining their next move, agents reason
about all their subsequent actions in the extensive-form mechanism. SOSP, on the contrary, corresponds
to the case in which k = 0 in that no extra future action is planned for in addition to the one under
consideration. We fully characterize k-step OSP mechanisms with transfers for single-parameteragents and
binary allocation problems:
Main Theorem 1 (informal). A mechanism is k-step OSP for single-parameter agents
and binary allocation problems if andonly if each agentreceives at mostk+2“OSPqueries”,
the (k+2)-th (if any) being “payoff-neutral up to one type”.
In the informal statement above, by “OSP query” we mean that the extensive-form mechanism must satisfy
the ensuing OSP constraints,whereas by “payoff-neutralup to one type query” we mean that the payoff for
the queried agent i is essentially determined for all her moves but potentially one; this move corresponds
to a single type of i for which her outcome can still be undecided at that point of the game. Whilst it is
expected that the queries must be OSP, it is surprising that there is clean connection between the number
of possible queries that each agent can be asked and her planning horizon, with up to k+1 “unrestricted”
queries to each agent i and one closing extra query that not only can affect the outcome that the other
playerswillreceivebutalsoi’soutcome(albeitverylimitedly)1. Thisresultthus showsthatournotionfully
capturesthe trade-offbetweensimplicityandimplementability. Themoresophisticatedthe decisionmaking
ofthe agentsis,the moremechanismsareincentivecompatible. Inparticular,ournotiongivesrisetoafully
nested class of mechanisms since every k-step OSP mechanism is also k′-step OSP for each k′ >k.
To prove this characterization,we developthe theoretical foundations to study k-stepOSP mechanisms.
We prove that it is without loss of generality to focus on a certain family of implementations, called round-
tablemechanisms,andwefindastructuralpropertyofk-OSPconstraintsthatlimitstheclassofqueriesthat
the mechanismcanmake2. We subsequentlygive a versionof the TaxationPrinciple for k-OSPmechanisms
by proving that from a certain point of the extensive-form game, outcomes (and payments) need to be
constant for the agent being queried. Few additional structural properties are then proved to bound the
number of queries to k+2 and determine what is the power of the last query.
This result complements the results by Pycia and Troyan [27] for binary allocation problems from two
perspectives. Firstly, our characterization says that each agent has two payoff relevant queries in an SOSP
1Noteindeedthatthisconnectionisneitheran“innate” norastraightforwardpropertyofk-stepOSPmechanisms,sincefor
largeroutcomespaces theremaybek-stepOSPmechanismswithmorethank+2queries(cf. AppendixB).
2Theseresultsdonotrequiretheoutcomespacetobebinary.
2mechanism. Underanassumptionofrichdomains,PyciaandTroyan[27]proveinsteadthatagentsonlytake
onepayoff-relevantmoveinSOSPmechanisms. Thus,ourresulthighlightsthatforgeneralsingle-dimensional
type domains, there can be a second query which affects the outcome of the queried agent in a very specific
and limited way. Secondly, Pycia and Troyan[27] consider a notion of k-step dominance (see Appendix A),
whichisveryrelatedtoours,inthatagentsthink aboutk future selfmoveswhentakingadecision. Itturns
outthattheirdefinitionistechnicallydifferent,withconsequencesontheboundariesbetweensimplicityand
implementability. In the work of Pycia and Troyan[27], although agents take into account their subsequent
k moves they do not commit to them but rather follow the principle of “cross[ing] that bridge when you
come to it” (i.e., make choices as they arise) [28]. It is thus assumed that agents in their decision making
process optimistically complete the path of play beyond their planning horizon. To some extent, our notion
formalizesthe“lookbeforeyouleap” (i.e.,createacompletecontingentplanforthepossiblekfuturedecisions
one may have) model of decision making [28] and take a pessimistic perspective by considering the worst
possible way in which the agent can complete her path of play beyond her planning horizon. Consequently,
our approach is more restrictive but more robust to decisions made outside the agents’ planning horizons.
(Please see Example 1 for an illustration of the differences between the two notions.) Importantly, within
their modelling of decision making, Pycia and Troyan [27] prove that one future move is enough for 1-step
simple mechanisms,forwhichhonesty is one-stepdominant, to collapseto OSPmechanisms. In fact,agents
canat eachstep reconsiderwhether the plan that was 1-stepdominantat the previousdecisionpoint is still
therightwaytogo;intuitively,thisfreedomallowstheagentstoreconstructanobviouslydominantstrategy
step by step. Our notion instead draws a more fine grained boundary between the mechanisms that can be
implemented and the behavioral model of the agents interacting with them.
Example 1 (Ascending price auctions). Consider an ascending auction for a single good, where at each
non-terminal information set, an agent is called to play and has two actions, Stay In or Drop Out. The
payoff of an agent i is equal to the agent’s valuation v minus her payment if the agent is allocated the good
i
and 0 otherwise. The price for the good weakly increases along each path of play. The auction ends when
there is only one agent who has not dropped out; she wins the good and pays the price associated to the last
time she moved. We remark that the ascending auction is OSP because the strategy of staying in as long as
the current price is below the agent’s valuation is obviously dominant, as shown in [22].
Aone-stepdominant strategyatinformation setI∗ isthefollowing. Ifp(I∗), thepriceat I∗, isnothigher
than v , then Stay In and Drop Out at the subsequent information set I along a path of play. If the price at
i
I∗ is higher than v , then Drop Out at I∗ and the subsequent information set I. This is one-step dominant
i
because in both cases, the minimum from following the strategy is 0 (dropping out eventually) which is not
worsethan otherstrategies atI∗ which can onlyguaranteeanon-positivepayoff. Importantly, inher decision
process, agent i is ignoring future paths of play wherein the agent will not drop out. However, player i must
not necessarily drop out at I but can still stay in if the price at I is not higher than v . In other words, agent
i
i can eventually have inconsistent plans (see also Remark 1 in [27]). Moreover, there are paths where the
agent could, beyond her planning horizon, stay in even for prices higher than v .
i
A 1-step obviously dominant strategy instead mimics the aforementioned obviously dominant strategy but
limits it to a planning horizon of two moves. So the agent would look at both p(I∗) and p(I), prices at I∗ and
I, and Stay In (Drop Out, respectively) at I′ ∈ {I∗,I} if p(I′) ≤ v (p(I′) > v , respectively). Incidentally,
i i
and differently from above, our notion leads to consistent strategies since the decision of agent i at I will
follow the same recommendation dictated by the strategy at I∗. This strategy is 1-step obviously dominant
only when the minimum payoff that can be reached by completing it in any possible way would be better than
a deviation. So, for example, if the type domain of agent i were $1, $2, $3, $4 and $5, and her type were $4
then, by following the strategy, agent i would have stayed in for prices $2 and $3 (for her first two moves).
To evaluate the 1-step obvious dominance of the strategy, agent i would then take the worst possible path of
play that her future self could take, e.g., the decision to stay in for a price of $5 leading to a payoff of −1.
The best possible payoff by deviating is 0 (e.g., dropping out immediately).
Tofurtherexploretheboundarybetweenimplementabiltyandsimplicity,westudytheextenttowhichthe
approximationguarantee of OSP deteriorates when future self moves are not fully accounted for in decision
making. We build on our first theorem to characterize what social choice functions can be implemented by
3k-step OSP mechanisms. Towards this end, we define a version of cycle monotonicity for k-step OSP; as in
the cases of SP and OSP (amongst others) cycle monotonicity is a useful tool in that it allows to separate
the allocationfunction (whose approximationguarantee we want to bound) and the paymentfunction. The
constructionofthisusefultoolkitrequiressomefurtherworktoconvenientlyrewritek-stepOSPconstraints.
We are then able to algorithmically characterize k-step OSP mechanisms, by relating the cycles of the OSP
graph [12] with those of the k-step OSP graph we define.
Main Theorem 2 (informal). There is a k-step OSP mechanism implementing social
choice function f if and only if f is two-way greedy with k-limitable priority functions.
As hinted above, the algorithmic nature of OSP for binary allocation problems can be explained in terms
of two-way greedy algorithms [13]. These are algorithms that build the eventual solution by either greedily
including agents with low cost (high valuation, respectively) — termed forward greedy algorithm — or
by greedily excluding agents that have a high cost (low valuation, respectively) — termed reverse greedy
algorithm — for minimization (maximization, respectively) problems.3 These algorithms adopt adaptive
priority functions (that is, priority functions that depend on the past choices made by the algorithm) to
definethegreedyorderinwhichagentshavetobeprocessed. TherestrictionfromOSPtok-stepOSPlimits
the class of priority functions that can adopted – it must be the case that each agent i is at the top of the
priority list for no more than k +2 times excluding the instances in which i is consecutively at the top.
These are k-limitable priority functions. Intuitively, this means that the greedy algorithm must be ready to
decide whether an agent is included or excluded from the solution in no more than k+2 steps, thus clearly
demarcating the algorithmic limitations that k-step OSP imposes.
We conclude this work by exploring the power of this class of algorithms. We focus here on p-systems,a
class of problems for which it is known that greedy algorithms can compute a solution with approximation
at most p. To what extent can this result be replicated for k-step OSP mechanisms? It turns out that the
size of the type domain of the agents and the format of the greedy algorithm play a crucial role. By letting
d denote half the size of the agents’ type domain, we obtain the following tight result (assuming here for
simplicity of exposition that the type domain has even size).
Main Theorem 3 (informal). There is a p-approximate k-limitable reverse greedy algo-
rithm for p-systems whenever k ≥d−2. There is an instance of a p-system, even for p=1
(i.e., a weighted matroid) for which no k-limitable two-way (forward, respectively) greedy
algorithm with bounded approximation for k <d−2 (k<2d−3, respectively).
We can then conclude that, in the worstcase, there is no gradualdegradationof the performances of k-step
OSP mechanisms; as the value of k decreases, there is a stark dichotomy. Essentially, the two-way greedy
algorithm needs to traverse the domain of each agent to compute good solutions when the types in the
domain are sufficiently far apart, meaning that k must be large enough. If it is conceivable to imagine that
were it possible to cluster the domain of the agents around k centres, then better results would be possible.
Interestingly,reversegreedyneedshalfthenumberofpriorityfunctionsofforwardgreedy. Itwasalready
known that forward greedy is less robust than reverse greedy to economic desiderata (such as, individual
rationality) of OSP mechanisms, due to the characterizationof OSP payments by Ferraioliand Ventre [16].
Our result further shows that reverse greedy is not only economically but also algorithmically more robust
than forwardgreedy to imperfect rationality.
2 Related Work
Since its inception [22], OSP has attracted the interest of both computer scientists and economists. Many
papers [6, 30, 29, 24] study OSP for stable matchings and provide an impossibility result in general as well
as a suitable mechanism under some assumptions. Bade and Gonczarowski [8] further study this concept
3Ingeneral,differentagents canfacedifferentdirections;inspecificcircumstances, itispossibletomovefromonedirection
totheotherevenforsingleagents,cf. Section6.
4for a number of settings, including single-peaked domains. Single-peaked preferences have been object of
further work on OSP mechanisms [4, 5]. Pycia and Troyan [26] study OSP mechanisms in domains where
monetary transfers are not allowed and provide a useful characterizationin this setting.
For the setting where money is permitted, characterizations of OSP mechanisms have been provided
by Ferraioli et al. [13] for binary allocation problems and by Ferraioli and Ventre [17] for general single-
dimensional problems. These characterizations are based on the OSP cycle-monotonicity technique intro-
duced by Ferraioli et al. [9] along with some bounds on the approximation for machine scheduling and set
system problems (see also [11, 10]).
OSP has been studied also under different restrictions on the agents’ behavior during the execution
of the mechanism. E.g., monitoring has been shown to help the design of OSP mechanisms with a good
approximationratio in various mechanism design domains [14]. Kyropoulouand Ventre [21] builds forth on
this by studying machine scheduling in the absence of monetary payments and showing the power of OSP
in this setting. Under the assumption that non-truthful behaviour can be detected and penalised with a
certainprobability,itis provedthat everysocialchoicefunction canbe implemented by anOSP mechanism
with either very large fines for lying or a large number of “verified” agents.
OSPmechanismsforsingle-mindedcombinatorialauctionsarestudiedbydeKeijzeretal. [20]. Mackenzie
[23] presents a revelation principle that states that every social choice function implementable through an
OSPmechanismcanbeimplementedusingacertainstructuredOSPprotocolwhereagentstaketurnsmaking
announcements about their valuations. We prove a similar result here. Finally, Ferraioli and Ventre [16]
provide explicit formulas for the payment functions of OSP mechanisms, giving a constructive proof to the
existentialexistenceofpaymentsguaranteedbycyclemonotonicity. Clearly,theirresultscanbeimportedto
our notion of k-step OSP and confirm, that from the economic point of view, reverse greedy is more robust
than forwardgreedy.
Several variants of OSP have been defined. k-OSP [15] is a notion that interpolates between OSP
and the classical strategyproofness (SP) for perfect rationality. The smoothing parameter k measures the
number of other agents, each can think about contingently when taking decisions. Thus, OSP corresponds
to k =0 whereas k is equal to the number of agents in the mechanismfor SP. This workproves that k-OSP
mechanisms are not much better than OSP mechanisms in approximating the makespan unless k is very
large. In a sense, this suggests that the limits imposed by imperfect rationality do not quickly evaporate
and, as long as approximation is concerned, one can focus on OSP without loss of generality.
Another related line of work concerns the notion of non-obviously manipulable (NOM) mechanisms [31]
where the absence of contingent reasoning skills is advocated to limit the misbehavior of agents as opposed
to limiting strategyproofness (as in OSP). Recent work has provided a characterization single-dimensional
domains [1, 2] and a general recipe for their design [3].
3 Preliminaries
Forthedesignofamechanism,weneedtodefineasetN ofnselfish agents andasetoffeasibleoutcomes S.
Eachagentihasatype t ∈D ,whereD isthedomain ofi. Thetype t isassumedtobe private knowledge
i i i i
of agenti. We let t (X)∈R denote the cost of agent i with type t for the outcome X ∈S. When costs are
i i
negative, it means that the agent has a profit from the solution, called valuation.
We would like to run a mechanism in order to select an outcome and assign opportune payments. I.e.,
the mechanismimplements apair (f,p),where f (termedsocial choice function or,simply, algorithm)maps
the actions taken by the agents to a feasible solution in S, and p maps the actions taken by the agents to
payments. Note that payments need not be positive. Each selfish agent i is equipped with a quasi-linear
utility function u : D ×S → R: for t ∈ D and for an outcome X ∈ S returned by a mechanism M,
i i i i
u (t ,X) is the utility that agent i has for the implementation of outcome X when her type is t , i.e.,
i i i
u (t ,X) = p −t (X). In this work we will focus on single-parameter settings, that is, the case in which
i i i i
the private informationof eachbidder i is a single realnumber t andt (X) canbe expressedas t w (X) for
i i i i
some publicly known function w .
i
5In order to implement (f,p), we design a game Γ for the agents to play. Specifically, Γ is an imperfect-
information, extensive-form game with perfect recall, defined in the standard way: H is a finite collection
of partially ordered histories (i.e., sequences of moves). At every non-terminal history h ∈ H, one agent
i∈N is called to play and has a finite set of actions A(h) from which to choose. At some history h it may
be also possible that the mechanism M plays by taking a random choice: specifically, we denote with ω(h)
the realization of the mechanism’s random choice at history h, and with ω = (ω(h)) the
h∈H:M playsath
mechanism’s random choices along the entire game. Each terminal history is associated with an outcome
X ∈S,andagentsreceiveutility u (t ,X). We usethe notationh′ ⊆h todenotethath′ isasubhistoryofh
i i
(equivalently, h is a continuation history of h′), and write h′ ⊂h when h′ ⊆h but h6=h′. When useful, we
sometimes write h = (h′,a) to denote the history h that is reached by starting at history h′ and following
the action a∈A(h).
Aninformation set I ofagentiis asetofhistoriessuchthatforanyh,h′ ∈I andanysubhistories˜h⊆h
and h˜′ ⊆ h′ at which i moves, at least one of the following conditions holds: (i) there is a history h˜∗ ⊆ h˜
such that h˜∗ and h˜′ are in the same information set, A(h˜∗)=A(h˜′), and i makes the same move at h˜∗ and
h˜′; (ii) there is a history ˜h∗ ⊆ h˜′ such that ˜h∗ and ˜h are in the same information set, A(h˜∗) = A(h˜), and i
makes the same move at h˜∗ and h˜. We denote by I(h) the information set containing history h. Roughly
speaking, an information set collects all the histories that an agent is unable to distinguish.
Astrategy foraplayeriingameΓ isafunction S thatspecifies anactionateachoneofherinformation
i
sets. When we wantto refer to the strategies of different types t of agent i, we write S (t ) for the strategy
i i i
followed by agent i of type t ; in particular, S (t )(I) denotes the action chosen by agent i with type t at
i i i i
information set I. We use S(t) = (S (t )) to denote the strategy profile for all of the agents when the
i i i∈N
type profile is t=(t ) . An extensive-form mechanism is an extensive-form game together with a profile
i i∈N
of strategies S.
Given an agent i, an information set I is an earliest point of departure between strategy S and S′ in
i i
game Γ if I is on the path of play under both S and S′ and both strategies choose the same action at all
i i
earlier information sets, but choose a different action at I. I.e., I is the earliest information set at which
these two strategies diverge. Note that for two strategies, there will in general be multiple earliest points of
departure.
Foranagentiwithpreferencet ,strategyS k-stepobviously dominates strategyS′ ingameΓif,starting
i i i
at any earliest point of departure I between S and S′, the outcome that maximize the utility of i among
i i
the ones reachable following S′ at I is weakly worse than the outcome that achieves the minimum utility
i
amongtheonesreachablebyfollowingS atI,whereworst(best,resp.) casesaredeterminedbyconsidering
i
any future play by other agents (including random choices of the mechanism) and any future play of agent
i that coincides with strategy S (S′, resp.) in all information sets I′ following I such that i plays at most
i i
k times between I (excluded) and I′ (included). In particular we simply say that S obviously dominates
i
S′ when k = ∞, and that it strongly obviously dominates S′ when k = 0. If a strategy S (k-step /
i i i
strongly) obviously dominates all other S′, then we say that S is (k-step / strongly) obviously dominant. If
i i
a mechanism implements f by guaranteeing that each player has a (k-step / strongly) obviously dominant
strategy, we say that it is (k-step / strongly) obviously strategy-proof ((k-step / S) OSP).
3.1 Round-Table Mechanisms
Mackenzie [23] proved that for OSP mechanisms, it is without loss of generality to consider mechanisms
M with a specific format, named round table mechanisms, defined as follows. M is defined by a triple
(f,p,T) where, as above, the pair (f,p) determines the outcome of the mechanism, and T is a tree, called
implementation tree, such that:
• Every leafℓ ofthe treeis labeledwith apossible outcome ofthe mechanism(X(ℓ),p(ℓ)), where X(ℓ)∈S
and p(ℓ)∈Rn;
• Each internal node u in the implementation tree T defines the following:
– An agent i = i(u) to whom the mechanism makes some query. Each possible answer to this query
leads to a different child of u.
6– A subdomain D(u) = (D (u),D (u)) containing all types profiles that are compatible with u (or
i −i
available at u), i.e., with all the answers to the queries from the root down to node u. Specifically,
the query at node u defines a partition of the current domain of i, D (u) into k ≥2 subdomains, one
i
for each of the k children of node u. Thus, the domain of each of these children will have, as for the
domainof i, the subdomain ofD (u) correspondingto a different answerof i atu, and anunchanged
i
domain for the other agents. We also say that action at u signals the associated subdomain.
Observe that, according to the definition above, for every type profile b = (b ∈ D ) there is only one
i i i∈N
leaf ℓ = ℓ(b) such that b belongs to D(ℓ). Similarly, to each leaf ℓ there is at least a profile b that belongs
to D(ℓ). This allows as to simplify the notation: indeed, we can define M(b) = (X(ℓ),p(ℓ)) for ℓ = ℓ(b).
Similarly,wecansimplywritef(b)=(f (b),...,f (b))=X(ℓ)andp(b)=(p (b),...,p (b))∈Rn =p(ℓ),
1 n 1 n
and u (t ,M(b ,b )) = p (b ,b ) −t (f(b ,b )). For the single-parameter setting, considered in this
i i i −i i i −i i i −i
work,we canfurther simplify the notation,by setting t (X)=t f (b) when we wantto expressthe costofa
i i i
single-parameter agent i of type t for the output of social choice function f when the actions taken by the
i
agent lead to the leaf ℓ associated with bid vector b.
Two type profiles b, b′ are said to diverge (or to be separated) at a node u of T if this node has two
children v,v′ such that b ∈ D(v), whereas b′ ∈ D(v′). For every such node u, we say that i(u) is the
divergent agent atu. We sometimesabusenotationandwesaythattwotypest andb ofthe agenti=i(u)
i i
diverge (are separated) at u.
A round-table mechanism M is OSP if for every agent i with real type t , for every vertex u such that
i
i=i(u),foreveryb ,b′ (withb′ notnecessarilydifferentfromb ),andforeveryb ∈D ,withb 6=t ,
−i −i −i −i i i i i
such that (t ,b ) and (b ,b′ ) are compatible with u, but diverge at u, it holds that u (t ,M(t ,b )) ≥
i −i i −i i i i −i
u (t ,M(b ,b′ )).Roughlyspeaking,OSPrequiresthat,ateachtimestepagentiisaskedtotakeadecision
i i i −i
that depends on her type, the worst utility that she can get if she henceforth behaves according to her true
type is at least the best utility she can get by behaving differently.
We will extend this definition as follows. Let us first start with some useful definition. For each agent i,
andforeachvertexuinthe implementationtreeT suchthati=i(u),andeveryu′ alongthepathfromuto
aleaf,wesaythatu′ belongstothek-steplimit L (u)ofuifu′ isthek-thnodealongthispath(uexcluded)
k
in which i is queried or,if i is queriedin less than k nodes alongthis path, then u′ is the leaf. Moreover,for
eachagenti, andfor eachvertex u in the implementation tree T suchthat i=i(u), the k-step neighborhood
N (u) of u consists of each node of T that appears in the path between u and some u′ ∈ L (u). Then, for
k k
each agent i and for each vertex u in the implementation tree T such that i = i(u), two (not necessarily
different) profiles a and b are said to be k-step unseparated at u if a and b do not diverge either at u or in
every node in the k-step neighborhood of u. Finally, for each agent i and profile a, and for each vertex u in
the implementation tree T such that i= i(u) and a is available at u, the k-step equivalence class of a at u
is Γk(a)={b: b is k-step unseparated from a at u}.
u
Then, a round-table mechanism M is k-step OSP if for every agent i with real type t , for every vertex
i
u such that i = i(u), for every b ,b′ ,b′′ (with b′ ,b′′ not necessarily different from b and different
−i −i −i −i −i −i
from each other), and for every b ,b′ ∈ D such that (t ,b ),(b ,b′ ) ∈ Γk(t ,b ), while (t ,b ) and
i i i i −i i −i u i −i i −i
(b′,b′′ ) diverge at u, it holds that u (t ,M(b ,b′ )) ≥ u (t ,M(b′,b′′ )). Roughly speaking, k-step OSP
i −i i i i −i i i i −i
requiresthat,ateachtimestepagentiisaskedtotakeadecisionthatdependsonhertype,theworstutility
that she can get if she now behaves according to her true type is at least the best utility she can get by
behaving differently, even if she later (i.e., after the next k queries received by the mechanism) changes her
mind and plays as if her type was an untruthful but still available one. As above, it is immediate to check
that k-step OSPness reduces to OSPness when k = ∞, and has been dubbed strong OSPness for k = 0 by
Pycia and Troyan[27].
Mackenzie [23] proved that if there is an OSP mechanism implementing a social choice function f, then
this can be also implemented by an OSP round-table mechanism. We next show that this claim holds also
for k-step OSP.
Theorem 1. There is a k-step OSP mechanism implementing a social choice f if and only if f can be also
implemented by a k-step OSP round-table mechanism.
Theproofisessentiallythe sameprovidedbyMackenzie[23]forOSP,andhenceweomitithereaformal
7argument, and only provide the main ideas.
Proof Sketch. ConsiderageneralmechanismM. IfMisrandomized,thenfixarealizationω oftherandom
choicesofthemechanism,andconsideronlythesetofhistoriesofMthatarecompatiblewiththisrealization
(this is what is denoted as ω-derandomization operation [23]). Clearly, if the mechanism M is k-step OSP
withrespectthefullsetofhistories,itwillremaink-stepOSPalsowithrespecttothereducedsetofhistories.
In other words, we are claiming that the randomized mechanism is k-step OSP if and only if each possible
random realization of the mechanism must be k-step OSP.
Let us thus assume that M is a deterministic k-step OSP mechanism. Suppose that at an history h the
chosen player has only one available action. Clearly, we can safely remove this history without affecting the
k-step OSPness of both this agent and remaining agents. Suppose that the mechanism M also allows the
agent to be absent-minded, that is, to have two histories, one following the other, that belong to the same
information set, representing in this way an agent that forgets to have played before. Hence, every possible
actionofotherplayersoccurringbetweenthetwohistoriesisnotrelevantfortheconsideredagent,while the
action taken by this player must be the same at both histories. Hence, we can merge these two histories,
without affecting neither the k-step OSPness of the current agent, nor the k-step OSPness of remaining
agents (this corresponds to the untangling operation [23]).
Hence, we can assume that the mechanism is deterministic, and no agent is absent-minded. In other
words, they have perfect information about the mechanism, and their own previous actions. Still, it is
possible that the agents do not have perfect information about the actions taken by other agents, and
different histories corresponding to different actions taken by agent j are in the same information set of
agenti. Observethat, in this case,the worstoutcomethat i may play by taking a givenactionis not better
than the worst that she can receive by taking this action when she knows about the action of j. Similarly,
incomplete information cannot improve the best outcome that i can receive. Hence, if the mechanism is
k-step OSP with incomplete information, it must be k-step OSP also with complete information. And thus
we can assume that each information set corresponds of a single history (this is the illumination operation
[23]).
To conclude, since the mechanism M is deterministic and the players have complete information, it is
sufficienttosimply prune thatactionsthatwillnotbe playedbyanystrategy[22],andrename actionswith
type subdomains for having a k-step OSP round-table mechanism, as desired.
Due to Theorem 1, we will henceforth focus only on round-table mechanisms, and we will refer to them
simply as mechanisms.
4 Characterizing the Implementation Tree
Inthis sectionweproveourfirstmainresultandcharacterizek-stepOSPmechanismsinterms ofextensive-
form games where each agent is called to act at most k+2 times, with the limitations discussed above on
thelasttimesheplays. Wenotethatthe resultsinSection4.1holdforeachoutcomespacewhilstinSection
4.2 we restrict to binary outcomes.
4.1 Almost-Ordered Mechanisms
A mechanism M implementing social function f with implementation tree T is said to be almost-ordered,
if for every agent i, every node u of T such that i = i(u), and every pair of profiles a and b separated
at u such that f (a) > f (b) we have that c < d where c = max{x | ∃x : (x ,x ) ∈ Γk(a)} and
i i i i i i −i i −i u
d =min{x |∃x : (x ,x )∈Γk(b)}. RoughlyspeakingamechanismisalmostorderedifforeverypairL
i i −i i −i u
and R of the subsets in which D (u) is partitioned at u, either the mechanism assigns the same outcome to
i
all types in L∪R or these two sets are ordered (i.e., the types in one of these two sets are all smaller than
the types in the other set).
Wenextprovethateveryk-stepOSPmechanismmustbealmostordered. Letusfirststatethefollowing
useful lemma.
8Lemma 1. An extensive-form mechanism M=(f,p) with implementation tree T is k-step OSP if and only
if for all i, all vertices u of T such that i = i(u), and every pair of profiles a and b separated at u, the
following holds for all (c ,c )∈Γk(a):
i −i u
p (b ,b )−p (a ,a )≤c (f (b ,b )−f (a ,a )). (1)
i i −i i i −i i i i −i i i −i
Proof. By definition,a mechanismM withimplementationtree T is ak-stepOSPmechanismfor the social
choice function f if and only if there exists a payment function p such that M=(f,p) and, for every agent
i with real type t , and for every vertex u such that i=i(u), it holds that
i
p (b ,b′ )−t f (b ,b′ )=u (t ,M(b ,b′ ))≥u (t ,M(b′,b′′ ))=p (b′,b′′ )−t f (b′,b′′ )
i i −i i i i −i i i i −i i i i −i i i −i i i i −i
foreveryb ,b′ ,b′′ andforeveryb ,b′ ∈D ,withb′ 6=t ,suchthat(t ,b ),(b ,b′ )∈Γk(t ,b ),while
−i −i −i i i i i i i −i i −i u i −i
(t ,b ) and (b′,b′′ ) are compatible with u, but diverge at u. Since the true type of i can be any value in
i −i i −i
D , then the mechanism is k-step OSP if and only if this is true for any pair a ,b ∈D (u).
i i i i
Henceforth, we will refer to condition (1) as k-step OSP constraint.
Theorem 2. A k-step OSP mechanism M implementing social function f with implementation tree T is
almost-ordered.
Proof. Suppose that M is not almost-ordered, and let i and u be respectively the agent and the node of T
such that i=i(u) and there are a and b with f (a) >f (b) separated at u such that c >d , where c and
i i i i i
d are as defined above. Since a and b are separated at u, and there are, by definition of c and d , c and
i i i −i
d such that (c ,c )∈Γk(a) and (d ,d )∈Γk(b), then both the following k-step OSP constraints must
−i i −i u i −i u
be satisfied:
p (b ,b )−p (a ,a )≤c (f (b ,b )−f (a ,a ))
i i −i i i −i i i i −i i i −i
p (a ,a )−p (b ,b )≤d (f (a ,a )−f (b ,b )).
i i −i i i −i i i i −i i i −i
This leads to c ≤d , that contradicts our hypothesis.
i i
4.2 k-Limited Mechanisms for Binary Outcomes
We henceforth focus on settings with binary outcomes, i.e., S ={0,1}n.
Letus consideramechanismM implementing (f,p)withimplementationtreeT. We nextprovidesome
useful definitions. We begin with certain subsets of type domains.
Definition 1 (Suffix/Prefix of Type Domains). Given a node u ∈ T and agent i = i(u) we say that the
domain D (u) is prefix if max{t∈D (u)}<min{t∈D \D (u)}, i.e., it only contains the smaller types in
i i i i
the domain of u (with larger types already removed in the queries preceding u). Similarly, we say that D (u)
i
is suffix if min{t∈D (u)}>max{t∈D \D (u)}.
i i i
We now move to queries of particular interest.
Definition 2 (Revelation, Extremal and (In)Effective Queries). Given a node u∈T and a type t∈D (u),
i
i=i(u), we say that the query at this node is a(n)
Revelation query if agent i is asked to reveal her type.
Extremal query if agent i is asked to separate one extreme (i.e., the minimum or maximum type) from
the rest of her current domain D (u).
i
Ineffective query if for every x available at u, and every t′,t′′ ∈ D (u), f (t′,x ) = f (t′′,x ) and
−i i i −i i −i
p (t′,x ) =p (t′′,x ). In words, regardless of how types are partitioned by this query, i receives the
i −i i −i
same outcome and payment for every given profile of other agents’ actions.
9Strongly Ineffective query if for every x ,x′ available at u and every t′,t′′ ∈ D (u), we have that
−i −i i
f (t′,x ) = f (t′′,x′ ) and p (t′,x ) = p (t′′,x′ ). In words, a strongly ineffective query is one for
i −i i −i i −i i −i
which agent i receives the same outcome and payment for each possible profile available at that history.
Only-t effective query if for each x available at u and every t′,t′′ ∈D (u) with t′,t′′ 6=t, f (t′,x )=
−i i i −i
f (t′′,x )andp (t′,x )=p (t′′,x ),andthereisy available atusuchthatf (t,y )6=f (t′,y ).
i −i i −i i −i −i i −i i −i
In words, for each profile of other agents’ actions, the outcome and payment received by i is the same
except for the type t.
Strongly only-t effective query if for each x ,x′ available at u and every t′,t′′ ∈ D (u) such that
−i −i i
t′,t′′ 6= t, f (t′,x ) = f (t′′,x′ ) and p (t′,x ) = p (t′′,x′ ), and there is y available at u such
i −i i −i i −i i −i −i
that f (t,y ) 6= f (t′,y ). That is, i receives exactly the same outcome and payment in each profile
i −i i −i
available at u, except for the ones in which she has type t.
In our context, we will concentrate on (strongly) only-maximum (minimum, respectively) effective queries,
that is, the (strongly) only-t queries for which t=max{t∈D (u)} (t=min{t∈D (u)}, respectively).
i i
We will next show that if M is k-step OSP, then it is without loss of generality, to assume that T has
the following special structure.
Definition 3 (k-limited mechanism). A mechanism M implemented by a tree T is a k-limited mechanism
for each agent i, and for every path P from the root of T to a leaf, one of the following properties holds:
• i is queried at most k+1 times along P;
• iis queried at most k+2 times along P andat thenode u corresponding tothe (k+2)-thquerywe have
that: (i) either |D (u)| = 2 or D (u) is prefix; and (ii) the query at u is either a strongly ineffective
i i
revelation query, or a strongly only-maximum effective revelation query or it is an only-maximum
effective extremal query that separates the maximum type in D (u) from the rest of the domain;
i
• i is queried at most k+2 times along P and at the node u corresponding to the (k+2)-th query we
have that: (i) D (u) is suffix; and (ii) the query at u is either a strongly ineffective revelation query,
i
a strongly only-minimum effective revelation query or it is an only-minimum effective extremal query
that separates the minimum type in D (u) from the rest of the domain.
i
We then have the following theorem.
Theorem 3. If there is a k-step OSP mechanism M that implements (f,p) with implementation tree T,
then there is a k-limited k-step OSP mechanism M′ implementing (f,p).
The rest of this section proves Theorem 3. To this aim, we first prove some preliminary properties of a
k-step OSP mechanism M, which amount to a version of the taxation principle for k-step OSP.
Lemma 2 (Taxation Principle for k-step OSP). Let M be a k-step OSP mechanism that implements (f,p)
with implementation tree T. For all i and for each vertex u in T such that i= i(u), take any three profiles
a= (a ,a ), c=(c ,a ), and d =(d ,a ) such that (i) a <c <d , (ii) a,c,d ∈Γk(a), and (iii) there
i −i i −i i −i i i i u
is u′ ∈/ N (u) such that i = i(u′), a,c, and d are available at u′, and two among a, c, and d are separated
k
at u′. We have that:
1. if there are b and b′ separated from a,c,d by i along the path from u to u′ such that b > d and
i i
b′ <a , then f (a)=f (c)=f (d) and p (a)=p (c)=p (d) (Outer-sandwich separations);
i i i i i i i i
2. if there is b separated from a,c,d by i along the path from u to u′ such that a < b < d , then
i i i
f (a)=f (c)=f (d) and p (a)=p (c)=p (d) (Inner-sandwich separation);
i i i i i i
3. if there is b separated from a,c,d by i along the path from u to u′ such that b >d then f (a)=f (c)
i i i i
and p (a)=p (c) (Top separation);
i i
4. if there is b separated from a,c,d by i along the path from u to u′ such that b <a then f (c)=f (d)
i i i i
and p (c)=p (d) (Bottom separation).
i i
Proof. We start by rewriting the k-step OSP constraint (1) for mechanism M and agent i with real type
t . For every profile (t ,t ), for every vertex u such that i = i(u) and (t ,t ) is available at u, and every
i i −i i −i
t′ ∈Γk(t ,t ), it holds that
u i −i
p (b)−p (t′)≤t (f (b)−f (t′)) (2)
i i i i i
10for every b available at u that diverges from (t ,t ) at u. Hence, by taking t = a , if t = a , then we
i −i −i −i i i
have that
p (b)−p (a)≤a (f (b)−f (a)) if t′ =a;
i i i i i
p (b)−p (c)≤a (f (b)−f (c)) if t′ =c; (3)
 i i i i i
p i(b)−p i(d)≤a i(f i(b)−f i(d)) if t′ =d;
while if t
i
=c i, then we have that
p (b)−p (a)≤c (f (b)−f (a)) if t′ =a;
i i i i i
p (b)−p (c)≤c (f (b)−f (c)) if t′ =c; (4)
 i i i i i
p i(b)−p i(d)≤c i(f i(b)−f i(d)) if t′ =d;
and if t
i
=d i, then we have that
p (b)−p (a)≤d (f (b)−f (a)) if t′ =a;
i i i i i
p (b)−p (c)≤d (f (b)−f (c)) if t′ =c; (5)
 i i i i i
p i(b)−p i(d)≤d i(f i(b)−f i(d)) if t′ =d.
By taking instead t =b , t =b , t′ =b, we have
i i −i −i
p (a)−p (b)≤b (f (a)−f (b));
i i i i i
p (c)−p (b)≤b (f (c)−f (b)); (6)
 i i i i i
p i(d)−p i(b)≤b i(f i(d)−f i(b)).
We distinguish three cases based onthe relation between b i, a i, and d i.
Case 1 (b >d ). Then from (3)–(6) we achieve that f (b)≤min{f (a),f (c),f (d)} and (5) and (6) yield
i i i i i i
L =d (f (a)−f (b))≤p (a)−p (b)≤b (f (a)−f (b))=U ; (7)
1 i i i i i i i i 1
d (f (c)−f (b))≤p (c)−p (b)≤b (f (c)−f (b)). (8)
i i i i i i i i
Clearly, if a and c are never separated by i, then f (a) = f (c). Suppose instead that there is a node
i i
u′′ ∈/ N (u) (not necessarily the same as u′ defined in the statement) such that a and c are separated
k
at u′′ and f (a) 6= f (c). Since a and c only differ in the type of agent i, then i(u′′) = i. Then, by
i i
applying (2) with t =a , t =a , t′ =a and b=c, we have
−i −i i i
p (c)−p (a)≤a (f (c)−f (a)).
i i i i i
Similarly, by applying (2) with t =a , t =c , t′ =c and b=a, we have
−i −i i i
p (a)−p (c)≤c (f (a)−f (c)).
i i i i i
Hence, since a <c , we achieve that f (a)>f (c) and thus
i i i i
a (f (a)−f (c))≤p (a)−p (c)≤c (f (a)−f (c)). (9)
i i i i i i i i
Inordertosatisfy(8),weneedthatp (c)=p (b)+x (f (c)−f (b))forsomex ∈[d ,b ]. Byreplacing
i i i i i i i i
this value in (9), we then have that
L =a (f (a)−f (c))+x (f (c)−f (b))≤p (a)−p (b)≤c (f (a)−f (c))+x (f (c)−f (b))=U . (10)
2 i i i i i i i i i i i i i i 2
Hence, in order to have that both (7) and (10) are satisfied, we need that U ≥ L . That is, we need
2 1
that
d (f (a)−f (b))=d (f (a)−f (c))+d (f (c)−f (b))≤c (f (a)−f (c))+x (f (c)−f (b)).
i i i i i i i i i i i i i i i
11Rearranging,we get
(d −c )(f (a)−f (c))≤(x −d )(f (c)−f (b)). (11)
i i i i i i i i
Since d >c and f (a) > f (c), then the l.h.s. of (11) is larger than 0. Moreover, since outcomes are
i i i i
binary,it must be the case that f (a)=1 and f (c)=0,and thus, since f (b)≤f (c), it must be that
i i i i
f (b) = f (c) = 0 meaning that the r.h.s. of (11) is 0. Hence, (11) cannot be satisfied, and thus it
i i
cannot be that f (a)6=f (c).
i i
Case 2 (b <a ). This case is symmetric with respect to the previous one, and it can be similarly proved
i i
by simply inverting the roles of a and d.
Case 3 (a <b <d ). Then we have that the query at u is not ordered. Since M is k-step OSP, then by
i i i
Theorem2,itmustbealmost-ordered,andthusitmustbethecasethatf (b)=f (a)=f (c)=f (d),
i i i i
as desired.
The arguments above imply that the outcomes are the same for every profile in Γk(a). The fact that also
u
paymentsarethe sameimmediatelyfollows,sinceeitherthetwoprofilesareneverseparatedbyi(andhence
they receive the same outcome and the same payment) or they are separated by i, and hence they need to
receive the same payment otherwise the mechanism fails to be even simply strategyproof.
To conclude the proof, we simply observe that when outer-sandwich separations occur then Case 1 and
2 hold simultaneously; inner-sandwich separation corresponds to Case 3 whilst top (bottom, respectively)
separation corresponds to Case 1 (2, respectively).
We say that a mechanism M with implementation tree T is almost k-limited if T is such that for each
agent i and every path P from the root of T to a leaf, the following conditions are satisfied:
• foru∈P correspondingto the (k+2)-thqueryto i,if we denote with a andd the minimum andthe
i i
maximum of the types of i available at u respectively, we must have that
– if the domain D (u) of i at u contains at least three types and it is neither prefix nor suffix (i.e.,
i
in the previous k+1 queries to i, either i separated from D (u) types b and b′ such that b >d
i i i i i
and b′ <a , or i separated from D (u) type b such that a <b <d ), then the (k+2)-th query
i i i i i i i
is ineffective;
– ifD (u)containsatmosttwotypesoritisprefix(i.e.,inthepreviousk+1queriestoi,iseparated
i
from D (u) only types b such that b >d ), then the (k+2)-th query is either ineffective or it is
i i i i
only-maximum effective;
– if D (u) contains at least three types and it is suffix (i.e., in the previous k+1 queries to i, i
i
separated from the domain only types b such that b < a ), then the (k+2)-th query is either
i i i
ineffective or it is only-minimum effective.
• every u∈P corresponding to the q-th query to i with q ≥k+3 are ineffective.
Considering the first query along a path P, Lemma 2 restricts the (k + 2)-th query on P as in the
first bullet point (the three cases corresponding to sandwich, top, and bottom separations, respectively).
Moreover, given these properties, it is not hard to see that the subsequent queries must be ineffective (as
requested by the second condition of almost k-limited mechanisms). Thus, Lemma 2 can be restated as
follows.
Corollary 1. If a mechanism M that implements (f,p) with implementation tree T is k-step OSP, then T
is almost k-limited.
Wenowaregoingtoprovefurtherlimits totheeffectivenessofthe (k+2)-thqueryandsubsequentones,
by showing thatif a queryis ineffective for a pair ofseparatedtypes then it is in fact stronglyineffective for
those types.
Lemma 3 (Strong Ineffectiveness upon Separation). If a mechanism M that implements (f,p) with im-
plementation tree T is k-step OSP, then for every i, and every path P of T, every node u ∈ P such that
i(u)=i, if there are t,t′ ∈D (u) such that for every x available at u we have that f (t,x )=f (t′,x ),
i −i i −i i −i
and t,t′ are separated at u, then for every x ,x′ available at u we have that f (t,x ) = f (t′,x′ ) and
−i −i i −i i −i
p (t,x )=p (t′,x′ ).
i −i i −i
12Proof. Suppose that the claim does not hold, and there are y=(t,y ) and y′ =(t′,y′ ) for some y and
−i −i −i
y′ available at node u, such that f (t,y )6=f (t′,y′ ).
−i i −i i −i
Consider then the profiles z=(t,y′ ) and z′ =(t′,y ). Since y and y′ are available at node u, and
−i −i −i −i
t,t′ are separated at u, then it must be the case that z and z′ also are separated at u by i. Moreover, by
hypothesis, f (z) =f (y′) and f (z′)=f (y). Since the mechanism is k-step OSP, then it must be the case
i i i i
that all the following k-step OSP constraints4 are satisfied:
p (y′)−p (y)≤t(f (y′)−f (y)); (12)
i i i i
p (y)−p (y′)≤t′(f (y)−f (y′)); (13)
i i i i
p (z′)−p (z)≤t(f (z′)−f (z)); (14)
i i i i
p (z)−p (z′)≤t′(f (z)−f (z′)). (15)
i i i i
Suppose that t < t′ (the case t > t′ is symmetric and omitted). If f (y) < f (y′), then it follows that (12)
i i
and (13) cannot be both satisfied; if instead f (y)>f (y′), then (14) and (15) cannot be both satisfied.
i i
The equality of payments directly follows from the outcomes being the same, and the profiles being
separated.
Lemma 3 thus states that if in some path P of T the (k+2)-th query to i is ineffective, then it must
be strongly ineffective. Similarly, if in some path P of T the (k+2)-th query to i is only-maximum (only-
minimum, resp.) effective, and the types of i different from the maximum (minimum, resp.) are separated
at the (k+2)-th query or successive, then the (k+2)-th query is strongly only-maximum (only-minimum,
resp.) effective. In order to stress that in T this property must be satisfied, we say that the corresponding
mechanism is strongly almost k-limited.
Lemma 2 and Lemma 3 allow to conclude that a k-step OSP mechanism must be strongly almost k-
limited. However, in such a mechanism we are still allowed to query agent i more than k+2 times, or to
have a (k+2)-th query that is neither a revelation nor an extremal query. We next show how to transform
T in order to achieve the desired reduction to a k-limited mechanism.
Lemma 4 (Revealingatthe (k+2)-thquery/1). Let M be a k-step OSP mechanism that implements (f,p)
with implementation tree T, and consider a path P of T such that along P agent i is queried at least k+2
times, and the (k +2)-th query is strongly ineffective. Then, there is a k-step OSP mechanism M′ that
implements (f,p) with an implementation tree T′ such that along path P, agent i is queried exactly k+2
times and the (k+2)-th query is a strongly ineffective revelation query.
Proof. Let u be the node of P corresponding to the (k+2)-th query to i along P, and for each child v of u,
let T be the subtree of T rooted at v. We define the implementation tree T′ obtained from T by replacing
v
each child v of u with nodes v for each type t ∈ D (v), each of them rooting a copy of T (pruned of the
t i v
redundant queries to i for types t′ 6=t).
It is immediate to check that the mechanism M′ implemented by T′ implements (f,p), and, along P,
agent i is queried k+2 times, with the (k+2)-th query being a strongly ineffective revelation query. We
next show that M′ is k-step OSP. To this aim, we need to prove that all the k-step OSP constraints are
satisfied. As for those constraintsdefined by nodes u′ suchthat i(u′)6=i, it is immediate to check that they
aretriviallysatisfied, since they aresatisfiedalsointhe originalmechanismandno new separationhas been
introduced for i(u′).
Similarly, the validity of all constraints about profiles that have been separated in T′ by i at a node
different from u is inherited from the original mechanism. It is only left to check that the constraints
introduced at node u are satisfied. Since the new queries at u in T′ are for singletons, then the new
constraints require that for every child v of u in T such that |D (v)|≥2, every t,t′ ∈D (v), and every x
i i −i
and y available at u, it holds that
−i
p (t,x )−p (t′,y )≤t′(f (t,x )−f (t′,y )) (16)
i −i i −i i −i i −i
p (t′,y )−p (t,x )≤t(f (t′,y )−f (t,x )) (17)
i −i i −i i −i i −i
4TheseareactuallyOSPconstraints, meaningthatthelemmaholdstrueforthestrongestk-stepOSPnotion.
13However, since the query at u is strongly ineffective, then it must be the case that f (t,x ) = f (t′,y )
i −i i −i
and p (t,x )=p (t′,y ), and thus these constraints are clearly satisfied.
i −i i −i
Lemma 5 (Revealingatthe (k+2)-thquery/2). Let M be a k-step OSP mechanism that implements (f,p)
with implementation tree T, and consider a path P of T such that along P agent i is queried at least k+2
times, and the (k+2)-th query is strongly only-maximum (only-minimum) effective. Then, there is a k-step
OSP mechanism M′ that implements (f,p) with an implementation tree T′ such that along path P, agent i
is queried exactly k+2 times and the (k+2)-th query is a strongly only-maximum (only-minimum, resp.)
revelation query.
Proof. ThetransformationandtheproofareexactlythesameasforLemma4,exceptthatweneedtocheck
thatthe constraints(16) and(17)aresatisfiedevenift′ =max{t∈D (u)} (t′ =min{t∈D (u)}, resp.) and
i i
f (t′,y )6=f (t,x ).
i −i i −i
However,since the query at u is strongly only-maximal(only-minimal, resp.) effective, then f (t,y )=
i −i
f (t,x ) 6= f (t′,y ). However, since (t,y ) and (t′,y ) differ only in the type of i, and they have a
i −i i −i −i −i
differentoutcome,then they mustbe separatedby i. Since M is k-stepOSP, then the followingk-stepOSP
constraints hold:
p (t,y )−p (t′,y )≤t′(f (t,y )−f (t′,y )); (18)
i −i i −i i −i i −i
p (t′,y )−p (t,y )≤t(f (t′,y )−f (t,y )). (19)
i −i i −i i −i i −i
However, since the query at u is strongly only maximal (only-minimal, resp.), then p (t,x ) = p (t,y )
i −i i −i
and f (t,x )=f (t,y ). Then (16) and (17) follow from (18) and (19), respectively.
i −i i −i
Theorem 3 then follows from the repeated applications of transformations described in Lemma 4 and
Lemma 5, since for each remaining path P it must be the case that either agent i is queried at most k+1
times, or it is queried k+2 times, with the (k+2)-th query either being a revelation or an extremal query.
5 Cycle-Monotonicity for k-step OSP
We will nextshowthatk-stepOSP-nesscanbe statedinterms ofsuitable weightedgraphsandtheir cycles.
5.1 Definition of Cycle-Monotonicity
For each agent i, for each path P from the root of T to a node u corresponding to the (k +2)-th query
to i, if it exists, or to a leaf otherwise, we partition the domain D of types of i in classes D1 ,...,Dℓ ,
i i,P i,P
where ℓ=min{k+2,q+1}, q denoting the number of queries to i along this path; Dj , for j <ℓ contains
i,P
all types of i available at the j-th query at i, but not available at the (j +1)-th query to i along P, and
Dℓ =D \ ℓ−1Dj .
i,P i j=1 i,P
Supposethat,alongthepathP,iisqueriedatleastk+2times,andletubethenodecorrespondingtothe
S
(k+2)-thqueryati. LetDk+2,E be amaximalsetoftypesofiavailableatuthatreceivethe sameoutcome
i,P
foreachpossiblefixedprofileofthe remainingagentsavailableatu,i.e., Dk+2,E ⊆Dk+2 suchthatforevery
i,P i,P
t,t′ ∈Dk+2,E andeveryx availableatuwehavethatf (t,x )=f(t′,x ),andforeveryt∈Dk+2,E and
i,P −i i −i −i i,P
every t′′ ∈Dk+2,E =Dk+2\Dk+2,E there is y available at u for which f (t,y )6=f (t′′,y ). Note that
i,P i,P i,P −i i −i i −i
if the (k+2)-th query is (strongly) ineffective, we have that Dk+2,E = Dk+2. Moreover, if the (k+2)-th
i,P i,P
query is (strongly) only-maximum or only-minimum effective, then Dk+2,E contains only the one extremal
i,P
type for which the (k+2)-th query is effective.
Given this partition of the type domain of agent i, we then partition the profiles in equivalence classes
as follows: for each agent i, for each path P from the root of T to a node u corresponding to the (k+2)-th
14query to i, if it exists, or to a leaf otherwise, we define the equivalence classes
Λj (0)={(x ,x )|x ∈Dj ,x available at u,f (x ,x )=0} (20)
i,P i −i i i,P −i i i −i
Λj (1)={(x ,x )|x ∈Dj ,x available at u,f (x ,x )=1}, (21)
i,P i −i i i,P −i i i −i
for j = q+1 if in P agent i is queried at most q ≤ k+1 times, and j ∈ {(k+2,E),(k+2,E)} otherwise.
Let Λ be the set that contains all the equivalence classes defined for agent i. Moreover, we abuse notation
i
andwe setf (Λj (0))=0 andf (Λj (1))=1. We arenow ready to define the graphsofinterestfor k-step
i i,P i i,P
OSP.
Definition 4. (k-step OSP-graph) Let f be a social choice function and T be an implementation tree. We
define for every agent i, the k-step OSP-graph O ik
,f,T
with Λi as the set of vertices, and an edge e between
Λ,Λ′ ∈ Λi exists if there are x ∈ Λ and x′ ∈ Λ′ such that x and x′ have been separated in T by i. We set
w(e)=min xi|∃x−i:(xi,x−i)∈Λx i(f i(Λ′)−f i(Λ)).
We say that the k-step OSP cycle monotonicity (k-step OSP CMON) property holds if, for all i, the
graph Ok does not have negative weight cycles.
i,f,T
5.2 Proving k-step OSP CMON
Webeginbyobservingthatifthemechanismisk-limited,theequivalenceclasses(20)canbeusedforredefine
some of the k-step OSP constraints given in (1) as follows. Towards this end, we define the function λ−1
i
that on input a profile x returns the equivalence class Λ∈Λ to which x belongs.
i
Lemma 6 (Rewriting the k-Step OSP Constraints). If a k-limited mechanism M with implementation tree
T is k-step OSP, then for all i, all vertices u of T such that i = i(u), and every pair of profiles a and b
separated at u such that λ−1(a)6=λ−1(b), the following holds:
p (b)−p (a)≤ min c(f (b)−f (a)). (22)
i i i i
c|∃c−i:(c,c−i)∈λ− i1(a)
Proof. LetP˜ bethe pathfromthe rootofT tothe leafℓcorrespondingtoprofilea. Assume firstthatagent
i has been queried q ≤ k+1 times in P˜. This implies that λ−1(a) = Λq+1(a) and that Γk(a) contains all
i i,P˜ u
profiles available at ℓ. In turns, (t,a ) ∈ Γk(a) f or every t ∈ Dq+1, and no profile x such that x ∈/ Dq+1
−i u i,P˜ i i,P˜
is in Γk(a) since x has been separated from a in one of the q queries to i. Note that f (t,a ) = f (a)
u i i i −i i
for every t ∈ Dq+1, since these profiles are never separated by any agent. Observe, moreover, that Λq+1(a)
i,P˜ i,P˜
contains all profiles available at ℓ with outcome f (a). Hence, as discussed above, it must contain at least
i
(t,a ) for every t∈Dq+1. Hence, from Lemma 1, we have that
−i i,P˜
p (b)−p (a)≤ min c(f (b)−f (a))
i i i i
c|∃c−i:(c,c−i)∈Γk u(a)
= min c(f (b)−f (a))
i i
c∈Dq+1
i,P˜
= min c(f (b)−f (a)).
i i
c|∃c−i:(c,c−i)∈λ−1(a)
Consider now the case in which agent i is queried at least k+2 times P˜. Let P denote the subpath of
P˜ containing all the nodes from the root to the node v in which i receives the (k+2)-th query. Note that
a ∈Dk+2. Supposethatf (b)≥f (a)(theproofforf (b)<f (a)issymmetricandhenceomitted). Hence,
i i,P i i i i
theminimuminther.h.s. of (22)isachievedincorrespondenceofc∗ =min{c|∃c : c=(c,c )∈λ−1(a)}.
−i −i i
We next show that since M is k-limited then c∗ = (c∗,a ) also belongs to λ−1(a). Since, for some
−i i
c , (c∗,c )∈λ−1(a), then (i) f (c∗,c )=f (a) and (ii) c∗ has not been separated by a within the first
−i −i i i −i i i
k+1 queries to i. Thus, we have that c∗ ∈Dk+2. Since M is k-limited, then the (k+2)-th query is either
i,P
15strongly ineffective, and thus a ,c∗ ∈ Dk+2,E, or (strongly) only-maximum or only-minimum effective, and
i i,P
thus Dk+2,E is a singleton, and hence either c∗ = a ∈ Dk+2,E or a ,c∗ ∈ Dk+2,E. The claim then follows
i,P i i,P i i,P
since a is available at node v (since it is still available at the leaf ℓ in the subtree rooted at v).
−i
We now argue that b does not belong to the same partition of a and c∗ at the history in which the
i i
(k+2)-th query is performed. Since the mechanism is k-limited and λ−1(a)6=λ−1(b), then either a and b
havebeenseparatedby i inthe firstk+1queries(i.e., b 6∈Dk+2)orthey havebeen separatedinone ofthe
i i,P
following queries to i, and either a =c∗ ∈Dk+2,E and b ∈Dk+2,E, or a ,c∗ ∈Dk+2,E and b ∈Dk+2,E.
i i,P i i,P i i,P i i,P
Thus,since the mechanismis k-limited, theninallcaseswe havethatc∗ andb alsohavebeenseparated
at the same node u′ in which a and b have been separated. Hence, we have the following k-step OSP
constraints corresponding to c∗ and b:
p (b)−p (c∗)≤ min c(f (b)−f (c∗)). (23)
i i i i
c|∃c−i:(c,c−i)∈Γk u′(c∗)
However,since the mechanismis k-limited andc∗ ∈λ−1(a), we havethat f (a)=f (c∗) andp (a)=p (c∗).
i i i i
Hence, (23) can be rewritten as follows:
p (b)−p (a)≤ min c(f (b)−f (a)). (24)
i i i i
c|∃c−i:(c,c−i)∈Γk u′(c∗)
As above, the minimum in the r.h.s. of (24) is achieved for c′ = min{c | ∃c : (c,c ) ∈ Γk (c∗)}. Since
−i −i u′
c∗ ∈Γk (c∗), then either c′ =c∗ or c′ <c∗ implying (22).
u′
Secondly,wenotethatthek-stepOSP-graphsofk-limitedmechanismsenjoythefollowingusefulproperty.
Lemma 7 (Sticky Edges). Suppose that Ok is the k-step OSP-graph of a k-limited mechanism and there
i,f,T
is an edge (Λ,Λ′) in Ok , then for every x ∈ Λ, and every x′ ∈ Λ′, we have that x and x′ have been
i,f,T
separated by i at the same node in T.
Proof. Since the edge(Λ,Λ′)existsinOk ,thenthere mustbe y∈Λandy′ ∈Λ′ suchthaty andy′ have
i,f,T
been separated at some node u by i.
Note that for every x∈Λ and x′ ∈Λ′, it is impossible that both x ∈Dk+2,E and x′ ∈Dk+2,E, since in
i i,P i i,P
a k-limited mechanism if these two profiles had been separated by i at the (k+2)-th query, then this must
be either strongly ineffective or (strongly) only-maximum or only-minimum effective. However, in all these
cases f (x)=f (x′), and thus x and x′ cannot belong to different equivalence classes.
i i
Hence,sincethemechanismisk-limited,theneitheruisoneofthefirstk+1nodesinwhichiisqueried,
oritisa(strongly)only-maximum(only-minimum,resp.) effective(k+2)-thqueryandthelargest(smallest,
resp.) among y and y′ belongs to Dk+2,E, while the other is in Dk+2,E.
i i i,P i,P
Moreover, by definition of Λ, for every x ∈ Λ, x is still available at u and x has not been separated
−i i
from y by i in the first k+1 queries, and if they have been separated at the (k+2)-th query, then this
i
queryis stronglyonly-maximal(only-minimal,resp.) effective andeither x =y orneither x nory arethe
i i i i
extreme for which this query is effective. The same holds for x′ with respect to y′. Hence, x and x′ must
have been separated at u.
We then have the following theorem.
Theorem 4. A mechanism M with implementation tree T is k-step OSP for a social function f on finite
domains if and only if it is k-limited and k-step OSP CMON holds.
Proof. If M is k-step OSP, then, by Theorem 3, it is k-limited. Now, suppose that there is a negative cycle
in Ok . Let the negative-weightcycle be C =(Λ1,Λ2,...,Λh+1), with Λh+1 =Λ1. By definition ofk-step
i,f,T
OSP-graph there are profiles aj ∈Λj, for j =1,...,h. By Lemma 7, each profile aj is separated by i from
16aj+1. Since λ−1(aj) 6= λ−1(aj+1), for each j = 1,...,h, then Lemma 6 implies that the following k-step
OSP constraints must be satisfied:
p (a2)−p (a1)≤ min c(f(a2)−f(a1)),
i i
c|∃c−i:(c,c−i)∈Λ1
p (a3)−p (a2)≤ min c(f(a3)−f(a2)),
i i
c|∃c−i:(c,c−i)∈Λ2
···
p (ah)−p (ah−1)≤ min c(f(ah)−f(ah−1)),
i i
c|∃c−i:(c,c−i)∈Λh−1
p (a1)−p (ah)≤ min c(f(a1)−f(ah)).
i i
c|∃c−i:(c,c−i)∈Λk
Since all above inequalities are satisfied, then it must be the case that the inequality achieved by summing
up all above inequalities must be satisfied. However, observe that by summing up the left-hand side we
achieve 0 since each p (x) is added and subtracted once. Instead, the terms on the right-hand side are
i
exactly the cost of edges of C, and thus they sum exactly to w(C). Hence, we obtain the contradictionthat
0≤w(C)<0.
Consider now the case that M is k-limited and there are no negative cycles in Ok for every i. We
i,f,T
then show that there are payments p such that M=(f,p) is k-step OSP with implementation tree T. Fix
i and T and consider the graph Ok . Augment Ok with a node ω and edges (ω,Λ) for any Λ ∈ Λ
i,f,T i,f,T i
eachofweight0. Observethatω does notbelong to any cycleofthe augmented Ok since it hasoutgoing
i,f,T
edges only. Therefore we can focus our attention on cycles of Ok . For any Λ ∈ Λ , we let SP(ω,Λ)
i,f,T i
be the length of the shortest path from ω to Λ in the augmented k-step OSP-graph. Since Ok is finite
i,f,T
and does not have negative-weight cycles then SP(ω,Λ) is well defined. It suffices, for all Λ ∈ Λ , to set
i
p (x) = SP(ω,Λ) for every x ∈ Λ. Indeed, consider two profiles a and b separated by i at u, and a profile
i
c∈Γk(a). If a andb belong to the same classΛ,then p (b)−p (a)=0 andf (b)−f (a)=0, andthus the
u i i i i
k-step OSP constraint (1) is satisfied. If a and b belong to different classes Λ and Λ′, then the edge (Λ,Λ′)
in Ok . The fact that the shortest path from ω to Λ followed by the edge (Λ,Λ′) is a path from ω to Λ′
i,f,T
implies, by shortest path definition, that p (b)−p (a)=SP(ω,Λ′)−SP(ω,Λ)≤c (f (b)−f(a)), and thus
i i i i
the k-step OSP constraint (1) is satisfied.
6 Algorithmic Characterization
We nextprovidethe algorithmiccharacterizationfor k-stepOSP mechanisms. We willstartby recallingthe
characterizationfork =∞. We willsee thathowthis characterizationcanbe easilyextendedtoeachk ≥0.
As fork =∞,the characterizationhasbeenprovidedbyFerraiolietal. [13]. We willreportherethisresult,
since it will be useful in what follows. To this aim, we say that an agent i is revealable at node u under
social choice function f if either f (x)=1 for every x such that x ∈D (u) and x <maxD (u), and x is
i i i i i −i
compatible withu, orf (x)=0 foreveryx suchthat x ∈D (u)andx >minD (u), andx is compatible
i i i i i −i
with u.
Analgorithmf: ×n D →S istwo-waygreedy implementable ifitcanbeimplementedbyaround-table
i=1 i
mechanism with implementation tree T such that:
• ateachnode uthe agenti(u)separatesherdomainD (u)intwoorderedsubsetsL (u)andR (u), i.e.,
i i i
max{t ∈ L (u)} < min{t ∈ R (u)}, such that at least one of the two is a singleton, i.e., it contains
i i
a single type, being the minimum in D (u) (if L (u) is a singleton) or the maximum (if R (u) is a
i i i
singleton). If L (u) is a singleton, then the agent i(u) receives outcome 1 in every profile compatible
i
with L (u)×D (u), and we say that i(u) interacts with the mechanism in a greedy fashion. If R (u)
i −i i
is a singleton, then the agenti(u)receives outcome 0 in everyprofile compatible with R (u)×D (u),
i −i
and we say that i(u) interacts with the mechanism in a reverse greedy fashion;
• each agent i is not allowed to interleave interaction in a greedy fashion with interaction in a reverse
greedy fashion until it is revealable. Specifically, agent i at node u is either revealable,or can interact
17with the mechanism in a greedy fashion if and only it i interacted with the mechanism in a greedy
fashion at every node u′ along the path between the root of T and u such that i=i(u′).
Then we have the following theorem.
Theorem 5 ([13]). There is an OSP mechanism implementing f if and only f is two-way greedy imple-
mentable.
Whilethedefinitionoftwo-waygreedyimplementablemechanismappearstobequiteinvolved,ithasbeen
observed that it establishes a very strong relationship between two-way greedy implementable algorithms
and greedy algorithms [13]. Essentially every greedy algorithm and every reverse greedy algorithm (a.k.a.,
deferred-acceptance algorithm) is two-way greedy, and hence can be turned in an OSP mechanism. This
continues to hold if the algorithm is allowed to greedily insert into the solutions some components (i.e.,
interact greedily with some agents) and reverse greedily remove from the solutions other components (i.e.,
interact reverse greedily with other agents). We will finally observe that whenever an agent is revealable at
some node u, we can ask the agent to reveal her type without affecting the OSPness of the mechanism.
6.1 k-step OSP-graph vs. ∞-step OSP-graph
We first prove a useful relation between negative cycles in the k-step OSP-graph,and negative cycles in the
∞-step OSP-graph. This will be useful to provide later a characterization of k-step OSP mechanisms as
two-way greedy mechanisms enjoying a special adjunctive feature.
Lemma 8. Let M be a k-limited mechanism with implementation tree T. There is no negative cycle in
Ok if and only if there is no negative cycle in O∞ .
i,f,T i,f,T
Proof. Suppose that there is a negative cycle C in O∞ . Now consider the sequence of nodes C′ in Ok
i,f,T i,f,T
defined as follows: for each profile x∈C, we insert in C′ the node Λj such that x∈Λj. Now for each edge
(x,y) of C such that x∈Λj and y∈Λh, for j 6=h, we must have that edge (Λj,Λh) exists, and
w(Λj,Λh)= min t(f (Λh)−f (Λj))≤x (f (y)−f (x))=w(x,y).
i i i i i
t|∃c−i:(t,c−i)∈Λj
Moreover, for each edge (x,y) of C such that x,y ∈ Λj, we have that w(x,y) = x (f (y)−f (x)) = 0.
i i i
Hence, by pruning from C′ the possible consecutive replications of the same node, we get a cycle in Ok
i,f,T
whose cost is at most the cost of C, and thus is negative, as desired.
Consider now the case that there is a negative cycle C in Ok . We can suppose w.l.o.g. that C is a
i,f,T
simple cycle (i.e., it visits each node only once), otherwise, in order for C to be negative, there must be at
least one negative simple cycle within C, that we can take in place of C. We consider the sequence C′ of
nodes of O∞ defined as follows: for each Λj ∈ C, we add to C′ the profile xj = (xj,xj ) such that xj =
i,f,T i −i i
argmin t|∃c−i:(t,c−i)∈Λj andxj −ibeoneoftheprofilesoftheotheragents’actionsforwhichxj ∈Λj. Lemma7
impliesthatedge(xj,xj+1)existsinO∞ andhascostxj(f (xj+1)−f (xj))=xj(f (Λj+1)−f (Λj)),that,
i,f,T i i i i i i
by our choice of xj, is exactly the cost of edge (Λj,Λj+1) in C. Hence, we can conclude that the cost of C′
i
is exactly the cost of C, and thus negative, as desired.
6.2 k-step OSP Characterization
Two-way greedy implementation of a social choice function f assumes that the implementation tree T is
binary and makes only extremal queries. Clearly, each implementation tree T′ for which there are no
negative cycles in O∞ , regardless the kind of queries that are performed in T′, can be transformed in an
i,f,T′
implementation tree T with binary extremal queries that still has no negative cycle through a serialization
procedure(see[13,Observation3andTheorem4]). Similarly,abinaryimplementationtreeT withextremal
queriesandnonegativecycleinO∞ canbetransformedinanimplementationtreeT′ withgenericqueries
i,f,T
but still no negative cycle through a simple compression procedure: every two consecutive nodes u and u′
18such that i = i(u) = i(u′) can be merged in a single node U with outgoing edges leading to v ,...,v , and
1 x
to v′,...,v′, where v ,...,v are the children of u different from u′, and v′,...,v′ are the children of u′.
1 y 1 x 1 y
However, these serialization/compressionoperations will change the number of queries done to each agent.
While this does notmatterfor ∞-stepOSPness,it turnsout tobe veryrelevantfor k-stepOSPness. Hence,
we will introduce a way to keep the number of queries to a given agent unchanged after the operations of
serialization/compression. Specifically, we say that a binary implementation tree T with extremalqueries is
k-limitable if and only if the implementation tree T′ achievedthrough the compressionprocedure described
above is k-limited. (Note that for convenience we are abusing a bit our terminology by calling k-limited the
implementation tree T′ rather than the mechanism M using T′.)
We then have the following characterization.
Theorem 6. There exists a k-step OSP mechanism implementing f if and only f is two-way greedy imple-
mentable and the corresponding implementation tree T is k-limitable.
Proof. Suppose that there exists a k-stepOSP mechanismimplementing f with implementation tree T. By
Theorem 4, T is k-limited and k-step OSP CMON holds. Note that since k-step OSP CMON holds, then,
by Lemma 8, there is no negative cycle in O∞ . Consider the implementation tree T′ achievedby running
i,f,T
the serializationproceduredescribedaboveon T. Since T is k-limited,thenit followsthatT′ isk-limitable.
Moreover, since there is no negative cycle in O∞ , then there is no negative cycle in O∞ . Hence, by
i,f,T i,f,T′
Theorem 5 f is two-way greedy.
Supposenowthatf istwo-waygreedyimplementablethroughak-limitableimplementationtreeT. Then,
by Theorem 5, there is no negative cycle in O∞ . Consider then the implementation tree T′ achieved by
i,f,T
running the compression procedure on T; there is no negative cycle in O∞ . Moreover, since T is k-
i,f,T′
limitable, then T′ is k-limited and thus, by Lemma 8, Ok has no negative cycles. Then, by Theorem 4,
i,f,T′
we have that the corresponding mechanism is k-step OSP.
Essentially, Theorem 6 states that the characterization in term of greedy algorithms provided for OSP
continuestoholdevenfork-stepOSPness. However,forthesemechanismwealsorequireafurtherconstraint
to be satisfied, namely that the implementation tree is k-limited (in its compressed version) or k-limitable
(in the serialized version). This essentially means that the mechanism can interact with each agent at most
k+2 times (with the (k+2)-th interaction limited as discussed above).
The effect of this limitation is very heavy in the case of strong OSP mechanisms. Indeed, a 0-limitable
two-way greedy implementable f can be implemented by a compressed implementation tree T that can be
described as follows. For each agent i, for each path P from the root to a leaf, let u be the first node in P
such that i=i(u) and let v ,...,v be the childrenof u with maxD (v )<minD (v ); then for each x
1 ℓ i j i j+1 −i
compatible with u one of the following three cases occurs:
• there is j∗ ∈{0,1,...,ℓ,ℓ+1} such that f (x ,x )=1 for x ∈
j∗
D (v ), and f (x ,x )=0 for
i i −i i j=1 i j i i −i
x ∈ ℓ D (v );
i j=j∗ i j S
• f (x ,x ) = 0 for x ∈ ℓ D (v ), f (x ,x ) = 1 for x ∈ D (v ) with x < maxD (v ), and
i iS−i i j=2 i j i i −i i i 1 i i 1
f (x∗,x )∈{0,1} for x∗ =maxD (v );
i i −i i i 1
• f (x ,x ) = 1 for x ∈
Sℓ−1D
(v ), f (x ,x ) = 0 for x ∈ D (v ) with x > minD (v ), and
i i −i i j=1 i j i i −i i i ℓ i i ℓ
f (x∗,x )∈{0,1} for x∗ =minD (v ).
i i −i i S i ℓ
That is, either the separation between outcomes 0 and 1 is decided at the first query, or we are allowed
to run a second query affecting the outcome of agent i only for separating the maximum of the group of
minimal types or the minimum of the group of maximal types.
This can be easily characterized to every k, by essentially stating that a social function f can be imple-
mented by a k-step OSP mechanism only if the possible thresholds for the outcomes can be determined in
at most k+1 compressed queries or at most k+2 non-interleaving queries.
197 Approximation Guarantee of k-step OSP Mechanisms
In this section we apply our characterization to quantify the restriction that k-step OSP imposes on the
quality of the algorithmic solution that can be implemented. We will focus on maximization problems;
agents’ types will thus be a non-negative valuation (i.e., a non-positive cost) for each algorithmic allocation
received.
To introduce our questions of interest, we start by discussing arguably the simplest possible problem in
this area, social-welfare maximizing single-item auctions: n agents have a valuation v ∈ D for the item,
i i
andwe are willing to sellthe item to the agentwiththe highestvaluation. Note that in orderto fully define
the social function f for this problem, we need to specify how ties are broken. We will assume that ties are
broken in favor of the agent with the smallest index. We will also assume that every agent i has a domain
D = D. It is not hard to see how most of the arguments below can be adapted to work also if both these
i
assumptions are dropped.
The ascending price auction discussed in Example 1 is an OSP mechanism that solves this problem
optimally. We can rephrase it in terms of two-way greedy implementation as follows: mark all agents as
available; for t from the smallest type to the second largest type in D or until there is only one available
agent,askeachavailableagentiin orderoftheir index whether her type is t, andincase ofpositive answer,
mark the agent as unavailable; assign the item to the agent with smallest index among the available ones.
Actually, this is not the unique OSP auction implementing the desired social function (e.g., we can query
agents from the largest to the second smallest type and allocate the item upon a positive answer).
Our question is the following: is it possible to implement single-item auctions with a k-step OSP mech-
anism? And if not, how large can be the price of limited foresight? To answer these questions, first observe
that the English auction described above queries each agent |D|− 1 times, with the last query being a
revelationstronglyonly-minimumeffective query. Hence,this mechanismis k-limitable,and,by Theorem6,
k-step OSP for every k ≥|D|−3.
However,the mechanism fails to be (|D|−4)-limited. Indeed, after the (|D|−3)-th query to agenti, its
domaincontainsthe threelargesttypes,andforeachactionofotheragentscompatiblewiththe (|D|−3)-th
query, the outcome of this agent should be the same when agent i has the smallest and the second smallest
type. But the ascending price auction described above does not provide such a guarantee.
Can there be another k-step OSP mechanism implementing the social choice function f? Or some
social function f′ differing from f only in the tie-breaking rule (and hence, still retuning an allocation that
maximizes the social welfare)?
Wewillnextshowthatak-stepOSPmechanismexistsforthis problemwheneverk ≥ |D| −2(e.g.,an
2
SOSP mechanismexists whenever|D|≤4). Actually, we provethat this resultholds evenlin ammore general
setting than single-item auctions. We also prove that this result is tight.
7.1 Weighted Matroids and p-systems
We will now focus on the class of problems that satisfy the downward closed property. In these problems
we are given a set E of elements, with each element e associated to a weight w(e) ∈ R, and a set F,
containing subsets S ⊆ E, named feasible solutions, that enjoy the following property: if S ∈ F, then
T ∈ F for every T ⊆ S, and we need to select the one feasible solution of maximum total weight, i.e.
S∗ =argmax w(e).
S∈F e∈S
Mostwell-knownproblems belong to this class: the socialwelfare maximizing single-itemauctioncanbe
P
seen as a problem in this class, where E corresponds to the set of agents, their weight corresponds to their
valuation for the item, and the set of feasible solution are all (and only) the singletons. Other examples of
problems that can be easily modeled in this way are the ones of finding the maximum number of linearly
independentrowsinamatrix,ortheoneoffindingtheminimumspanningtreeorthemaximumindependent
set in a graph.
A special subclass of problems satisfying the downward closed property consists of problems defined on
(weighted)matroids: for these problems,the set of feasible solutions alsoenjoys the exchange property, that
20is, if S ∈F and T ∈F and |S|≤|T|, then there is e∈T \S such S∪{e}∈F.
Given a subset S of elements, we denote with O(S) the set of feasible solutions that are maximal with
respecttoS,i.e. O(S)={T ∈F: T ⊆S,T∪{e}∈/ F ∀e∈S\T}. WealsosimplywriteO asshorthandfor
O(E), i.e., the maximal feasible solutions in F. Note that in a matroid, the exchange property implies that
for every pair of solutions S,T ∈ O, we have that |S| = |T|. For this reason, we can measure the distance
between a generic problem satisfying the downward closed property and a problem defined on a matroid,
by the extent to which two maximal feasible solutions differ in size. Specifically, given a downward-closed
problem(E,F),andasubsetS ofE,the lower rank ofS islr(S)=min{|T|: T ∈O(S)},i.e.,the sizeofthe
smallestmaximalfeasiblesolutionwithrespecttoS,andtheupperrank ofSisur(S)=max{|T|: T ∈O(S)},
i.e., the size of the largest maximal feasible solution with respect to S. Then, the distance of (E,F) from
beingamatroidisdefinedastherankquotient q(E,F)=min lr(S) |S ⊆E,ur(S)6=0 ,thatisessentially
ur(S)
an upper bound on the ratio between the sizes of the smallenst and the largest maximaol feasible solutions.
We then say that, for p ≤ 1, a downward-closed problem (E,F) is a p-system if q(E,F) = p. Note that
problems on matroids are 1-systems.
Given a p-system (E,F), let an algorithm process elements in some order e ,...,e and let E =
1 n j
{e ,...,e }. If the algorithm returns a solution G such that G = G∩E , with j = 1,...,n, is a maximal
1 j j j
feasible solution with respect to E , then the total weight of elements in G is at least a fraction p of the
j
total weight of the optimal feasible solution [18]. Recall that the greedy algorithm processes elements e in
decreasing order of their weight, and includes them in the current solution S unless S∪{e}∈/ F, whilst the
reverse greedy algorithmprocesseselements e in increasingorderof their weight, andremoveanysolutionS
containing e fromO unless this empties O. It is not hard to see that both greedy and reservegreedy satisfy
the property described above5, and hence they return a p-approximation of the optimal solution for every
p-system. This, in turn, means that for all these problems, it is possible to design an OSP mechanism that
is able to return a p-approximate feasible solution for the problem [13].
We next show that it is always possible to implement the reverse greedy algorithm defined above as a
k-limitable two-way greedy algorithm when k ≥ |D| −2, and thus, by Theorem 6, that a k-step OSP
2
algorithmexiststhatreturnsap-approximatesolutlionfmoreveryp-system. Unfortunately,wewillshowthat,
if no constraint is given on the values in D, then no k-step OSP mechanism exists that is able to return a
bounded approximationof the optimal solution, whenever k < |D| −2.
2
l m
7.1.1 Two-Way Greedy Algorithm
We next describe in Algorithm 3 the k-limitable two-way greedy algorithm for p-systems. For readability,
the algorithm assumes that E = {1,...,n} and D = D = {t ,...,t } for every j ∈ E: if the domain
j 1 d
of some agents were a subset of D, then clearly some of the queries could be skipped, allowing the actual
implementation to be k′-limitable for them.
The algorithms makes two kind of queries to agents, that we name respectively bottom queries and top
queries. Theformerasksanagentifhertypeistheminimuminhercurrentdomain,andifso,itexcludesthe
correspondingelementfromthecurrentsolution(seeAlgorithm1). Incidentally,excludingoneelementfrom
the solution implies that there are other elements that cannot be excluded (e.g., in the minimum spanning
tree application, once δ−1 edges have been removed from a node of degree δ, we know that the remaining
edge will surely belong to the solution). Hence, when we run a bottom query, we do not only save those
elements that have been excluded, but also the ones that consequently will surely belong to the solution
(regardless of her type/weight): indeed, in both cases, we do not need to make further queries to these
elements.
5Whileforgreedy this isimmediate(and indeedthis isstated in[18]), forreverse greedy, itfollowsbyconsidering element
(e1,...,en)indecreasingorderofweights(sothatthealgorithmwillprocessthemfromthelasttothefirstone),andobserving
there cannot bean element e∗ ∈Ej\Gj, such that Gj∪{e∗} isfeasible, sinceat the timethe algorithm processes e∗, either
nosolutioncontaininge∗ isremoved fromO,andthus Gmustcontain e∗,orthere isatleastonesolutioninO thatdoes not
containe∗ anditismaximalforE,andthus alsoforEj,anditisreturned bythealgorithm.
21Algorithm 1: Bottom Query
1 def BQuery(j, S, X):
2 ask j if hertypeis minD j
3 if yes then
4 add j to X
5 U =unremovable(S, X)
6 S =S∪U
7 if X∪S =E then return True
8 return False
In order to check which element cannot be excluded we assume that a function unremovableexists that
givenininputapartialsolutionS,andasetofexcludedelementsX,returnsthesetU ofelementsthatmust
be inserted in the solution. In general, this function may maintain the set O of maximal feasible solutions,
exclude from O all solutions S involving elements in X, and return the set U = {e ∈ E \(X ∪S): e ∈
T ∀T ∈ O}, i.e., the set of those elements that belong to all non-excluded maximal solutions. Note
that however the set O may in principle contain an exponentially large number of solutions, and thus the
implementation of the function unremovable as described above is not in general polynomial. However, it
is often possible, by exploiting the structure the problem, to implement unremovable without the need of
keeping this exponentially large data structure, as in the case of, e.g., minimum spanning tree.
The function is assumed to signal through the return value whether the final solution has been found,
i.e., when all elements are either in the current solution or have been excluded.
A top query instead asks an agent if her type is the maximum in her currentdomain, and if so, includes
the corresponding element in the solution (see Algorithm 2). As for the bottom query, this may in turn
cause some other elements to be excluded from the solution (since they never appear in a solution with the
one element that we just added to our solution).
Algorithm 2: Top Query
1 def TQuery(j, S, X):
2 ask j if hertypeis maxD j
3 if yes then
4 add j to S
5 U =removable(S, X)
6 X =X∪U
7 if X∪S =E then return True
8 return False
Asabove,weassumethatafunctionremovableexiststhatfindstheseelements;ageneralimplementation
would return the set U = {e ∈ E\(X ∪S): e ∈/ T ∀T ∈ O}, where O is defined above, but more efficient
implementationscaninprinciplebefoundbyexploitingthespecificproblemofinterest. Finally,thefunction
isassumedtosignalthroughthereturnvaluewhetherthefinalsolutionhasbeenfound(i.e.,whenallelements
are either in the current solution or have been excluded).
WearenowreadytopresentinAlgorithm3thetwo-waygreedyalgorithmforfindingthefeasiblesolution
of approximate maximum weight in a p-system. The algorithm works as follows: it maintains a set A of
aliveagents,thatis,thoseagentsthatdidnotrevealtheirtype(i.e.,theyneveransweredyestosomequery)
andare not unremovable(i.e., they do notbelong to any remaining maximalfeasible solution); in Lines 6-8,
the algorithm looks for the first agent whose type is not the minimum in her domain, by querying agents
in order of their id until the first agent that answer no is found (or only one maximal feasible solution is
left, that must be returned)6; once the first agent is found whose type is not the minimum, in Lines 10-13,
6Note that in the algorithm A changes as soon as either S or X change, and hence as soon as one agent answers yes to a
22the algorithm asks each remaining agent whether her type is the minimum or the second minimum in her
domain; finally, in Lines 15-18, the algorithm asks to the first alive agent (for whom the minimum was
already discarded) if her type is the second or the third minimum in her domain; note that the algorithm
tries to keep always one alive agent that is one query ahead with respect to the others, and thus if the first
agenthappenstonotbealiveasaneffectofthelasttwoqueries,weneedtofindanotheragentthatwillplay
this role,andthis isdoneinLines19-21; this processisrepeateduntilthe domainofthe firstaliveagenthas
size 3 and the domain of remaining agents has size 2, if |D| is even, or the domain of the first agent has size
2 and the domain of remaining agents has size 1, otherwise; after that, one last query is asked(to all agents
if |D| is even, and to the first alive agent only otherwise) in order to have that the domain of all agents is
fully revealed,and hence the desired maximal feasible solution can be immediately computed and returned.
Algorithm 3: k-limitable two-way greedy algorithm for a p-system (E,F)
1 Set b=1−|D| mod 2
2 Let S =unremovable(∅,∅) /* The partial solution */
3 Let X =removable(∅,∅) /* The excluded elements */
4 UseA as an alias for E\(S∪X) /* The set of alive elements */
5 Let j =0 /* The next agent to query */
6 whilej 6=minA do
7 if BQuery(minA, S, X) then return S
8 j =j+1
9 while|DminA|>2+b or |DmaxA|>1+b do
10 for j ∈A:j >minA,|D j|>2 do
11 if BQuery(j, S, X) then return S
12 if j ∈A then
13 if BQuery(j, S, X) then return S /* We can compress last two queries */
14 j =minA
15 if |D j|>2+b then
16 if BQuery(j, S, X) then return S
17 if j ∈A then
18 if BQuery(j, S, X) then return S /* We can compress last two queries */
19 whilej 6=minA do
20 if BQuery(minA, S, X) thenreturn S
21 j =j+1
22 if |D| is even then
23 for j ∈A:j >minA do
24 if TQuery(j, S, X) then return S /* Only-minimum effective bottom query */
25 if BQuery(minA, S, X) then return S /* Only-minimum effective bottom query */
26 else
27 if BQuery(minA, S, X) then return S /* Only-minimum effective bottom query */
28 add minA to S
29 U =unremovable(S,X)
30 return S∪U
We next prove the following result.
Theorem 7. Algorithm 3 is two-way greedy, and it is k-limitable for k ≥ |D| −2. Moreover, it returns a
2
p-approximation of the feasible set of maximum weight for every p-system.l m
query, butitdoesnotchangewhenthequeriedagentgivesanegativeanswer.
23Proof. InordertoprovethatAlgorithm3istwo-waygreedy,itissufficienttoshowthatwedonotinterleave
top and bottom queries to some element unless the domain of that element is revealable, but this is clearly
the case for Algorithm 3, since interleaving only occurs when the domain of the element has size two.
Inordertoprovethatthealgorithmisk-limitable,itissufficienttoobservethatqueriescanbecompressed
so that each agent receives at most k+2 queries, with the the (k+2)-th query allowed only if the previous
queries are all bottom query, and being either a strongly only-minimum effective revelation query or an
only-minimum effective bottom query.
To this aim, let us first assume that |D| is even. Observe that the element minA receives one single
query (at Line 7 or at Line 20), two consecutive queries (that can be compressed) until the domain has size
3 and a final single query (at Line 25). Hence she receives 2+x compressed queries, where x is such that
|D|−2x−1 = 3, and thus x = |D| −2 ≤ k, as desired. Moreover, it is immediate to check that the last
2
query is an only-minimum effective bottom query. As for remaining elements they receive two consecutive
queries until the domain has size 2, and one final top query. Hence, they receive 1+x compressed queries,
where x is such that |D|−2x = 2, and thus x = |D| −1 ≤ k+1, as desired. Moreover, for the last query,
2
since the domain has size 2, it is trivially an only-minimum effective bottom query.
If |D| is odd, then element minA receives one single query (at Line 7 or at Line 20), two consecutive
queries (that can be compressed) until the domain has size 2, and a final single query. Hence she receives
2+x compressed queries, where x is such that |D|−2x−1 = 2, and thus x = |D|+1 −2 ≤ k, as desired.
2
Moreover, since the domain has size 2, the last query trivially is an only-minimum effective bottom query.
As for remaining elements they receive two consecutive queries until the domain has size 1. Hence, they
receive x compressed queries, where x is such that |D|−2x=1, and thus x= |D|+1 −1≤k+1.
2
Finally,weprovetheapproximationofthemechanism. Tothisaim,observethattheoutcomereturnedby
thismechanismisexactlythesamereturnedbyareversegreedyalgorithm,eveniftheorderinwhichelements
are removed changes based on their type: for even |D| it essentially alternates the order (minA,minA+
1,...,maxA) used for odd types (the first type in the domain, the third one, and so on) with the order
(minA+1,...,maxA,minA) used for even types.
7.1.2 Inapproximability Results
We next show that no bounded approximation can be achieved by a k-step OSP mechanism whenever
k < |D| −2, even for p-systems with bounded p. Interestingly, on the way to prove this result, we will
2
also hlighlmight how reversegreedy algorithms appear to be more powerful than greedy algorithms when they
should be implemented by selfish agents with limited cognitive abilities: indeed, while in Section 7.1.1, we
proved that it is possible to turn a reverse greedy algorithm in a k-limited two-way greedy algorithm for
every k≤ |D| −2, we will observe that it is impossible to turn a greedy algorithm in a k-limited two-way
2
greedy algolrithmm for every k <|D|−3.
To this aim, we consider the problem of maximizing the social welfare in a single-item auction, that, as
described above, is a special case of problems on weighted matroids, and thus a special p-system. Assume
that for each agent e ∈ E, we have w(e) ∈ D = {t ,...,t }, where d = |D| ≥ 4, and t > ρt for every
1 d j+1 j
j =1,...,|D|−1, for some ρ>0. Suppose that there exist a socialchoice function f that is implementable
by a k-step OSP auction and returns a feasible solution whose total weight is better than an 1/ρ fraction
of the total weight of the optimal solution for any instance. By Theorem 6 f must be implementable by a
k-limitable two-way greedy mechanism M with implementation tree T. We next provide some properties
about T. Recall that we denote as bottom query, a query in which the element is asked whether her weight
is the smallest in the current domain, andin case of a positive answer,the element will surely not belong to
the returned solution (and hence the element is not further queried). Similarly, we denote with top query,
a query in which the element is asked whether her weight is the largest in the current domain, and in case
of a positive answer, the element will surely belong to the returned solution (and hence the element is not
further queried). Recall also that we say that interleaving occurs in T if there is a path such that element
e first receives a bottom query and then a top query, or viceversa: in a two-way greedy algorithm this is
24allowedonly if at node u in whichthe directionof queries interleavesthe domainof e is revealable,meaning
that for all values in the domain except at most the smallest one, if queries before u were bottom queries,
and the largest one, otherwise, the outcome is always the same regardless the actions of other players.
Lemma 9. Let u be a node of T and let e = i(u). Suppose that D (u) is not revealable. Let then v be the
e
unique child of u such that D (v) is not a singleton.
e
If the query at u is a bottom query, then D (v) = {t ,t ,...,t } for some x > 1. Moreover, if
e x x+1 d
minD e′(v)<t
x
for every e′ 6=e, and there is at least e′′ such that maxD e′′(v)>t x+1, then i(v)6=e.
Similarly, if the query at u is a top query, then D (v) = {t ,...,t ,t } for some x < d. Moreover,
e 1 x−1 x
if there is at least one agent e′′ such that maxD e′′(v) > t x, and minD e′(v) < t
x−1
for every e′ 6= e, then
i(v)6=e.
Proof. Suppose first that the query at u is a bottom query. Since D (u) is not revealable, and M is a two
e
way greedy algorithm, this means that there has been no interleaving along the path from the root of T
and u. Hence, all the query to e preceding the one at u must be bottom query, from which we achieve that
D (v)={t ,t ,...,t } for some x>1, as desired.
e x x+1 d
Now, suppose that the domain of the other agents is as in the claim. We now prove that the domain of
e atv is not revealable,i.e., that for w(e)=t there is both a leaf ℓ in the subtree rootedin v such that
x+1 in
e belongs to the solution corresponding to ℓ , and a leaf ℓ such that e does not belong to the solution
in out
corresponding to ℓ out. Indeed, the profile y such that y e = t x+1 and y e′ ≤ t x for every e′ 6= e is available
at v (and thus there must be a leaf ℓ at which it corresponds), and for it the mechanism must assign the
in
item to e, otherwise the cost of the returned solution would be at most t < 1t ≤ 1OPT(y), where
x ρ x+1 ρ
OPT(y) denotes the optimal solution for profile y. Similarly, the profile z such that z e =t x+1, z e′′ >t x+1,
and z e′ ∈D e′(v) for every e′ 6=e,e′′ is available at v, and for it the mechanism must not assign the item to
e, otherwise the cost of the returned solution would be at most t < 1t ≤ 1OPT(z).
x+1 ρ x+2 ρ
Since the domain of e at v is not revealable, it follows that we cannot interleave, and thus make a top
query to e at v. We next show that it is not possible to have a bottom query at this node, from which
the claim follows. Suppose instead that the query at v is a bottom query to e, and consider the profile y
such that y = t and y′ < t for every e′ 6= e. Note that this profile is compatible with the children of
e x e x
v corresponding to an yes answer to the bottom query. Hence, the mechanism does not assign the item to
e, and thus receives a social welfare of at most t < 1t = 1OPT(y), contradicting the fact that the
x−1 ρ x ρ
mechanism always returns a 1-approximation.
ρ
Thecasethatthequeryatuisatopqueryisverysimilar,anditisincludedonlyforsakeofcompleteness.
Since D (u) is not revealable, and M is a two way greedy algorithm, this means that there has been no
e
interleavingalong the path fromthe rootof T andu. Hence, all the query to e preceding the one at u must
be top query, from which we achieve that D (v)={t ,...,t ,t } for some x<d, as desired.
e 1 x−1 x
Now, suppose that the domain of the other agents is as in the claim. We now prove that the domain of
e atv is not revealable,i.e., that for w(e)=t there is both a leafℓ in the subtree rootedin v such that
x−1 in
e belongs to the solution corresponding to ℓ , and a leaf ℓ such that e does not belong to the solution
in out
corresponding to ℓ out. Indeed, the profile y such that y e = t x−1 and y e′ <t x−1 for every e′ 6=e is available
at v (and thus there must be a leaf ℓ at which it corresponds), and for it the mechanism must assign the
in
itemtoe,otherwisethecostofthereturnedsolutionwouldbeatmostt < 1t ≤ 1OPT(y). Similarly,
x−2 ρ x−1 ρ
the profile z such that z e =t x−1, z e′′ > t x, and z e′ ∈D e′(v) for every e′ 6= e,e′′ is available at v, and for it
the mechanism must not assign the item to e, otherwise the cost of the returned solution would be at most
t < 1t ≤ 1OPT(z).
x−1 ρ x ρ
Sincethedomainofeatv isnotrevealable,itfollowsthatwecannotinterleave,andthusmakeabottom
query to e at v. We next show that it is not possible to have a top query at this node, from which the
claim follows. Suppose instead that the query at v is a top query to e, and consider the profile y such that
y e =t x, y e′′ >t x and y e′ ∈D e′(v) for every e′ 6=e. Note that this profile is compatible with the children of
v corresponding to an yes answer to the top query. Hence, the mechanism must assign the item to e, and
thus receives a social welfare of at most t < 1t = 1OPT(y), contradicting the fact that the mechanism
x ρ x+1 ρ
always returns a 1-approximation.
ρ
25Despite the apparent symmetry between top and bottom queries in Lemma 9, it is the case that they
are different in terms of k-step OSPness of the mechanism, as suggested by comparing Theorem 7 (and
the observationthat Algorithm3 essentiallyprovides animplementation of the reversegreedy algorithmfor
p-systems) and the following corollary of Lemma 9.
Corollary 2. For every ρ > 0, every d = |D| ≥ 4, every k < d−3, and every n ≥ d,7 there is a p-system
(E,F) with |E| = n, such that any k-limitable two-way greedy implementation of the greedy algorithm for
this problem, returns a feasible solution of total weight not larger than a 1 fraction of the total weight of the
ρ
optimal feasible solution.
Proof. Let us consider the single-item auction setting with D as described above. Any implementation of
the greedy algorithm for this problem works by defining an ordering π over agents for every x ∈ [d], and
x
making top queries about type t according to the ordering π , until either the first agent is found that
x x
produces a yes answers (and it is then assigned the item) or the domain of some agent is revealable (and
thus we can make a strongly only-maximum effective revelation query for that agent). Suppose that there
exists one such implementation that is k-limitable and always returns an 1-approximation of the optimal
ρ
feasible solution.
Let us focus on the path of the implementation tree of this mechanism compatible with the type of all
agents being t .
1
We first show that the domain of an agent e cannot become revealable until the domain of remaining
agents contains other elements except at most t and t . Indeed, when the type of e is t we can still be
1 2 2
in a profile in which e, by the approximation guarantee of the mechanism, must be assigned the item (i.e.,
when all remaining elements have type t ), and in a profile in which e, by the approximation guarantee of
1
the mechanism, must not be assigned the item (i.e., when there is at least one alternative agent whose type
ist ). Hence,inorderforthe domainofagentetobe revealableweneedthateachremainingagentreceived
3
at leastd−2 top queries. Note also thatwhen the domain ofan agenthas size 2, this is trivially revealable.
Moreover, it must be the case that for each agent e whose domain is {t ,t }, we need to make another
1 2
query unless the domain of all remaining agents is {t }. Indeed, if this query is not done, then the outcome
1
received by e is the same when her type is t and the type of e′ is t , and when her type is t and the type
1 2 2
of e′ is t , where e′ is one ofthe remaining agentswhose domaincontains atleast t andt . But this clearly
1 1 2
lead to an approximation worse than 1.
ρ
Hence,ifweshowthatthere areatleasttwoagentsdifferentfrome suchthatnotwoconsecutivequeries
canbe done to these agents,then the needed d−2topqueriescannotbe compressed,andfor atleastone of
thesetwoagents,anadditionalqueryisneeded. Thisagentthenreceivesd−1queries. Sincethemechanism
is k-limitable, then d−1≤k+2, that contradicts our hypothesis.
However, the existence of these two agents is guaranteed by Lemma 9 and our choice of n. Indeed, by
Lemma 9, each agent that receives a top query about type t cannot receives a top query about type t
x x−1
unless all remaining agents discarded type t from their domain. Hence, only the last agent that receiving
x
the top query about t ,...,t can immediately receive another query. Since there are at most d−2 such
d 3
agents, and n−1≥d, the claim follows.
We are now ready to prove that Theorem 7 is tight.
Theorem 8. For every ρ > 0, every d = |D| ≥ 5, and every k < d −2, there is a p-system (E,F) with
2
|E| = n, such that no k-limitable two-way greedy algorithm returns a feasible solution of total weight not
larger than a 1 fraction of the total weight of the optimal feasible solution for this problem.
ρ
7Actually,itispossibletoprovethatgreedyalgorithmsareweakerthanreversegreedyintermsofimplementabilitythrough
k-stepOSPmechanisms,evenforsmallervaluesofn≥4. Indeed,inthiscase,wewouldbeabletoproveinapproximabilityby
k-limitedmechanismsforeveryksmallerthanathresholdofabout 2d,andthusstilllargerthanthe d thresholdthatwehave
3 2
beenabletoproveforreversegreedyalgorithms. Thisresultsfollowsbynoticing,asdoneintheproofbelow,that,byLemma9,
agents can receive two consecutive top queries only in extreme cases, and they can never receive more than two consecutive
queries: the result then follows by noticing that it is impossiblethat three different agents can be found in the extreme case
allowingconsecutive queries formorethanonethirdofthetotal possiblecases.
26Proof. Let us consider the single-item auction setting with D as described above. Suppose that a two-
way greedy algorithm exists that always returns an 1-approximation of the optimum. By Corollary 2, the
ρ
algorithm cannot be the implementation of a greedy algorithm. Moreover, as showed above, if all agents
receive as first query a top query, then the domain of these agents becomes revealable only if the domain
has size two for all agents (except at most one). That is, any two-way greedy algorithm that makes a top
query as first query to each agent must be an implementation of a greedy algorithm.
Hence, either the k-limitable two-way greedy algorithms starts with a bottom query for all agents, or
there is an agente for whichthe firstquery is a bottom queryand anotheragente′ for whichthe firstquery
is a top query. By Lemma 9, it follows that we cannot make a bottom query to e about type t , and we
3
cannotmakeatopquerytoe′ abouttypet . Hence,foreachactionofagentsdifferentfromeande′,emust
4
receive the same outcome for each type in {t ,...,t } and e′ must receive the same outcome for each type
3 d
in {t ,...,t }: it is immediate to chech that there is a choice of action of other players (e.g., they all have
1 4
type t ), for which this constraint leads to an approximation worse than 1.
1 ρ
Thus, the k-limitable two-way greedy algorithm must start with a bottom query for all agents. Let us
focus onthe pathofthe implementationtree ofthis mechanismcompatiblewith the type ofallagentsbeing
t .
d
We first show that the domain of an agent e cannot become revealable until the domain of remaining
agents contains other elements except at most t and t . Indeed, when the type of e is t we can still
d−1 d d−1
be in a profile in which e, by the approximationguaranteeof the mechanism, mustnot be assignedthe item
(i.e., whenallremainingelementshavetype t ), andina profileinwhich e,by the approximationguarantee
1
of the mechanism, must not be assigned the item (i.e., when there is at least one alternative agent whose
type is t ). Hence, in order for the domain of agent e to be revealable we need that eachremaining agent
d−2
receivedatleastd−2bottomqueries. Notealsothatwhenthedomainofanagenthassize2,thisistrivially
revealable.
Moreover,it mustbe the casethat foreachagente whosedomainis {t ,t },we need to makeanother
d−1 d
query unless the domain of all remaining agents is {t }. Indeed, if this query is not done, then the outcome
d
received by e is the same when her type is t and the type of e′ is t , and when her type is t and the
d d−1 d−1
type ofe′ is t , where e′ is oneofthe remainingagentswhosedomaincontainsatleast t andt . But this
d d−1 d
clearly lead to an approximation worse than 1.
ρ
Hence, by Lemma 9, for each agent different from e we cannot make more than two consecutive queries.
Then we cannotcompress the needed d−2 bottom queries in less than d−1 compressedqueries, andfor at
2
least one agent, an adjunctive query is needed. This agent then receives d queries. Since the mechanism is
2
k-limitable, then d ≤k+2, that contradicts our hypothesis.
2
8 Conclusions
In this work, we have studied the algorithmic robustness of OSP to agents that are not able to perform
contingent reasoningand think about their future actions. Specifically, we introduce a novel notion, termed
k-stepOSP,thatsmoothensthe notionsofOSP(whereabsenceofcontingentreasoningisthe onlycognitive
limitation) and SOSP (where in addition agents are unable to think about any of their future actions) by
maintaining the assumption that agents are not able to think contingently but allowing them a foresight of
k self moves ahead. We provide an algorithmic characterizationof these mechanisms for single-dimensional
agentsandbinaryoutcomes,viathe introductionofa new cyclemonotonicitytoolkit. We applyourcharac-
terizationtodownward-closemaximizationproblemsandprovethattheperformanceofOSPcandeteriorate
when k is small in comparisonto the type space of the agents. En route, we prove that reversegreedy algo-
rithms are more robust than greedy algorithms to this worsening of the performances.
A natural open problems left by this work is to understand the extent to which the findings above
hold for non-binary allocation problems, and quantify the limitations of limited planning horizons for other
optimization problems, such as scheduling related machines that is now fully understood for OSP [17]. We
highlightthatourframeworkcanalsobeadoptedfornon-binaryallocationproblemstoprovethatthequery
from the (k+2)-th onward must be limited in some way (specifically, (11) must hold), but this does not
27necessarilyleadto mechanisms with only k+2 queries (as highlightedby the example in Appendix B) since
theTaxationPrinciplefork-stepOSPwouldbelesscleanastherelativeweightoftypesandoutcomeswould
come to the fore.
References
[1] Archbold, T., De Keijzer, B., Ventre, C.: Non-obvious manipulability for single-parameter agents and
bilateraltrade. In: Proceedings of the 22nd International Conference on Autonomous Agents and Mul-
tiagent Systems (AAMAS 2023) (2023)
[2] Archbold, T., De Keijzer, B., Ventre, C.: Non-obvious manipulability in extensive-form mechanisms:
the revelation principle for single-parameter agents. In: Proceedings of the 32nd International Joint
Conference on Artificial Intelligence (IJCAI 2023) (2023)
[3] Archbold, T., De Keijzer, B., Ventre, C.: Willy wonka mechanisms. In: Proceedings of the 23rd Inter-
national Conference on Autonomous Agents and Multiagent Systems (AAMAS 2024) (2024)
[4] Arribillaga,R., Massó, J., Neme, A.: All sequential allotment rules are obviously strategy-proof(2019)
[5] Arribillaga,R., Massó,J., Neme, A.: Onobviousstrategy-proofnessandsingle-peakedness.JET (2020)
[6] Ashlagi,I.,Gonczarowski,Y.A.: Stablematchingmechanismsarenotobviouslystrategy-proof.Journal
of Economic Theory 177, 405–425(2018)
[7] Ausubel, L.M.: An efficient ascending-bid auction for multiple objects. American Economic Review
94(5), 1452–1475(2004)
[8] Bade,S., Gonczarowski,Y.A.: Gibbard-satterthwaitesuccess storiesandobviousstrategyproofness.In:
Proceedings of the 2017ACM Conference on Economics and Computation. p. 565.EC ’17, Association
for Computing Machinery, New York, NY, USA (2017)
[9] Ferraioli, D., Meier, A., Penna, P., Ventre, C.: On the approximation guarantee of obviously strate-
gyproof mechanisms. arXiv preprint arXiv:1805.04190(2018)
[10] Ferraioli, D., Meier, A., Penna, P., Ventre, C.: Automated optimal OSP mechanisms for set systems
- the case of small domains. In: Web and Internet Economics - 15th International Conference, WINE
2019,New York, NY, USA, December 10-12,2019, Proceedings. pp. 171–185(2019)
[11] Ferraioli,D.,Meier,A.,Penna,P.,Ventre,C.: Obviouslystrategyproofmechanismsformachineschedul-
ing. In: 27th Annual European Symposium on Algorithms, ESA 2019, September 9-11, 2019, Mu-
nich/Garching,Germany. pp. 46:1–46:15(2019)
[12] Ferraioli, D., Meier, A., Penna, P., Ventre, C.: New constructions of obviously strategyproof mecha-
nisms. Mathematics of Operations Research (2022)
[13] Ferraioli,D.,Penna,P.,Ventre,C.: Two-waygreedy: Algorithmsforimperfectrationality.In: Weband
InternetEconomics - 17thInternationalConference,WINE 2021,Potsdam, Germany,December 14-17,
2021,Proceedings. Lecture Notes in Computer Science, vol. 13112,pp. 3–21. Springer (2021)
[14] Ferraioli, D., Ventre, C.: Obvious strategyproofness needs monitoring for good approximations. In:
Thirty-First AAAI Conference on Artificial Intelligence (2017)
[15] Ferraioli, D., Ventre, C.: Obvious strategyproofness, bounded rationality and approximation. Theory
Comput. Syst. 66(3), 696–720 (2022)
28[16] Ferraioli, D., Ventre, C.: Explicit payments for obviously strategyproof mechanisms. In: Proceedings
of the 2023 International Conference on Autonomous Agents and Multiagent Systems, AAMAS 2023,
London, United Kingdom, 29 May 2023 - 2 June 2023.pp. 21257–21336.ACM (2023)
[17] Ferraioli, D., Ventre, C.: On the connection between greedy algorithms and imperfect rationality. In:
EC (2023)
[18] Hausmann,D.,Korte,B.,Jenkyns,T.A.: Worstcaseanalysisofgreedytypealgorithmsforindependence
systems. CombinatorialOptimization pp. 120–131(1980)
[19] Kagel,J.H.,Harstad,R.M.,Levin,D.: Informationimpactandallocationrulesinauctionswithaffiliated
private values: A laboratory study. Econometrica 55(6), 1275–1304(1987)
[20] de Keijzer, B., Kyropoulou, M., Ventre, C.: Obviously strategyproof single-minded combinatorial auc-
tions. In: ICALP. pp. 71:1–71:17(2020)
[21] Kyropoulou, M., Ventre, C.: Obviously strategyproof mechanisms without money for scheduling. In:
Proceedingsofthe 18thInternationalConference onAutonomousAgents andMultiAgent Systems.pp.
1574–1581(2019)
[22] Li,S.: Obviouslystrategy-proofmechanisms.AmericanEconomicReview107(11),3257–87(November
2017)
[23] Mackenzie,A.: Arevelationprinciplefor obviouslystrategy-proofimplementation.ResearchMemoran-
dum 014, Maastricht University, Graduate School of Business and Economics (GSBE) (May 2018)
[24] Mandal, P., Roy, S.: On obviously strategy-proof implementation of fixed priority top trading cycles
with outside options. Economics Letters 211, 110239 (2022)
[25] Nisan, N., Roughgarden, T., Tardos, E., Vazirani, V. (eds.): Algorithmic Game Theory (2017)
[26] Pycia, M., Troyan, P.: Obvious dominance and random priority. In: Proceedings of the 2019 ACM
Conference on Economics and Computation. p. 1. EC ’19, Association for Computing Machinery, New
York, NY, USA (2019)
[27] Pycia, M., Troyan, P.: A theory of simplicity in games and mechanism design. Econometrica 91(4),
1495–1526(2023)
[28] Savage, L.: Foundations of Statistics. John Wiley and Sons (1954)
[29] Thomas,C.: Classificationofprioritiessuchthatdeferredacceptanceisospimplementable.In: EC.pp.
860–860(2021)
[30] Troyan, P.: Obviously strategy-proof implementation of top trading cycles. International Economic
Review 60(3), 1249–1261(2019)
[31] Troyan,P., Morrill, T.: Obvious manipulations. Journal of Economic Theory 185, 104970(2020)
29A On the Definition of k-step Simple Mechanisms
PyciaandTroyan[27]definedtheconceptofk-stepsimplemechanism,thatresemblesourdefinitionofk-step
OSP mechanisms. We here further discuss about similarities and differences among these concepts.
Let us start by describing the concept of k-step simple mechanism. To this aim, we need to define the
conceptofstrategic collections thatconsistinaplanningaboutthe actiontoplayatthecurrentnode,along
to the ones to play at a certain number of nodes following it. In playing a mechanism, the agent defines a
strategic collection for each node in which she interacts with the mechanism. However,the agent is allowed
to choose strategic collections that are not coherent with each other: e.g., the strategic collections selected
fornodeumaystatethatthe agentplayacertainactionatthecurrentnodeandplansthatatthe following
node u′ she will play action a; however, the strategic collection at node u′ may state that instead at the
current node a different action a′ is instead played. In other words, in [27] the plan done at previous node
does not constrain the action taken at the following nodes, while in our definition we will only consider
“coherent” strategic classification,in which what has been planned is actually played. (See also Example 1.)
Notethatthe definitionofPyciaandTroyan[27]leadsto adefinitionofOSP(k-stepsimple mechanisms
for k =∞) that is slightly different fromthe originalone by Li [22], since it is based on strategic collections
in place of strategies: indeed, even if for an ∞-step simple mechanism the dominant strategic collection
is coherent, and hence corresponds to a strategy, this strategy is required to be better even with respect
to non-coherent strategic collections, that do not correspond to strategies (while in Li [22], the dominant
strategy is compared only against strategies).
Moreover,thedefinitionofk-stepsimplemechanismsalsofailstocaptureagradualtransitionfromOSP
to SOSP. This is already observed by Pycia and Troyan [27] about binary allocation problems, for which
they showed that 1-step simplicity is equivalent to OSP. Actually, we observe that this actually occurs for
each problem. Indeed, since each future action is not constrained, then it must be the case that the each
deviation possible in an OSP mechanism is also possible in a k-simple mechanism for each k > 0: in other
words,ifwe try tocompute anequivalentofthe OSPgraph[11] for this mechanism,weendupwith exactly
the same graph.
B An SOSP Mechanism with More than Two Queries
Consider two agents with domain D =D =D ={1,2,3,4}. We would like to implement the socialchoice
1 2
function f =(f ,f ) defined as follows:
1 2
4−t , if t ≥t ;
1 1 2
f (t ,t )=
1 1 2
(4−t 2, otherwise.
and
4−t , if t >t ;
2 2 1
f (t ,t )= 0, if t ≤t and t =4;
2 1 2  2 1 1
4−t 1−1, otherwise.
Let us consider a mechanism M implemented as follows:
• first ask to agent 1 if her type is 4, and if yes, return outcome (0,0), then ask to agent 2 if her type is
4, and if yes, return outcome (0,0);
• for i = 2,3, first ask to agent 1 if her type is 5−i, and if yes, return outcome (i−1,i−2), then ask
to agent 2 if her type is 5−i, and if yes, return outcome (i−1,i−1);
• return outcome (3,2).
It is immediate to check that M implements the social function f and each agent receives 3 queries that
cannotbecompressed. WenextshowthatthismechanismcanbeaugmentedwithpaymentmakingitSOSP.
30Lemma 10. There are payments for which the mechanism M is SOSP.
Proof. Suppose that agent i receives payment 0 whenever her outcome is 0, payment 4 for outcome 1,
payment 7 for outcome 2, and payment 9 for outcome 3.
Considerfirst agent1. Suppose that her type is 1. At the firstquery, if she deviates andanswersyes she
receivesoutcome0 andpayment0, correspondingto utility 0. Ifshe is truthful then either receivesoutcome
0 and payment 0, corresponding to utility 0, or outcome 1 and payment 4 corresponding to utility 3>0, or
outcome 2 and payment 7, corresponding to utility 5 > 0, or outcome 3 and payment 9, corresponding to
utility 6 > 0. Hence, the player has no incentive to deviate. At the second query, deviating and answering
yes, guaranteesutility 3,whereas being truthful will guaranteeutility 3 or 5 or 6, and thus the agenthas no
incentive to deviate. At the third query, deviating and answering yes, guarantees utility 5, whereas being
truthful will guarantee utility 5 or 6, and thus the agent has no incentive to deviate.
Suppose now that agent 1 has type 2. At first query, deviating gives utility 0, while being truthful
guaranteeutility either0,or4−2,or7−4,or9−6. Atthe secondquery,deviatinggivesutility 4−2,while
being truthful guarantee utility either 4−2, or 7−4, or 9−6. At the third query, deviating by answering
no, gives utility either 7−4 or 9−6, but being truthful guarantees the same utility 7−4=3.
Suppose now that agent 1 has type 3. At first query, deviating gives utility 0, while being truthful
guarantee utility either 0, or 4−3, or 7−6, or 9−9. At the second query, deviating by answering no, gives
utility either 4−3 =1, or 7−6 =1 or 9−9 =0, but being truthful guarantees an at least as good utility
4−3=1.
Finally, if agent 1 has type 4. At the first query, deviating by answering no, gives utility either 0 or
4−4=0, or 7−8=−1 or 9−12=−3, but being truthful guarantees an at least as good utility of 0.
The case of agent 2 is symmetric and omitted.
31