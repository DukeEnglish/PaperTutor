Optimal Integrated Task and Path Planning and Its Application to
Multi-Robot Pickup and Delivery
Aman Aryan1, Manan Modi2, Indranil Saha3, Rupak Majumdar4 and Swarup Mohalik5
Abstract—Weproposeagenericmulti-robotplanningmech- thetasklocationswhenarobothastoperformmultipletasks.
anism that combines an optimal task planner and an optimal Thetraversetimebetweendifferentlocationsdependsonthe
path planner to provide a scalable solution for complex multi-
collision-free optimal trajectories of the robots, which can
robot planning problems. The Integrated planner, through the
only be obtained from a multi-robot path planner.
interaction of the task planner and the path planner, produces
optimal collision-free trajectories for the robots. We illustrate Two different approaches are, in general, employed to
our general algorithm on an object pick-and-drop planning solve a multi-robot planning problem offline for a static
problem in a warehouse scenario where a group of robots is environment. In the first approach, the multi-robot task
entrusted with moving objects from one location to another
assignment and the path planning problems are formulated
in the workspace. We solve the task planning problem by
and solved as a monolithic problem (e.g., [1], [2], [3]).
reducing it into an SMT-solving problem and employing the
highlyadvancedSMTsolverZ3tosolveit.Togeneratecollision- In the second approach, the task assignment problem is
free movement of the robots, we extend the state-of-the-art solved based on a heuristic to measure the trajectory lengths
algorithm Conflict Based Search with Precedence Constraints approximately (e.g., [4], [5], [6]). As the task assignment
with several domain-specific constraints. We evaluate our inte-
is not carried out based on collision-free trajectories, a local
grated task and path planner extensively on various instances
collisionavoidancestrategy(e.g.[7])isemployedduringthe
of the object pick-and-drop planning problem and compare
its performance with a state-of-the-art multi-robot classical execution of the plan. The shortcoming of the first approach
planner. Experimental results demonstrate that our planning is that it either fails to provide a multi-robot trajectory with
mechanism can deal with complex planning problems and a guarantee on its optimality [1], or the algorithm that can
outperforms a state-of-the-art classical planner both in terms
produce an optimal plan takes a prohibitively large amount
of computation time and the quality of the generated plan.
oftimetocomputethecollision-freetrajectories[2],[3].The
I. INTRODUCTION second approach can find a plan quickly, but the generated
plansareguaranteedtobeneithercollision-freenoroptimal.
A major component of the software controlling a robotic
To bridge this gap, we design a scalable algorithm to
system is a planner that guides the robots to safely move
generate optimal collision-free trajectories for multi-robot
through their workspace and perform the designated tasks
systems. The proposed algorithm works as follows. It first
appropriately. A planner for an application involving mobile
estimatesthelengthsofthetrajectoriesbetweenalllocations
robots needs to have two components: a task planner that
of interest through which a robot may need to move. Based
decides which tasks should be performed by which robots
ontheestimatedtrajectorylengths,thetaskplannergenerates
and in what order, and a path planner that provides the
a task assignment corresponding to optimal trajectories for
collision-free trajectories to be followed by the robots to
the robots based on the estimated length of the trajectories
reach the locations to perform the tasks. The task planning
between any two locations. The outcome of the task assign-
andthepathplanningproblemscannotbeaddressedentirely
mentisasequenceoflocationstobevisitedbyalltherobots.
independently as the assignment of a task to a robot is
Inthesecondstep,wegeneratecollision-freetrajectoriesfor
directly related to the amount of effort the robot needs to
the robots to reach their designated locations in sequence
invest in reaching the task locations.
by means of an optimal multi-robot path planner. If the cost
Consider a multi-robot application where a group of mo-
of the trajectories obtained in this step is more than that
bile robots is entrusted with the responsibility of delivering
of the trajectories obtained during task assignment, we look
objects from one location to another in a workspace. The
for another same-cost or a sub-optimal task assignment for
task assignment to the robots depends on the time required
which the cost of the collision-free trajectories obtained by
to traverse the distance between the initial locations of the
solvingthemulti-robotpathplanningproblemmaybebetter
robots and various task locations and the distance between
than the collision-free trajectories obtained in the previous
1 Aman Aryan is with IIT Kanpur, India. step. In this way, we alternate between the task planner and
aman.aryan0@gmail.com thepathplanneruntilwefindataskassignmentwithoptimal-
2 Manan Modi is with Jupiter Money, India.
cost collision-free trajectories.
modimanann@gmail.com
3 Indranil Saha is with IIT Kanpur, India. We illustrate our general algorithm on an offline multi-
isaha@cse.iitk.ac.in agent pick-and-drop planning problem in a warehouse sce-
4 Rupak Majumdar is with MPI-SWS, Germany. nariowhereagroupofrobotsmoveobjectsfromonelocation
rupak@mpi-sws.org
toanotherintheworkspace.Ourproblemstatementissimilar
5 Swarup Mohalik is with Ericson Research, India.
swarup.kumar.mohalik@ericsson.com to[8]exceptthatwehavedefinedadesignatedbaselocation
4202
raM
2
]OR.sc[
1v77210.3042:viXraforrobotstoreturnafterfinishingthetasks.Wetransformthe and stay. However, our methodology seamlessly applies
task-planningproblem intoanSMT-solvingproblem thatin- to any complex set of motion primitives for a robot. The
corporates many application-specific operational constraints action primitives for a robot are application-specific. For
andsolveitusingtheZ3[9]solver.Additionally,weemploy example,forapick-and-dropapplication,therobothasaction
the existing optimal multi-robot path planning algorithm primitives for picking up and dropping off an object. We
MLA*-CBS-PC [10] to accommodate the sequential goal assume that all of these primitives take a one-time step
locations for each robot, thereby serving as the optimal path regardlessoftherobot’sdirection.Moreover,themotionand
planner. action primitives are deterministic, i.e., the application of a
We have evaluated our algorithm extensively on various primitive to a robot in a state moves the robot to a unique
instances of the object pick-and-drop planning problem and next state. We denote by attributes a set of attributes of
i
compared the performance of our planner with a state-of- robot r that may be required depending upon the nature of
i
the-art multi-robot classical planner. Experimental results the problem. For example, in a pick-and-drop example, an
demonstrate that our planning mechanism can deal with attribute for a robot could be the number of objects or the
complex planning problems and outperform the state-of-the- total amount of weight the robot can carry at once.
art classical planner ENHSP in terms of computation time 3) Tasks: The set of tasks associated with a problem
and quality of the generated plan. is denoted by T. A task t ∈ T is defined as a tuple
i
In summary, we make the following contributions. ⟨L,attributes⟩.Here,L isasequenceoflocationsthatneed
i i i
• We provide a general multi-robot planning algorithm to be visited by a robot in the same order to complete the
that induces an interaction between the task planner task. We denote by attributes i a set of attributes of the task
and the path planner to generate optimal collision-free thatmayberequiredforplanningdependinguponthenature
trajectories for the robots to enable them to complete of the problem. For example, a task t i may be associated
the mission successfully (Section III). with a deadline d i; in that case, the last location in L i must
• We provide an SMT-based task planner for object pick- be visited before d i.
and-dropapplicationsinawarehousescenario.Ourtask 4) Plan and Trajectory: We capture the behaviour of a
plannerisgeneralenoughtobeabletoincorporatemany robot in the workspace as a sequence of states. The state of
application-specificoperationalconstraints(SectionIV). robot r i at time step t is denoted by σ i(t). Given a state σ
• We adapt the state-of-the-art graph-based multi-robot and a motion or action primitive ν, the robot’s next state σ′
path planner MLA*-CBS-PC [10] to deal with a se- is given by next(σ,ν).
quence of goal locations for each robot (Section IV-C) Definition 1 (Plan): The plan for a robot r i is the se-
using plans generated from our task planner. quence of motion and action primitives executed by the
• We demonstrate the overall algorithm for multi-agent robot.
pickup and delivery application on predefined as well Definition 2 (Trajectory): For robot r i with plan ν i =
as randomly generated maps for various scenarios (ν i(1),ν i(2),...ν i(T i)), the trajectory is given by σ i =
and compare it to the state-of-the-art classical planner (σ i(0),σ i(1),...,σ i(T i)), where σ i(0)=s i and for all
ENHSP. i∈{1,...,T i}. σ i(j)=next(σ i(j−1),ν i(j)). The symbol
T denotes the length of the plan ν and the trajectory σ.
i i i
II. PROBLEM The trajectory of the multi-robot system R ={r ,...,r }
1 n
In this section, we define our problem formally and is denoted by Σ = [σ ,σ ,...,σ ], where σ denotes the
1 2 n i
illustrate it with an example. trajectory of robot r.
i
5) Optimality Criteria for a Trajectory: The cost of
A. Preliminaries
executing a trajectory σ =(σ(0),σ(1),...,σ(T)) is equal
i i i i i
1) Workspace: The workspace, denoted by W, is repre- to its length T. Now, the quality of a multi-robot trajectory
i
sented as a 2-D rectangular grid. We assume that the robots, Σ is captured by one of the following two attributes.
as well as the task objects, occupy one grid block each Definition 3 (Makespan): The makespan of the trajecto-
at any time instance. Obstacles may occupy some of these ries Σ=[σ ,σ ,...,σ ] is given byC=maxT.
1 2 n i
grid blocks and thus cannot be used by the robots, tasks, i
Definition 4 (Total cost): Thetotalcostofthetrajectories
or movement. Formally, the workspace is represented by a
tuple ⟨L ,L ,Ω⟩, where L and L denote the length and
Σ=[σ 1,σ 2,...,σ n] is given byC=∑T i.
X Y X Y i
the width of the workspace, and Ω denotes the set of grid Notethatthemakespanandtotalcostareequalforasingle
blocks that are occupied by obstacles. robot system. We will use the terms plan and trajectory
2) Robots: The set of robots is denoted by R. Each interchangeably to denote the solution from our algorithm.
robot r ∈R is defined as a tuple ⟨s,Γ,Λ,attributes⟩. The
i i i i i
B. Problem Definition
symbol s denotes the start location of robot r. The symbols
i i
Γ and Λ denote the set of motion primitives and action Here, we provide the formal definition of the problem.
i i
primitives for robot r, respectively. To keep the exposition Definition 5 (Problem): Given a workspace W, a set of
i
simple, we assume that each robot has five basic motion tasks T, and a set of robots R, find optimal makespan or
primitives: move up, move down, move left, move right, optimal total cost collision-free trajectories Σ for the robotstime r r
1 2
0 (Start, (0, 0)) (Start, (7, 3))
1 (Move, (1, 0)) (Move, (7, 2))
2 (Move, (1, 1)) (Move, (7, 1))
3 (Move, (1, 2)) (Move, (6, 1))
4 (Move, (1, 3)) (Move, (5, 1))
5 (Move, (1, 4)) (Move, (4, 1))
6 (Move, (1, 5)) (Move, (3, 1))
Fig.1. Examplesofworkspacesshowingwarehousescenariosa)without
IntermediateLocation,b)withanIntermediateLocation. 7 (Move, (1, 6)) (Move, (2, 1))
8 (Pick , (1, 6)) (Move, (1, 1))
2
9 (Move, (0, 6)) (Move, (0, 1))
suchthatalltasksarecompletedwhilealsoensuringthatthe 10 (Move, (0, 5)) (Pick 1, (0, 1))
robots return to their initial positions. 11 (Move, (0, 4)) (Move, (1, 1))
12 (Move, (0, 3)) (Move, (2, 1))
Example.ConsidertheworkspacesshowninFigure1.They
13 (Drop , (0, 3)) (Move, (3, 1))
represent typical warehouse scenarios. Boxes in the images 2
14 (Move, (0, 2)) (Move, (4, 1))
denote the pickup locations for these objects. The blue grid
15 (Move, (0, 1)) (Move, (5, 1))
locationsdenotetheirdroplocations.Thegrey-colouredgrid
16 (Return, (0, 0)) (Move, (6, 1))
blocks are occupied by obstacles and must be avoided. In
17 (−−−, (0, 0)) (Move, (7, 1))
the figure, the robots are shown in their initial locations.
18 (−−−, (0, 0)) (Move, (7, 2))
The robots can carry multiple objects at a time. To pick up
19 (−−−, (0, 0)) (Move, (7, 3))
an object, a robot needs to be in the grid block where the
20 (−−−, (0, 0)) (Move, (7, 4))
objectisplaced.Thesameistruefordroppinganobject.The
21 (−−−, (0, 0)) (Move, (7, 5))
problemistofindthetaskassignmenttotherobotstodecide
22 (−−−, (0, 0)) (Move, (7, 6))
which robot should carry which object to its goal location
23 (−−−, (0, 0)) (Drop , (7, 6))
and the collision-free trajectories for the robots to carry out 1
24 (−−−, (0, 0)) (Move, (7, 5))
their tasks successfully.
25 (−−−, (0, 0)) (Move, (7, 4))
In Figure 1a, there are 4 objects that need to be moved
26 (−−−, (0, 0)) (Return, (7, 3))
to some specific goal locations. Three robots r , r and r
1 2 3
have to move the four objects from their current locations to Fig.2. TrajectoriesofthetworobotsfortheproblemshowninFigure1(a)
their goal locations. In Figure 1b, the yellow block denotes
the intermediate drop block. A robot can drop an object on
theyellowblock,andtheobjectcanbepickedupfromthere III. INTEGRATEDTASKANDPATHPLANNING
by another robot. Thus, having an intermediate block allows ALGORITHM
the robots to collaborate on delivering a specific object. Inthissection,weprovideanalgorithmtosolvetheprob-
In the scenario presented in Figure II-B, let us attempt to lemdescribedinSectionII.Onecouldreducetheproblemto
findtheplanwithoptimalmakespan.Thecollision-freeplan an Integer-Linear Programming or an SMT-solving problem
without the intermediate drop would be r 1 completing task andgenerateasolutionforthetaskassignmentaswellasthe
t 2 and returning to its base location in 16 steps and r 2 trajectoriesfortherobots.However,thismonolithicapproach
completing t 1 and returning to its base location in 26 steps. rarely scales up with the number of robots, the number of
Sothemakespanofthisplanbecomes26. Thecollision-free tasks, and the size of the workspace. Instead, we embrace a
trajectoryforthetworobotsr 1 andr 2 areshowninFigure2. decoupled approach where the task and the path planning
Ifweallowtherobotstousetheintermediateblockforobject problems are solved independently. However, through an
transfer, r 1 can pick up t 1 and drop it to the intermediate interaction between the task and the path planner, we ensure
block; then it can continue to pick and drop t 2 and return that the finally generated plans satisfy the task completion
to its base location in 24 steps. But this reduces the time requirement and that the corresponding paths are collision-
taken by r 2 to process t 1. Now, r 2 can pick up t 1 from the free and optimal.
intermediate location, drop it to its drop location, and come Our proposed methodology is shown in Algorithm 1. We
backtoitsbasestation.Executionofthisplantakes21steps advocate the use of an SMT solver to solve complex task
tocomplete,thusmakingtheoverallmakespan24.Sincewe assignment problems. The procedure TASK PLANNER takes
optimize the makespan, the total cost metric may increase. W, R, T, a set A of forbidden task assignments, a lower
In this scenario, the total cost increases from 42 to 45. The bound l b, and an upper bound u b as inputs. It produces
trajectories for both of the robots are shown in Figure 3. as output a task assignment L =[L 1,L 2,...,L |R|], with
Thus, intermediate locations help in finding a better plan minimum total cost or makespan within specified bounds.
forouroptimizationcriteria,andourgoalwouldbetodesign It returns 0/ if there does not exist a feasible task assign-
a planner that can efficiently exploit the availability of such ment within the bounds. Here, L denotes the sequence of
i
opportunities. locations that robot r must visit. In Section IV, we will
itime r r Algorithm1IntegratedPlannerusingTaskandPathPlanner
1 2
1: procedure TASK PLANNER(W, R, T, A, l b, u b)
0 (Start, (0, 0)) (Start, (7, 3))
2: //findoptimaltaskassignmentsusingaheuristiccost
1 (Move, (0, 1)) (Move, (7, 4))
for movements.
2 (Pick , (0, 1)) (Move, (6, 4))
1 3: return ⟨L,task cost⟩
3 (Move, (0, 2)) (Move, (5, 4))
4: end procedure
4 (Move, (1, 2)) (Move, (4, 4))
5 (Move, (1, 3)) (Move, (4, 4)) 5: procedure PATH PLANNER(W, R, L)
6 (Move, (1, 4)) (Move, (4, 4)) 6: // find the optimal collision-free trajectories for
7 (Move, (2, 4)) (Move, (4, 4)) robots following the given task assignments in L.
8 (Move, (3, 4)) (Move, (4, 4)) 7: return ⟨plan,plan cost⟩
9 (Move, (4, 4)) (Move, (5, 4)) 8: end procedure
10 (InterDrop , (4, 4)) (Move, (5, 4))
1 9: procedure INTEGRATED PLANNER(W, R, T)
11 (Move, (3, 4)) (Move, (4, 4))
10: cur task cost←0; opt plan cost←∞
12 (Move, (2, 4)) (InterPick , (4, 4))
1 11: opt plan←0/; A ←0/
13 (Move, (1, 4)) (Move, (5, 4))
12: while cur task cost<opt plan cost do
14 (Move, (1, 5)) (Move, (6, 4))
13: ⟨L,task cost⟩ ← TASK PLANNER (W, R, T,
15 (Move, (1, 6)) (Move, (7, 4))
A, cur task cost, opt plan cost)
16 (Pick , (1, 6)) (Move, (7, 5))
2 14: if L == 0/ then
17 (Move, (0, 6)) (Move, (7, 6))
15: break
18 (Move, (0, 5)) (Drop , (7, 6))
1 16: end if
19 (Move, (0, 4)) (Move, (7, 5))
17: ⟨plan,plan cost⟩←PATH PLANNER(W,R,L)
20 (Move, (0, 3)) (Move, (7, 4))
18: if (cur task cost<task cost) then
21 (Drop , (0, 3)) (Return, (7, 3))
2 19: cur task cost←task cost
22 (Move, (0, 2)) (−−−, (7, 3))
20: A ←0/
23 (Move, (0, 1)) (−−−, (7, 3))
21: end if
24 (Return, (0, 0)) (−−−, (7, 3))
22:
A ←A ∪{L}
Fig.3. TrajectoriesofthetworobotsfortheproblemshowninFigure1(b) 23: if (plan cost<opt plan cost) then
24: opt plan←plan
25: opt plan cost←plan cost
present the details of the task planner with an example of a 26: end if
warehouse pick-and-drop application. 27: end while
The following procedure PATH PLANNER takes the task 28: return ⟨opt plan,opt plan cost⟩
assignment L produced by the TASK PLANNER procedure 29: end procedure
and generates optimal and collision-free trajectories. The
procedurealsoreturnsthetrajectory’stotalcostormakespan
depending upon the optimization criterion. In Section IV-C,
cost of movements between important locations. If the task
we will present the details of the path planner.
planner cannot produce a plan (returns 0/), we terminate the
The main procedure INTEGRATED PLANNER induces an loop. Otherwise, for this task assignment L, we invoke the
interaction between the task planner and the path planner
PATH PLANNER, which outputs the collision-free trajectory
to find the optimal collision-free trajectories for the robots.
with cost plan cost. If we find that the new task assignment
There could be several task assignments with the same cost.
L has a higher cost compared to cur task cost, then we
Thus, once a task assignment L is produced by the task
updatecur task cost withtask cost andresettheexclusion’s
planner, we need to ensure that the task planner does not
listA.WeaddthistaskassignmentL totheA.Weupdate
generate the same task assignment again. We use the set A
the opt plan and opt plan cost if the current trajectory has
for this purpose. We keep on storing the task assignments
a better cost.
with the same cost in A and provide it as the set of
Now, we formally prove that Algorithm 1 produces the
prohibited assignments while invoking the task planner with
optimal trajectories satisfying the task requirements.
the same lower bound of the cost. This set is initialized
as an empty set. We initialize cur task cost (denoting the Theorem 1 (Optimality): There does not exist a task as-
cost of the current task assignment) as 0 and opt plan cost signment for which the cost of the collision-free trajectories
(denoting the minimum cost of the collision-free paths for would be less than the cost of the trajectories returned by
any assignment) as ∞ and repeat the procedure below until Algorithm 1.
cur task cost becomes equal to opt plan cost. We invoke Proof: LetusassumethatAlgorithm1returnscollision-
the TASK PLANNER with the cur task cost as lower bound free trajectories for the robots with cost C for a task as-
and opt plan cost as upper bound to get the best task signment L. The heuristic cost for the assignment is C .
h
assignment L with cost task cost based on some heuristic Now, let us assume that there exists a task assignment L′for which the cost of the collision-free trajectories is C′ Algorithm 2 Task Planner
where C′<C, but this task assignment was not considered 1: procedure TASK PLANNER(W, R, T, A, l b, u b)
by Algorithm 1. The heuristic cost for the assignment L′ is 2: S ←generate smt instance (W, R, T, A)
C′. As heuristic cost must always be a lower bound for the 3: if S.check() ̸= SAT then
h
cost of the collision-free trajectories, C h ≤C and C h′ ≤C′. 4: return 0/
Then either (I)C h′ <C h or (II)C h≤C h′. 5: end if
Case I: In this case, L′ must have been considered by 6: while (l b≤u b) do
the planner before L as the task planner returns the task 7: S′←S
assignment with the minimum possible heuristic cost. 8: mid←(l b+u b)/2
CaseII: AsC′ ≤C′ andC′<C,thereforeC′ <C.In this 9: S ←S ∧(cost≥l b)
case, the plannerh must have considered L′ afth er generating 10: S ←S ∧(cost≤mid)
collision-free trajectories for L as C′ <C and C ≤C′. 11: if S.check() = SAT then
Our Integrated Planner explores all tah sk assignmenh ts with h 12: u b←S.get(cost)−1
heuristic costs less thanC. 13: else
Thus, in both cases, our assumption that Algorithm 1 14: l b←mid+1
did not consider L′ is wrong. Hence, if the heuristic cost 15: end if
considered in the task planning procedure gives a lower 16:
S ←S′
bound on cost and the Path Planner gives the minimum cost 17: end while
collision-free paths corresponding to the task assignment, 18: L ←S.get(task assignment)
then the integrated planner will always generate collision- 19:
cost←S.get(cost)
free trajectories for the robots with optimal cost. 20: return ⟨L,cost⟩
Note: As the number of task assignments is finite for a 21: end procedure
well-formed MAPD instance, the optimality of Algorithm 1
establishes its completeness as well.
r : pickup−1, drop−1
1
Example. We illustrate the algorithm on the example in-
r : pickup−2, drop−2
2
troduced in Figure 1a in Section II with makespan as
r : pickup−4, pickup−3 drop−3 drop−4
3
optimizationcriteria. Here,weuse A*search algorithm[11]
Themakespanoftheabovetaskassignmentis18.Thepath
to find a trajectory for a robot between two locations. In the
plannerreturnsaplanwithamakespanof19,thesameasthe
belowtaskassignments,pickuprepresentsmoveandpickup.
previouslyfoundplan’smakespan.Wecontinuesearchingfor
Similarly, the drop represents move and drop. Since there is
task assignments. The third assignment that we obtain also
no intermediate location, all pickups are the boxes’ initial
has a makespan of 18. It is as follows:
locations, and drops are their respective drop locations. The
r : pickup−1, drop−1
minimum makespan returned by the task planner is 18, and 1
r : pickup−2, pickup−3, drop−2, drop−3
the corresponding task assignment is as follows: 2
r : pickup−4, drop−4
3
r : pickup−1, drop−1
1 The above task assignment differs slightly from the first
r : pickup−2, pickup−3, drop−3, drop−2
2 assignment, in which r drops object-2 before dropping
r : pickup−4, drop−4 2
3 object-3. The estimated cost returned by the task planner
In the above task assignment, r 1 starts from grid location for r , r , and r is 16, 18, and 12, respectively. Executing
1 2 3
(8, 4), visits the grid location (4, 3) to pick up object-1
thepathplannerwiththistaskassignmentreturnsacollision-
and then visits grid location (7, 6) to drop object-1 and
freetrajectorywithcostsof18,18,and12,respectively,thus
then finally return to grid location (8, 4). The distances
making the makespan 18. So, this collision-free trajectory
computed by the A* algorithm for these movements are 5,
becomestheminimumcollision-freetrajectory,andthemin-
6, and 3, respectively. Also, r spends two units of time
1 imum cost is updated to 18. As the collision-free cost is not
step to pick and drop the object, thus making the total time
greater than the estimated cost, we terminate the algorithm.
steps 16. Similarly, the cost for robots r and r are 18 and
2 3
12, respectively. Therefore, the effective makespan of the IV. APPLICATIONSTOWAREHOUSEMANAGEMENT
plan is 18. This heuristic cost is generated by calculating In this section, we illustrate our planning mechanism for
the costs individually without considering the robot-robot theobjectpick-and-dropapplicationinawarehousescenario,
collisions. Using the task assignment, we compute collision- as shown in Figure 1. As the tasks are pick-and-drop, L for
i
free trajectory using the path planner. The cost of collision- each task t contains two entries: L(0) denotes the pickup
i i
free trajectories the path planner returns is 19, 18, and 17, location and L(1) represents the drop location.
i
respectively. So, the overall makespan becomes 19. Since
A. Task Planning Algorithm
the estimated task assignment cost is 18 and the collision-
free cost is 19, there may be some plans with a cost of 18, The overall SMT-based task planning algorithm is shown
resultinginamakespanlessthan19.So,wecontinuetofind inAlgorithm2.Thegenerate smt instancefunctiongen-
more plans and obtain the next task assignment as follows: erates the SMT constraints for the task planner. We usethe notion of action-step in our SMT formulation. In each constraints formulation is as mentioned below.
action step, all the robots can perform an action related to
pick(r,t ,j)≡
movement,pickup,ordrop.Inourconstraints,wekeeptrack i m
of the time taken for each action step for each robot. There loc m,j−1=L m(0) (2a)
is no constraint on how long these actions can take here; ∧ pos =L (0) ∧being carried =i (2b)
i,j m m,j
we do not generate the final paths but rather just the task
∧ pos time =pos time +
i,j i,j−1
assignment. The time required for an action that requires
a movement from location x to location x′ is captured by dist(pos i,j−1,L m(0))+1 (2c)
dist(x,x′), as we assume a movement from one grid cell ∧ loc m,j=−1 ∧action i,j=m (2d)
to another takes one unit of time. We compute dist(x,x′)
Equation 2(a) captures that task t is at location L (0) in
using the A* search algorithm [11], which is guaranteed to m m
the j−1 action-step. Equation 2(b) captures that robot r is
be an under-approximation of the distance between x and x′ i
at location L (0) in action-step j and the object for task t
whilecomputingthecollision-freetrajectoriesfortherobots. m m
is being carried by robot r in action-step j. Equation 2(c)
For a task assignment problem, the number of action steps i
captures the time taken by robot r while moving from its
is denoted by Z, which is the same for all the robots. i
locationinthepreviousaction-step pos toitslocationin
i,j−1
thecurrentaction-stepL (0)andoneunitoftimeforpicking
m
up the task t by r. Equation 2(d) ensures that loc is set
m i m,j
B. SMT Encodings Of Constraints
to −1 as an object for task t is being carried by a robot
m
now and sets action as m to indicate pickup of the object
In this section, we describe the constraints in detail to i,j
t by robot r in action-step j.
capture two variants of the pick-and-drop problem. m i
Similarly,arobotcangotooneofthedroplocationsonly
1) Completing pick-and-drop tasks: Here, we present the if it drops an object there. If r wants to drop an object to
i
SMT constraints to capture the basic object pick-and-drop oneofthedroplocationsinaction-step j,thentheconstraints
problem as illustrated in Figure 1. We define LOC as a set
formulation is as below.
of all the task’s pickup and drop locations. Thus, LOC =
(cid:83) {L m(0),L m(1)}. drop(r i,t m,j)≡
tm∈T
being carried =i (3a)
The following are the variables used to track the state of m,j−1
∧ pos =L (1) ∧being carried =−1 (3b)
the system. i,j m m,j
∧ pos time =pos time +
• pos i,jdenotesthelocationofrobotr iafterthe jthaction- i,j i,j−1
dist(pos ,L (1))+1 (3c)
step. This location can be one of the locations from the i,j−1 m
sets LOC and s
i
for all j≥1. ∧ loc m,j=L m(1) ∧action i,j=m (3d)
• pos time i,j denotes the time step at which robot r i is at
Equation 3(a) captures that task t must be carried by
location pos in the jth action-step. m
i,j
robot r in action-step j−1 to be able to drop it in action-
• action i,j denotes on which task’s object r i will perform i
step j. Equation 3(b) captures that robot r is at location
action in the jth action-step. The value of the variable i
L (1) in action-step j and changes being carried to −1
can be either −1 if no action is performed or the task m m,j
as the object will be dropped. Equation 3(c) captures the
number.
time taken by robot r while moving from its location in the
• loc i,j denotes the location of task t i in the jth action- i
previous action-step pos to its location in the current
step.ThislocationcanbeeitherL(0)orL(1),oritcan i,j−1
i i
action-step L (1) and one unit of time to drop the task t
be −1 in case the task object is being carried by some m m
by r. Equation 3(d) set loc to indicate that the object for
robot. i m,j
taskt has been dropped at its final location in action-step j
• being carried i,j denotes by which robot the object of m
and action to m to indicate dropping of the object for task
taskt is being carried in the jth action-step. It is either i,j
i
t by robot r in action-step j.
the identifier of the robot if the task is in transition or m i
A robot can also do nothing for one action step, which is
−1 if it is steady.
captured as follows.
Theinitialstateofthesystemiscapturedbythefollowing
stay(r,j)≡ pos =pos ∧ action =−1
constraints. i i,j i,j−1 i,j
∧ pos time =pos time (4)
i,j i,j−1
∀r i∈R, pos i,0=s i∧ pos time i,0=0 ∧ action i,0=−1 A robot can also return to the base station from a drop
∀t ∈T, loc =L(0) ∧ being carried =−1 (1) location if it is no longer required to do more tasks.
i i,0 i i,0
return(r,j)≡
i
A robot can go to L (0) only if it picks up the object of
m pos =s ∧ action =−1 ∧ (5a)
task t from there. If robot r wants to pick up an object i,j i i,j
m i
pos time =pos time +dist(pos ,s) (5b)
from one of the pickup locations in action step j, then the i,j i,j−1 i,j−1 iEquation5(a)capturesthattherobotr isatbasestations at To accommodate the intermediate locations in I in our
i i
action-step j. Equation 5(b) captures the time taken by robot constraints we update LOC as follows:
r while moving from its location in the previous action-step
i
pos to its base station in the current action-step.
i,j−1 (cid:18) (cid:19) (cid:18) (cid:19)
Combining Equations (2) - (5), for each robot r i for each LOC= (cid:91) {L m(0),L m(1)} ∪ (cid:91) {i n}
possible action-step j, we get the constraint below: tm∈T in∈I
(cid:94) (cid:94)Z (cid:18) (cid:95) (cid:16)
stay(r,j) ∨ (pos =k) ∧
i i,j−1
Constraints formulation for r picking up one of the task
ri∈Rj=1
(cid:95) (cid:0)
k∈{si}∪LOC
(cid:1)(cid:17)(cid:19) objects from one of the
intermei
diate blocks in action step j
return(r,j) pick(r,t ,j) ∨drop(r,t ,j) (6) is as below in Equation (9) and (10).
i i m i m
tm∈T
Wenowaddtheconstraintstoenforcethatthetaskobjects pick intermediate(r,t ,i ,j)≡
i m n
move only when being carried by one of the robots.
loc =i (9a)
m,j−1 n
Z ∧ loc time ≤pos time +
(cid:94) (cid:94)(cid:0) (cid:94) (cid:1) m,j−1 i,j−1
action ̸=m =⇒ (loc =loc
i,j m,j m,j−1 dist(pos ,i )+1 (9b)
tm∈T j=1 ri∈R i,j−1 n
∧ pos =i ∧being carried =i (9c)
∧being carried =being carried ) (7) i,j n m,j
m,j m,j−1
∧ pos time =pos time +
i,j i,j−1
Equation 7 ensures that if no robot is performing an action
dist(pos ,i )+1 (9d)
i,j−1 n
ontaskt ,thent ’slocationandbeingcarriedstatusremain
m m
∧ loc =−1 ∧loc time =−1 (9e)
thesame.Notethatonlypickingupordroppingisclassified m,j m,j
as performing an action. A robot carrying a task’s object ∧ action i,j=m (9f)
does not mean that he is performing an action on that task.
(cid:94)
(loc =L (1)) (8)
m,Z m
tm∈T Equation (9) is similar to Equation (2) except the extra
constraintinEquation9(b),whichensuresthatthetaskobject
Equation (8) ensures that each task object is at its goal
isatthelocationbeforetherobotreachestheretopickitup.
location in the last action step.
The final set of constraints is obtained as the conjunction
of constraints capturing the initial states and those in Equa-
tions (1), (6), (7) and (8).
wait intermediate(r,t ,i ,j)≡
i m n
2) Enabling collaboration: In this subsection, we present
loc =i (10a)
the additional set of constraints that enables collaboration m,j−1 n
among the robots with the help of intermediate locations, as ∧ loc time m,j−1>pos time i,j−1+
illustrated in Figure 1b. dist(pos ,i )+1 (10b)
i,j−1 n
A robot can visit one of the intermediate blocks to either
∧ pos =i ∧being carried =i (10c)
i,j n m,j
pick up or drop off an object. While picking up from an
∧ pos time =loc time +2 (10d)
intermediate block, a validation of the timing consistency i,j m,j−1
between the drop-off and pick-up of an object is required. ∧ loc m,j=−1 ∧loc time m,j=−1 (10e)
We introduce new SMT variables named loc time i,j to add ∧ action i,j=m (10f)
this ability.
• loc time i,j denotesthetimestepatwhichtaskt i willbe
available at loc at the jth action-step. It is −1 if the
i,j
task object is in transition. Equation(10)issimilartoEquation(2)exceptthechanges
in Equation 10(b) and Equation 10(d). Equation 10(b) en-
Assume that a robot r dropped the object of taskt at lo-
1 l
sures that this is the case where the robot has reached
cationi inactionstep jwithloc time =20.Now,suppose
1 l,j
the location before the task object. Equation 10(d) sets the
another robot r , which has been idle for all the action steps
2
pos time tothetimeatwhichthetaskobjectcanbepicked
uptostep j+1,goestopickupthisobject.So, pos =i , i,j
2,j+1 1
upbytherobot.Afterarobotdropsthetaskatloc time
but it is possible that pos time +dist(pos ,i )<20. So m,j−1
2,j 2,j 1
time,anyotherrobotwilltakeatleast1unitoftimetoreach
even though r will go to pick up the object at a later action
2
that location and 1 more unit to pick up the task from the
step,itwillreachthelocationbeforethetaskobjectisavail-
intermediate location.
ablethere.Thus,inourconstraints,weneedtoaccommodate
thispossibilityintothecomputationof pos timeastheaction Constraints formulation for r dropping one of the task
i
will be completed only when the pickup is done. objects it carries to one of the intermediate blocks in actionstep j is shown below. constraints involving a drop operation (Equation (3), (11)),
we add:
drop intermediate(r,t ,i ,j)≡
i m n
capacity =capacity +weight (14)
being carried =i (11a) i,j i,j−1 l
m,j−1
∧ pos =n ∧being carried =−1 (11b) This updates the weight-carrying capacity of the robot after
i,j m,j
dropping.
∧ pos time =pos time +
i,j i,j−1
Deadline constraints. We can also add a specific deadline
dist(pos ,i )+1 (11c)
i,j−1 n deadline toeachtaskt byaddingthefollowingconstraint
m m
∧ loc m,j=n ∧action i,j=m (11d) for each task in Equation (8). This constraint is related to
∧ loc time =pos time (11e) time, so it needs to be handled in Task Planner as well as
m,j i,j
Path Planner.
Equation (11) is similar to Equation (3) as dropping at the
intermediatelocationissimilartodroppingatthetask’sgoal loc time m,Z ≤deadline m. (15)
location.
4) Exclusion: We provide a way to add an already found
Moreover, We need to add constraints to update loc time task assignment A as an exclusion to the SMT planner so
in Equation (2), (3) and (7). Finally, we have to change
that the task planner finds the best solution excluding the
Equation (6) to
already found assignments. Let POS be the position of
i,j
(cid:94) (cid:94)Z (cid:18) (cid:95) (cid:16) robot r i and action step j in the existing solution.
stay(r,j) ∨ (pos =k) ∧
i i,j−1 (cid:95) (cid:0) (cid:95) (cid:1)
(pos ̸=POS ) (16)
ri∈Rj=1 k∈{si}∪LOC i,j i,j
(cid:0)
return(r,j) ∨
ri∈R j∈Z
i
(cid:95) (cid:0) To add the existing solution as an exclusion, we have added
pick(r,t ,j) ∨drop(r,t ,j) ∨
i m i m Equation 16 to the set of constraints in the SMT solver.
tm∈T
5) Objective function: We present the two cost functions
(cid:95)
(pick intermediate(r i,t m,i n,j) ∨ related to the total cost and makespan of the trajectories.
in∈I
1) TotalCost:Here,weminimizethetotalworkdoneby
wait intermediate(r,t ,i ,j) ∨
i m n all the robots.
(cid:1)(cid:17)(cid:19)
drop intermediate(r i,t m,i n,j) ) (12) minimize ( ∑ pos time i,Z)
ri∈R
The final set of constraints is obtained as the conjunction of
2) Makespan: Here, we minimize the time required to
constraints capturing the initial states and those in Equation
complete the mission.
(12), (7) and (8).
3) Other operational constraints: In our task planning minimize (max pos time i,Z)
framework, we can easily add other operational constraints.
ri∈R
The constraints can be mainly of two types based on their The value of Z must be set such that it satisfies the
association with time. If the constraint is associated with condition Z ≥ 1+⌈|T|/|R|⌉∗2 for the problem to be
time, e.g., deadline, we need to handle the constraint in solvable. To search through all possible task assignments
Task Planner as well as Path Planner. However, constraints ignoring load balancing among robots, Z≥1+|T|∗2.
like capacity are not related to time and can be handled The task planner uses a binary search algorithm to opti-
through Task Planner only. We have added two constraints mize the cost function guided by the SMT constraints. Note
to demonstrate both types. that modern SMT solvers like Z3 [9] provide a mechanism
Capacity constraints. We can assign specific weights to to solve a minimization problem directly within the solver.
taskobjectsandspecificweight-carryingcapacitiestorobots. However, our experience shows that attempting to solve an
This constraint is independent of time, so it needs to be optimization problem directly using an SMT solver often
handled in Task Planner only. Let the variable capacity fails to succeed within a reasonable time. In contrast, the
i,j
denote the weight carrying capacity of robot r in action- binary search-based optimization method can successfully
i
step j and weight denote a constant weight of object for produce the result within a bound.
l
task t. Now, we add the following constraint to all the sets
l C. Path Planning
of constraints involving a pickup:
Forthepathplanner,weadopttheCBS-PCalgorithm[10]
capacity ≥weight ∧ for multi-agent pathfinding for precedence-constrained goal
i,j−1 l
capacity =capacity −weight (13) sequences. CBS-PC uses Multi-Label A* [12] as its low-
i,j i,j−1 l
level planner. Multi-Label A* can find optimal paths for a
This checks for weight satisfiability before assigning a task sequence of goal locations. As we deal with intermediate
to the robot and updates the weight-carrying capacity of dropsandpickups,theintermediatepickupmustbeexecuted
the robot after picking it up. Similarly, for all the set of after the intermediate drop for the same task. This is takenFig. 5. Task Planner : The effect of increasing the number of robots
(showninlegends)andthenumberoftasksfortaskplannerwithmakespan
optimizationcriteriaona)ComputationTime(left)andb)Makespan(right)
Fig.4. Predefined(left)andRandomlygenerated(right)50x50map
care of by the precedence constraints presented in the algo-
rithm. We also introduce the following enhancements to the
basic CBS-PC algorithm: (i) makespan optimization criteria
along with the sum of total costs, (ii) inclusion of deadlines
support for goals and checkpoints, and (iii) handling empty
goalsasthetaskplannermaynotassigntaskstosomerobots.
V. EVALUATION Fig.6. TaskPlanner:Theeffectofincreasingthenumberofrobots(leg-
ends)andthenumberoftasksfortaskplannerwithtotalcostoptimization
We evaluate our planning methodology on various in-
criteriaona)ComputationTime(left)andb)TotalCost(right)
stances of warehouse pick-and-drop application scenarios.
A. Experimental Setup
For all our experiments, we use a desktop computer with obtained by executing the planner on ten problem instances
an i7-4770 processor with a 3.90GHz frequency and 12GB each.
of memory. We use Z3 SMT solver [9] from Microsoft 1) TaskPlanningwithoutcollaboration: Weevaluatedour
Research to solve task-planning problems. For MA*-CBS- task planner for varying number of robots and tasks with
PC, we adapt the C++ code provided by [10] with appropri- our optimization criteria. We employ a 20×20 workspace
ate modifications. The source code of our implementation for these evaluations with the minimum satisfiable Z for
is available at https://github.com/iitkcpslab/ each number of robots and the tasks pair. Figure 5a shows
Opt-ITPP. how the computation time varies with the increase in the
For any data point, we take the average of the results number of robots and the number of tasks for makespan
for multiple generated scenarios where the initial location optimization criteria. The plot shows that the computation
of the robots and the task locations are generated randomly. time is very low when the number of tasks is less than or
For each experiment, we have used 20 different examples equaltothenumberofrobots.Foreachrobot,weobservean
using predefined as well as randomly generated maps as increase in computation time for an increase in tasks. But,
shown in Figure 4. The first one resembles a warehouse, for each increase in the number of action steps denoted by
and the second is one for which the obstacles are generated Z, we observe a substantial increase in computation time.
randomly. This increase in Z reflects a corresponding rise in the tasks
In our experiments, we consider two planners: one opti- assignedperrobot,approximatedastheroundedvalueofthe
mizesthemakespan(opt makespan),andtheotheroptimizes number of tasks divided by the number of robots.
the total cost (opt cost). In all the tests, we have set the Figure 6a is a similar plot for total cost optimization
timeout as 3600s. In the plots, for all the cases where the criteria.Fromtheplot,wecanobservethatexceptforasingle
planner fails to solve the problem in 3600s, we take its robot,thecomputationtimeforoptimizingtotalcostishigher
computation time as 3600s and the metric value as the than optimizing makespan. The difference keeps increasing
average of the values for the instances the planner can solve with higher robot and task counts. Also, the planner cannot
successfully. hand more than 8 tasks with any number of robots for total
cost optimization. The results indicate that our task planner
B. Evaluation of Task Planner
with total cost optimization is not as scalable as optimizing
In this section, we evaluate our SMT-based task planner. makespan for varying numbers of robots and tasks.
To evaluate the task planner, we use a typical warehouse- Figure 5b shows the change in makespan, and Figure 6b
like workspace and randomly generated location pairs. We shows the change in total cost with the increase in the
evaluateourTaskPlannerextensivelyforvarioussettingsby number of robots and tasks. The makespan improves with
varying the number of robots and tasks, map size, and the the increased number of robots as the tasks get distributed
number of actions (Z). We use the average of the metrics betweenmorerobots.Generally,thetotalcostsforindividualFig.7. TaskPlanner:Theeffectofchangingworkspacesizeforvarious Fig. 9. Comparison of various planners (shown in legends) for varying
optimizationmodes(showninlegends)ona)ComputationTime(left)and workspacesizeonComputationTime.Mean(left)andStandarddeviation
b)Makespan/TotalCost(right) (right).
Fig. 8. Task Planner : The effect of increasing Z (shown in legends) on Fig. 10. Comparison of various planners (shown in legends) for varying
a)ComputationTime(left)andb)Makespan(right) workspacesizeonMakespan.Mean(left)andStandarddeviation(right).
robots should increase linearly with increased number of but with higher Z, we get plans with a better makespan. For
tasks.ThemakespanmayremainthesameforthesameZ for Z=5,wehittimeoutforsomeinstanceswithfiverobotsand
individual robots and increase when Z increases. However, fivetasks.ForZ=7,wehittimeoutforsomeinstanceswith
we observe many fluctuations and anomalies in our plots as three robots with three tasks and timeout for all instances
all the problem instances are randomly generated. with four robots with four tasks and above.
Figure 7a shows the changes in computation time by
C. Evaluation of Integrated Task and Path Planner
varying workspace sizes for 3 robots and 5 tasks, with both
the optimization criteria. From the plot, we can see that In this section, we evaluate our integrated task and path
the computation time increases slightly with an increase planners by comparing it with a state-of-the-art classical
in workspace size for optimizing makespan. For optimizing planner ENHSP-20 [13]. Since our planner deals with nu-
total cost, there is no monotonous increase in computation meric values for capacities and deadlines, we required a
time with varying sizes. Generally, the computation time is classical planner supporting numeric values and providing
expected to increase as the range of values to search in the optimal solutions. We explored the possibility of modeling
binary search increases with an increase in workspace size. our problem as a constrained TSP problem and utilizing the
Another important observation is that the task planner takes meta-heuristic algorithm LKH3 [14] to get a near-optimal
significantly more time to optimize the total cost than the solution. However, we did not find any extension of LKH3
makespan. that can deal with all the constraints we consider in our
Figure 7b shows the change in makespan and total cost problem. On the other hand, it was quite straightforward to
with the change in workspace size. The plot contains the model our exact problem in SMT as well as in ENHSP-20.
makespan metric for opt-makespan mode and the total cost In our result plots, in all the instances where time is
metric for opt-cost mode. As expected, both metrics are 3600s,theplannerexperiencesatimeout.Weincludesuccess
increasing linearly with an increase in the workspace size. percentages as annotations wherever the planner could not
2) Task Planning with collaboration: Here, we have ex- solve all the problems. In the plots, for all the cases where
perimented on a 50×50 workspace with multiple values of the planner faces a timeout, we take its computation time as
Z, a minimum satisfiable Z (Z ) to show no collaboration, 3600s and the metric value as the average of the values for
min
and Z +2 and Z +4 to show collaboration. Each the instances the planner can solve successfully.
min min
increase of 2 in Z allows each robot to perform two extra 1) Comparisonforvaryingworkspacesize: Inthisevalu-
actions. So, it can perform additional drop at intermediate ation,weexperimentwith2robotsand2taskswithZ=5for
and pickup from intermediate. We have executed our task varying workspace sizes ranging from 10×10 to 100×100.
planner for n robots n tasks for various Zs. Figure 8a and Figure 9 shows the computation time for varying map sizes
Figure 8b show how computation time and makespan vary for our planners and the ENHSP-20 planner. Our planners
with different values of Z, respectively. With the increase areabletosolvealltheproblemsinlessthanafewseconds.
in Z, we see the computation time increase tremendously, The ENHSP planner was able to solve 15% of the problemsFig. 11. Comparison of various planners (shown in legends) for varying Fig. 13. Comparison of various planners (shown in legends) for varying
workspacesizeonTotalCost.Mean(left)andStandarddeviation(right). Robots and Tasks without Collaboration on Makespan. Mean (left) and
Standarddeviation(right).
Fig. 12. Comparison of various planners (shown in legends) for varying
RobotsandTaskswithoutCollaborationonComputationTime.Mean(left) Fig. 14. Comparison of various planners (shown in legends) for varying
andStandarddeviation(right). Robots and Tasks without Collaboration on Makespan. Mean (left) and
Standarddeviation(right).
for the smallest 10×10 map and was unable to solve any
both the optimization criteria for multiple values of Z. We
problem with a larger map size. Figure 10 and Figure 11
labelourplannerasopt−makespan ZNandopt−cost ZN
presentingthemakespanandthetotalcost,respectively,isas
in the plots, where N denotes the value of Z. A value of
per the expectations, showing a linear increase in makespan
Z=3 implies no collaboration; with a higher value of Z, the
and total cost respectively with an increase in map size.
opportunity for intermediate pickup and drop arises. Fig-
2) Comparison for varying Robots and Tasks without ure15representsthecomputationtimesforvariousnumbers
Collaboration: From the previous evaluation, we observe of robots and tasks, and Z. For each robot and task, the
that the classical planner cannot solve problems for map computation time increases drastically for each increase in
size more than 10×10. So, in this experiment, we use maps Z forour planner.Ourplannercannot solveallthe problems
of size 9×9. We experiment with 2 to 5 robots and the for 4 robots and 4 tasks with Z=7. However, our planners
number of tasks ranging from 2 to 7. Since we aim for a are able to solve more problems faster compared to the
load-balancedsolution,weuseaminimumsatisfiableZ asit classical planner. Figure 16 and Figure 17 show the change
forces every robot to perform some work. Figure 12 shows in makespan and total cost for varying numbers of robots
thecomputationtimeforvaryingnumberofrobotsandtasks. and tasks. Higher Z values improve makespan for makespan
The classical planner cannot solve any problem for more optimization and total cost for total cost optimization. Also,
than 3 robots. Even for 3 robots, it can solve some of the our planners are able to generate better or equivalent plans
problem instances. On the other hand, our planners perform compared to the classical planner.
significantly better compared to the classical planner. As 4) AdditionalResults: Wealsoevaluateouralgorithmfor
optimizingtotalcostisharderforourplanner,itstartsfacing N robots and N tasks, where N ranges from 2 to 20 for
timeoutfor6tasks.Ourplannerwithmakespanoptimization a 100×100 workspace to determine the scalability of our
solves almost all of the problems. It faces timeout for 5% of algorithm. Figure 18a and 18b represents the computation
the cases for 5 robots and tasks. Figure 13 and Figure 14 time and makespan for varying number of robots and tasks.
denotes a change in makespan and total cost with varying Ourplannercansuccessfullyexecuteupto19robotswith19
number of robots and tasks. From the plots, we observe that tasks without experiencing failures for a timeout of 3600s.
the opt-makespan planner produces better plans than others. We also evaluated the time distribution between task and
Optimizing makespan is more scalable compared to other path planner. On an average, the task planner consumes
planners. more than 98% of the total computation time. As the task
3) ComparisonforvaryingRobotsandTaskswithCollab- plannerexploresalargesearchspacetofindthesequenceof
oration: We perform these experiments with a setup similar actions, the combinatorial explosion of possibilities makes
to the previous one, but we add some intermediate locations the search exponentially large. Note that, in the some plots
in the maps (randomly for randomly generated maps and representingmakespan,forsomecasestheaveragemakespan
predefinedforpredefinedmaps).Weexecutetheplannerwith fortheENHSPplannerisslightlylessthanourplanner.ThisFig.15. Comparisonofvariousplanners(legends)forvaryingRobotsand Fig.17. Comparisonofvariousplanners(legends)forvaryingRobotsand
TaskswithCollaborationonComputationTime.Mean(left)andStandard TaskswithCollaborationonTotalCost.Mean(left)andStandarddeviation
deviation(right). (right).
Fig.16. Comparisonofvariousplanners(legends)forvaryingRobotsand Fig. 18. Varying Robots and Tasks without Collaboration for Integrated
TaskswithCollaborationonMakespan.Mean(left)andStandarddeviation TaskandPathPlannerwithmakespanoptimizationcriteriaonComputation
(right). Time(left)andMakespan(right)
is due to the fact that they are accumulated from the solved been addressed in [22], [3], [23]. Recently, Okumura and
instances only, which are less in number. De´fago have proposed a sub-optimal but fast algorithm for
simultaneous target assignment and path planning efficiently
VI. RELATEDWORK
for a large-scale multi-robot system. Though the goal as-
In this section, we briefly describe the related work in the signment is a form of task assignment, it is beyond the
domain of task and path planning for multi-robot systems. scope of these algorithms to deal with complex constraints
Several classical planners have been developed to solve task (e.g., payload capacity, task deadline) for the robots or the
planning problems described in the popular multi-agent task possibility of robot-robot collaboration. Though the problem
specification language MA-PDDL [15]. Leofante et al. [16] oftransferringpayloadsinpackettransfers[24]anddeadline-
proposed an SMT-based mechanism to solve the multi- aware planning [25] in a multi-agent environment have been
robottaskschedulingprobleminalogisticplanningscenario studied, the proposed solutions apply to the very specific
that focuses on a simple objective involving only one state problems. Several authors have presented mechanisms to
variable.Incontrast,ourSMTformulationconsidersmultiple solve the integrated task and path planning problem for
state variables for the robots and tasks to make it generic to multi-robot systems, where the task specifications are given
handle complex scenarios. using linear temporal logic [26], [27], [28]. These meth-
Many previous papers have addressed the multi-agent ods are either not scalable [26] or compromise on finding
path finding problem. Two prominent algorithms use A* collision-free paths to achieve scalability [27], [28].
search algorithm [11] for individual agents and rely on Severalresearchershavefocusedonthemulti-robotpickup
subdimensional expansion (M* [17]) or constraint search and delivery problem. Michal et al. [29] provides a dis-
tree (CBS [18]) to generate collision-free paths. Another tributedalgorithmtosolveawell-formedmulti-agentpickup-
approach with the SMT solver’s capability to generate an delivery problem. Ma et al. [30], [8] provide several al-
unsatisfiable core is utilized to assign priorities to the robots gorithms addressing the MAPD problem across online and
to avoid any potential deadlock situation [19]. All these offline contexts. These approaches perform path planning in
papers rely on task assignments from some other algorithm. two stages, resulting in sub-optimal collision-free trajecto-
Several authors have presented algorithmic solutions for ries. Our approach employs CBS-PC [10], which efficiently
finding optimal task assignments and the corresponding computes optimal collision-free trajectory. Though we take
collision-free paths for multi-robot applications. Concurrent the pickup-delivery problem as an application, our SMT-
goal assignment and planning problem has been addressed based approach is more general in dealing with many com-
by Turpin et al. for obstacle-free environments [20] and plexconstraintsinataskplanningproblem.Someapproaches
in the environment cluttered with obstacles [21] without a basedonLargeNeighborhoodSearch [31],[32]areefficient
guarantee of optimality. On the other hand, the optimal goal and scalable. However, these algorithms do not guarantee
assignment and the collision-free path-finding problem have optimality or completeness; in contrast, our approach iscomplete and optimal. [18] G.Sharon,R.Stern,A.Felner,andN.R.Sturtevant,“Conflict-based
searchforoptimalmulti-agentpathfinding,”Artif.Intell.,vol.219,pp.
VII. CONCLUSION 40–66,2015.
[19] I.Saha,R.Ramaithitima,V.Kumar,G.J.Pappas,andS.A.Seshia,
We have presented a generic integrated task and path “Implan: Scalable incremental motion planning for multi-robot sys-
tems,”inICCPS,2016,pp.43:1–43:10.
planningalgorithmformulti-robotsystemsanddemonstrated
[20] M.Turpin,N.Michael,andV.Kumar,“Capt:Concurrentassignment
the applicability of this framework on the pickup delivery and planning of trajectories for multiple robots,” I. J. Robotics Res.,
problem that is at the core of any automated warehouse vol.33,no.1,pp.98–112,2014.
[21] M. Turpin, K. Mohta, N. Michael, and V. Kumar, “Goal assignment
management system. Our planning framework provides an
and trajectory planning for large teams of interchangeable robots,”
opportunity to combine the strength of an optimal task Auton.Robots,vol.37,no.4,pp.401–415,2014.
planner and an optimal path planner to design an optimal [22] H. Ma and S. Koenig, “Optimal target assignment and path finding
forteamsofagents,”inAAMAS,2016,pp.1144–1152.
planner capable of solving complex multi-robot logistics
[23] K.Brown,O.Peltzer,M.A.Sehr,M.Schwager,andM.J.Kochender-
planning problems which is beyond the scope of the state- fer, “Optimal sequential task assignment and path finding for multi-
of-the-art multi-agent classical planners. agentroboticassemblyplanning,”inICRA,2020,pp.441–447.
[24] H.Ma,C.A.Tovey,G.Sharon,T.K.S.Kumar,andS.Koenig,“Multi-
agent path finding with payload transfers and the package-exchange
ACKNOWLEDGMENT
robot-routingproblem,”inAAAI,2016,pp.3166–3173.
This research was supported by Max-Plank Society, Ger- [25] H.Ma,G.Wagner,A.Felner,J.Li,T.K.S.Kumar,andS.Koenig,
“Multi-agent path finding with deadlines,” in IJCAI, 2018, pp. 417–
manythrougharesearchfundingawardedtoapartnergroup
423.
between MPI-SWS, Germany and IIT Kanpur, India. [26] A.Ulusoy,S.L.Smith,X.C.Ding,C.Belta,andD.Rus,“Optimality
and robustness in multi-robot path planning with temporal logic
constraints,”I.J.RoboticsRes.,vol.32,no.8,pp.889–911,2013.
REFERENCES
[27] Y.KantarosandM.M.Zavlanos,“Stylus*:Atemporallogicoptimal
[1] M. Crosby, M. Rovatsos, and R. P. A. Petrick, “Automated agent control synthesis algorithm for large-scale multi-robot systems,” Int.
decomposition for classical planning,” in ICAPS, vol. 23, 2013, pp. J.RoboticsRes.,vol.39,no.7,2020.
46–54. [28] D. Gujarathi and I. Saha, “MT*: multi-robot path planning for tem-
[2] I.Saha,R.Ramaithitima,V.Kumar,G.J.Pappas,andS.A.Seshia, porallogicspecifications,”inIROS,2022,pp.13692–13699.
“Automatedcompositionofmotionprimitivesformulti-robotsystems [29] M.Cˇa´p,J.Vokˇr´ınek,andA.Kleiner,“Completedecentralizedmethod
fromsafeLTLspecifications,”inIROS,2014,pp.1525–1532. for on-line multi-robot trajectory planning in well-formed infrastruc-
[3] W.Ho¨nig,S.Kiesel,A.Tinka,J.Durham,andN.Ayanian,“Conflict- tures,”inICAPS,2015,pp.324–332.
based search with optimal task assignment,” in AAMAS, 2018, pp. [30] H. Ma, J. Li, T. K. S. Kumar, and S. Koenig, “Lifelong multi-agent
757–765. pathfindingforonlinepickupanddeliverytasks,”inAAMAS,2017,
[4] I. Gavran, R. Majumdar, and I. Saha, “Antlab: A multi-robot task pp.837–845.
server,” ACM Trans. Embedded Comput. Syst., vol. 16, no. 5, pp. [31] Q. Xu, J. Li, S. Koenig, and H. Ma, “Multi-goal multi-agent pickup
190:1–190:19,2017. anddelivery,”inIROS,2022,pp.9964–9971.
[5] AakashandI.Saha,“Itcoststogetcosts!aheuristic-basedscalable [32] Z. Chen, J. Alonso-Mora, X. Bai, D. D. Harabor, and P. J. Stuckey,
goalassignmentalgorithmformulti-robotsystems,”inICAPS,vol.32, “Integrated task assignment and path planning for capacitated multi-
2022,pp.2–10. agent pickup and delivery,” IEEE Robotics and Automation Letters,
vol.6,no.3,pp.5816–5823,2021.
[6] M. Turpin, N. Michael, and V. Kumar, “Trajectory planning and
assignment in multirobot systems,” in Algorithmic Foundations of
Robotics,2013,pp.175–190.
[7] D. Hennes, D. Claes, W. Meeussen, and K. Tuyls, “Multi-robot
collision avoidance with localization uncertainty,” in AAMAS, 2012,
pp.147–154.
[8] M. Liu, H. Ma, J. Li, and S. Koenig, “Task and path planning for
multi-agentpickupanddelivery,”inAAMAS,2019,pp.1152–1160.
[9] L. M. de Moura and N. Bjørner, “Z3: An efficient SMT solver,” in
TACAS,2008,pp.337–340.
[10] H.Zhang,J.Chen,J.Li,B.C.Williams,andS.Koenig,“Multi-agent
path finding for precedence-constrained goal sequences,” in AAAMS,
2022,pp.1464–1472.
[11] P. E. Hart, N. J. Nilsson, and B. Raphael, “A formal basis for the
heuristic determination of minimum cost paths,” IEEE Transactions
onSystemsScienceandCybernetics,vol.4,no.2,pp.100–107,1968.
[12] F. Grenouilleau, W.-J. van Hoeve, and J. N. Hooker, “A multi-label
A* algorithm for multi-agent pathfinding,” in ICAPS, vol. 29, 2019,
pp.181–185.
[13] E.Scala,P.Haslum,S.Thie´baux,andM.Ramirez,“Subgoalingtech-
niques for satisficing and optimal numeric planning,” JAIR, vol. 68,
pp.691–752,2020.
[14] K. Helsgaun, “An extension of the lin-kernighan-helsgaun tsp solver
for constrained traveling salesman and vehicle routing problems,”
Roskilde:RoskildeUniversity,vol.12,2017.
[15] D.L.Kovacs,“Amulti-agentextensionofPDDL3.1,”inICAPS,2012,
pp.19–27.
[16] F.Leofante,E.A´braha´m,T.Niemueller,G.Lakemeyer,andA.Tac-
chella, “On the synthesis of guaranteed-quality plans for robot fleets
inlogisticsscenariosviaoptimizationmodulotheories,”inIEEEIRI,
2017,pp.403–410.
[17] G.WagnerandH.Choset,“M*:Acompletemultirobotpathplanning
algorithmwithperformancebounds,”inIROS,2011,pp.3260–3267.