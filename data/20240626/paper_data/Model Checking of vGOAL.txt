Model Checking of vGOAL
Yi Yang and Tom Holvoet
imec-DistriNet, KU Leuven, Celestijnenlaan, Leuven, 3001, Belgium.
Contributing authors: yi.yang@kuleuven.be; tom.holvoet@kuleuven.be;
Abstract
Developing autonomous decision-making requires safety assurance. Agent pro-
gramminglanguageslikeAgentSpeakandGwendolenprovidetoolsforprogram-
ming autonomous decision-making. However, despite numerous efforts to apply
model checking to these languages, challenges persist such as a faithful seman-
tic mapping between agent programs and the generated models, efficient model
generation, and efficient model checking.
AsanextensionoftheagentprogramminglanguageGOAL,vGOALhasbeenpro-
posedtoformallyspecifyautonomousdecisionswithanemphasisonsafety.This
paper tackles the mentioned challenges through two automated model-checking
processes for vGOAL: one for Computation Tree Logic and another for Prob-
abilistic Computation Tree Logic. Compared with the existing model-checking
approachesofagentprogramminglanguages,ithasthreemainadvantages.First,
it efficiently performs automated model-checking analysis for a given vGOAL
specification,includingefficientlygeneratinginputmodelsforNuSMVandStorm
andleveragingtheseefficientmodelcheckers.Second,thesemanticequivalenceis
establishedforbothnondeterministicmodelsandprobabilisticmodelsofvGOAL:
from vGOAL to transition systems or DTMCs. Third, an algorithm is pro-
posed for efficiently detecting errors, which is particularly useful for vGOAL
specifications that describe complex scenarios. Validation and experiments in
a real-world autonomous logistic system with three autonomous mobile robots
illustrate both the efficiency and practical usability of the automated CTL and
PCTL model-checking process for vGOAL.
Keywords:CTLModelChecking,PCTLModelChecking,vGOAL,Autonomous
Decision-Making,AgentProgrammingLanguages
1
4202
nuJ
52
]AM.sc[
1v60271.6042:viXra1 Introduction
The advancement of technology is leading to an increased interest in systems capable
ofindependentlyexecutingtasks,withouttheneedforinstructionsorhumaninterven-
tion. At the core of these autonomous systems lies the autonomous decision-making.
The public rightfully expresses concerns about the safety of autonomous systems.
Therefore, it poses a challenging yet indispensable endeavor to ensure the correctness
of autonomous decision-making, particularly regarding safety.
Agentprogramminglanguages(APLs)havebeenextensivelyresearchedovermany
yearsasameansofprogrammingautonomousagentswithinamulti-agentsystem[1].
Throughout the past few decades, various APLs have emerged, including AgentSpeak
[2], Gwendolen [3], and GOAL [4]. More recently, vGOAL [5] has been proposed as
a language, based on GOAL, for formally specifying autonomous decision-making.
The interpreter of vGOAL serves as an autonomous decision-maker that effectively
generates safe decisions without requiring external formal verification for a sound
vGOAL specification [6]. In this context, we consider a vGOAL specification sound
when it satisfies two properties: first, it can effectively achieve all goals; second, it
alwaysgeneratessafedecisionsunderallrealisticcircumstancesincludingencountering
unexpected errors or expected errors.
Formal verification is a convincing approach to ensure the correctness of agent
programs. Model checking is the most successful and influential verification method
in verifying APLs, including GOAL, Gwendolen, and AgentSpeak, owing to the auto-
mated verification process [7–10]. However, case studies for model checking of APLs
remainrelativelysimpleandconceptualduetothreemainchallenges:afaithfulseman-
ticmappingbetweenagentprogramsandgeneratedmodels,efficientmodelgeneration,
efficient model checkers [8–11]. Moreover, autonomous systems often encompass mul-
tiple agents with numerous goals, the complexity can lead to extensive state spaces in
their equivalent semantic models.
To address these challenges, we design and implement automated CTL and
PCTLmodel-checkingprocessesforvGOAL,efficientlyverifyingautonomousdecision-
making. Figure 1 presents the overview of the automated CTL and PCTL model-
checkingprocessesforvGOAL.TheprocesstakesavGOALspecificationasinputand
produces both a CTL model-checking analysis and a PCTL model-checking analysis
asoutputs.Yellowparallelogramsrepresentfilesduringthemodel-checkingprocesses.
ItcanbeavGOALspecification,ageneratedmodel:atransitionsystemoradiscrete-
timeMarkovchain(DTMC),aninputfileforamodelchecker:ansmv fileforNuSMV
[12] or a pm file for Storm [13], or a CTL or PCTL mode-checking analysis. Red
rectangles are steps of the model-checking process. The CTL model-checking pro-
cess involves three steps: generating a transition system, encoding for NuSMV, and
performing CTL model checking using NuSMV. The PCTL model-checking process
involves three steps: generating a DTMC, encoding for Storm, and performing PCTL
model checking using Storm.
Theautomatedmodel-checkingprocessesofvGOALaddressestheaforementioned
challenges well. First, the vGOAL translator implements two equivalently semantic
mappings from a vGOAL specification to either a transition system or a DTMC.
2vGOAL Specification
Model Generation
Transition System DTMC
NuSMV Encoding Storm Encoding
SMV File PM File
NuSMV Storm
CTL Model Checking Analysis PCTL Model Checking Analysis
Fig. 1 TheOverviewoftheCTLandPCTLModel-CheckingProcessforvGOAL.
Second, the vGOAL translator efficiently translates a vGOAL specification to a tran-
sition system or DTMC. Third, the model-checking process for vGOAL leverages the
efficiency of NuSMV [12] and Storm [13]. Moreover, we propose an algorithm that
can efficiently detect errors for a vGOAL specification that violates safety or live-
ness properties if the autonomous system involves multiple agents with many goals.
Usingareal-worldautonomouslogisticsystemwiththreemobilerobots,wehavecon-
ducted experiments to illustrate the practical efficiency and the use of the automated
model-checking processes for vGOAL.
2 Related Work
The first significant work on verifying the belief–desire–intention (BDI) logic pro-
gramming language through model checking of AgentSpeak(L) is detailed in [8].
To enable the model checking of AgentSpeak(L), two components are introduced:
AgentSpeak(F)-a variant of AgentSpeak(L), and a translation from AgentSpeak(F)
programs to Promela, the model specification language for the SPIN model check-
ing [14]. The model checking of AgentSpeak(F) has three main limitations. First, it
verifies the properties of the abstract version of systems instead of the real imple-
mentation. Second, the translation process is difficult to understand [9]. Third, the
model-checking process is not efficient.
[9] describes the first comprehensive approach to the verification of programs
developed using programming languages based on the BDI model of agency. The
comprehensive approach is officially released as the MCAPL (Model-checking Agent
Programming Languages) framework in [15]. To verify various agent programming
languages, the MCAPL consists of two layers, the Agent Infrastructure Layer (AIL)
3as a toolkit for interpreting BDI APLs, and Agent JavaPathFinder (AJPF) model
checker as the automated verification tool. Interpreters have been implemented for
Gwendolen,GOAL,SAAPL[16],andORWELL[17].Comparedwiththemodelcheck-
ingofAgentSpeak(L),theMCAPLcheckstheexecutionsofagentprograms.However,
the inefficiency of the AJPF model checker is particularly slow. It explores the whole
state space for each property verification. For the same property verification, it took
65 seconds to verify in SPIN, while it took 9 hours in AJPF [9]. Moreover, the faith-
fulnessoftheinterpretationofBDIlanguageinAIL.Toaddresstheinefficiencyissue,
[11]presentsatranslationfromAJPFtoPromela,enablingtheuseoftheSPINmodel
checker,andatranslationfromAJPFtoPRISM,enablingtheuseofthePRISMmodel
checker[18].TheempiricalcomparisonamongAJPF,SPIN,andPRISMisconducted
with rather simple case studies, the most complicated case study only has 408 states.
The experiments show PRISM has significantly better efficiency and supports more
expressivepropertyspecificationsthanAJPFandSPIN.However,theverificationper-
formance of Storm is still much better than the verification performance described in
[11]. For a DTMC with 98 states, the verification time of PRISM took 1.3 seconds,
whiletheverificationtimeforStormtookonlyaround0.14secondsforaDTMCwith
138 states.
[10] presents an interpreter-based model checker (IMC) to model check agent pro-
grams. IMC includes a program interpreter to generate state space, and a model
checker specifically built on this interpreter. This approach has only been validated
using single-agent systems. Using a subset of GOAL as the target language, an
empirical comparison among IMC, Maude model checker (MMC) [19], and AJPF is
conducted for a single deterministic agent system, specifically, blocks worlds. IMC
has the best efficiency based on the conducted experiments. Compared with MMC
andAJPF,IMCcanverifysingle-agentsystemswithnon-deterministicactions.More-
over,IMCusesnostate-spacereductiontechniques,whichmakesitsignificantlymore
inefficient than advanced efficient model checkers.
[20] describes an algorithm that transforms a single-agent and single-goal GOAL
program to a semantically equivalent transition system. [21] extends the work
described in [20]. It extends the transformation algorithm applicable for all single-
agent systems, and it presents an automated model-checking process for single-agent
GOAL programs using GOAL translator and Storm or PRISM.
The model-checking approaches described in [8–11, 21] have not specifically
discussed how to handle many agent goals.
3 Preliminaries
In this section, we introduce the basic concepts of vGOAL specifications and explain
the role of the goals of agents in vGOAL semantics. Moreover, we briefly introduce
the fundamentals of model checking. Since this introduction cannot be complete, we
havetoreferinterestedreadersto[5]formoredetailsofvGOAL.Fordetailedinsights
into the foundational aspects of model checking, we recommend referring to [22].
4Definition 1. (vGOAL Specifications) [5]
A vGOAL specification is defined as:
vGOALSpec::=(MAS,K,C,A,S,P,E,D,Prob,Safety),
MAS ::=(id,B,goals,M ,M )∗.
S R
A vGOAL specification defines autonomous decision-making. The first main com-
ponent is the agents’ specifications, MAS. Each agent’s specification comprises a
unique identifier (id), a belief base (B), a set of goals (goals), sent messages (M ),
S
and received messages (M ).
R
Theotherspecificationsaresystem-wide:K :knowledgebase,C:rulesforenabled
constraintsgeneration,A:rulesforfeasibleactiongeneration,S:rulesforsentmessage
generation, P: rules for event processing, including modifying agent goals and beliefs,
and processing received messages, E: action effects, D: domain of all variables. More-
over,Probspecifiestheprobabilityofpossibleoutcomesofeachaction,i.e.,itspecifies
the successful probability of each action. Safety specifies all safety requirements the
system has to satisfy.
vGOAL syntax restricts it to first-order logic. All specifications, except E and D,
are interpreted either as a set of atoms or a first-order theory. The syntax guarantees
each first-order theory has a minimal model. E is used to update the belief base
through actions, and D is used to instantiate universally quantified variables.
Definition 2. (vGOAL States) [5] A vGOAL state is formalized as
state::=(substate) , where substate::=id:(I(B),I(goals)).
×n
The vGOAL state of a system is formally defined as a composition of substates,
(id:(I(B),I(goals))) . Each substate represents an agent with a unique identifier
×n
and the semantics of its beliefs and goals, denoted as I(B) and I(goals).
Example 1. MAS =[Agent ,Agent ]
1 2
Agent =(id ,B ,G ,M ,M ), Agent =(id ,B ,G ,M ,M )
1 1 1 1 S R 2 2 2 2 S R
id =A , B =[b ,b ,b ], G =[[g ],[g ],[g ]]
1 1 1 1 2 3 1 1 1 2
id =A , B =[b ,b ,b ], G =[]
2 2 2 1 2 3 2
substate =A :({b ,b ,b },{g }),
1 1 1 2 3 1
substate =A :({b ,b ,b },∅)
2 2 1 2 3
state=(substate ,substate )
1 2
Example 1 is a simple example of the vGOAL state in a vGOAL specification.
A vGOAL state only pertains to the agent’s identifier and the interpretation of the
agent’s beliefs and goals. The interpretation of the agent’s goals is the first goal base
of the non-empty agent’s goals or an empty set.
Definition 3. (Operational Semantics of vGOAL) [? ]
The operational semantics of vGOAL are defined by:
(substate) −A −c −ti −o →n (substate′) ,
×n ×n
where Action is defined in two cases:
• Non-deterministic: Action::=(id:(M ,Act)) ,
R ×n
• Probabilistic: Action::=(id:(M ,Act,P(M ,Act))) .
R R ×n
5AvGOALstatewillbeupdatedifanysubstateisupdated.Asubstatewillonlybe
changedbyeitherthereceivedmessagesoftheagent,anagentaction,orbothofthem.
Moreover,theselectionofactionscanbemodeledasnondeterministicorprobabilistic.
Hence, Action can be formalized in two ways. In the non-deterministic case, actions
are non-deterministically chosen from a set of all possible actions. In the probabilistic
case, actions are selected according to the probability distribution P(M ,Act).
R
Definition 4. (Transition System) [22] A transition system TS is a tuple (S,Act,→
,S ,F,AP,L) where S is a set of states, Act is a set of actions, →⊆S×Act×S is a
0
transition relation, S ⊆S is a set of initial states, F ⊆S is a set of final states, AP
0
is a set of atomic propositions and L:S →2AP is a labeling function.
Definition 5. (Path) [22] A finite path fragment π of TS is a finite state sequence
s s ...s suchthat∀0≤i≤n.s ∈Post(s ),wheren≥0.Amaximalpathfragment
0 1 n i i−1
is a finite path fragment that ends in a terminal state. A path fragment is called initial
if it starts in an initial state. A path of transition system TS is an initial, maximal
path fragment.
Definition 6. (Bisimulation Equivalence) [22] TS =(S ,Act ,→ ,S ,AP ,L ), i=
i i i i i0 i i
1,2, be transition systems over AP. A bisimulation for (TS ,TS ) is a binary relation
1 2
R ⊆ S ×S , such that (a) ∀s ∈ S (∃s ∈ S .(s ,s ) ∈ R), and ∀s ∈ S (∃s ∈
1 2 1 10 2 20 1 2 2 20 1
S .(s ,s ) ∈ R), (b) for all (s ,s ) ∈ R, it holds (b.1) L (s ) = L (s ); (b.2) if
10 2 1 1 2 1 1 2 2
s′ ∈Post(s ), then there exist s′ ∈Post(s ) with (s′,s′)∈R; (b.3) if s′ ∈Post(s ),
1 1 2 2 1 2 2 2
then there exist s′ ∈Post(s ) with (s′,s′)∈R.
1 1 2 1
Definition 7. (Satisfaction Relation for CTL) [22] Let a∈AP be an atomic propo-
sition, TS =(S,Act,→,S ,F,AP,L) be a transition system, state s∈S, ϕ be a CTL
0
path formula, such that (a) s |= a iff a ∈ L(s); (b) s |= ∃ϕ iff π |= ϕ for some
π ∈Paths(s); (c) s|=∀ϕ iff π |=ϕ for all π ∈Paths(s).
Definition 8. (Discrete-Time Markov Chain) [22] A Discrete-Time Markov Chain
(DTMC) is a tuple D = (S,P,ι ,AP,L) where S is a countable, nonempty set
init
of states, P : S ×S → [0,1] is the transition probability function such that for all
states s: (cid:80) P(s,s′) = 1, ι : S → [0,1] is the initial distribution, such that
s′∈S init
(cid:80) ι (s) = 1, and AP is the set of atomic propositions and L : S → 2AP is a
s∈S init
labeling function.
Definition 9. (Satisfaction Relation for PCTL) [22] Let a∈AP be an atomic propo-
sition, D =(S,P,ι ,AP,L) be a Markov chain, state s∈S, and ϕ be a PCTL path
init
formula, such that (a) s |= a iff a ∈ L(s); (b) s |= P (ϕ) iff Pr(s |= ϕ) ∈ J, where
J
J ∈[0,1] and Pr(s|=ϕ)=Pr {π ∈Paths(s)|π |=ϕ}.
s
Definition 10. (Probabilistic Bisimulation) [22] Let D = (S,P,ι ,AP,L) be a
init
Markov chain. A probabilistic bisimulation on D is an equivalence relation R on S
such that for all states (s ,s ) ∈ R: (a) L(s ) = L(s ), (b) P(s ,T) = P(s ,T) for
1 2 1 2 1 2
each equivalence class T ∈s/R. States s and s are bisimulation-equivalent, denoted
1 2
s ∼ s , if there is a bisimulation R on D such taht (s ,s )∈R.
1 D 2 1 2
64 Model Generation
This section presents how to generate two faithful semantic mappings from a vGOAL
specificationtoitsequivalentmodels.FollowingDefinition3,foragivenvGOALspeci-
fication,thenon-deterministicmodelisatransitionsystemandtheprobabilisticmodel
is a DTMC. First, we introduce two algorithms for the model generation of a vGOAL
specification. The first algorithm describes how to generate a semantically equivalent
transition system from a given vGOAL specification. The second algorithm describes
how to generate a semantically equivalent DTMC from a given vGOAL specification.
Second, we provide theoretical proof of the semantic equivalence between a given
vGOALspecificationanditsmodels.Additionally,thetwoalgorithmsareimplemented
in the vGOAL translator, and its source code is available at [23].
4.1 Algorithms
4.1.1 Transition System Generation
Algorithm 1 describes the transformation from a vGOAL specification for an
autonomous system with n agents to its semantically equivalent transition system. In
thiscontext,bothavGOALspecificationandatransitionsystemadheretotheformal-
izations outlined in Definition 1 and Definition 4, respectively.Based on Definition 3,
thesemanticsinherentinvGOALisnaturallysuitabletoconstructatransitionsystem.
ThevGOALinterpreterimplementsthesemanticsofvGOAL.Leveragingtheexisting
vGOAL semantics implementation, we construct the transition system corresponding
to a given vGOAL specification.
The initial state (S ) of the transition system is determined by the semantics
0
of the initial beliefs and goals of each agent within the autonomous systems. The
transition system begins with S initialized to this initial state. Final states (F) are
definedasstatesinwhichallagentswithintheautonomoussystemhavenogoals.D
T
functions as a dictionary tasked with recording the current state and all its possible
next states in the last reasoning cycle. S denotes all possible states during a cycle
cur
when generating the transition system, initialized with the initial state. Act denotes
all actions and communication. T is the set of all transitions. AP denotes all atomic
propositionsgeneratedasstateproperties.Lisadictionarythatservestorecordstate
properties. F, D , Act, T, AP, and L are initialized with an empty set.
T
Lines 3-41 describe an iterative generation process of a transition system. The
generation process will terminate if all possible executions starting from the initial
statearetraversed.S recordsallpossiblenextstatesofallstatesinS .Lines5–7
next cur
describe the generation of final states. A state attains finality when each substate is
devoid of goals, which corresponds to no goals for each agent. The transition system
generation process will explore all possible next states for each non-terminal state for
all current states.
The next states of each state can be calculated by the vGOAL decision-making
process, implemented in the vGOAL interpreter. However, Algorithm 1 only uses the
vGOAL decision-making process to calculate next states when the state has never
beenprocessedbythevGOALdecision-makingprocess.IfthevGOALdecision-making
process has processed the state, Algorithm 1 will generate the next states based on
7Algorithm 1: Transform a vGOAL specification to a transition system
Input: vGOALSpec::=(MAS,K,C,A,S,P,E,D,Prob,Safety),
MAS ::=(id,B,goals,M ,M )n
S R
Output: (S,Act,T,S ,F,AP,L)
0
1 S 0
←(cid:83)n
id=1{id:(I(B),I(goals))}, S ←{S 0},F ←∅
2 D T ←∅, S cur ←{S 0}, Act←∅,T ←∅,AP ←∅, L←∅
3 while S cur ̸=∅ do
4 S next ←∅
5 for each
(cid:83)n
id=1{id:(I(B),I(goals))}∈S next do
6 if ∀id.I(goals)=∅ then
7 F ←F ∪{s}
8 S cur ←S cur\F
9 for each s∈S cur do
10 if s∈/ D T.keys() then
11 L←L∪{s:∅}
12 for each Ag :(id,B,goals,M S,M R)∈MAS do
13 subS i′ d ←∅, subA id ←∅, subT id ←∅
14 L[s]←L[s]∪{id:MinModel(B,KB)}
15 AP ←AP ∪MinModel(B,KB)
16 subs←id:(B,I(goals))
17 (subS i′ d,subA id)←DM(Ag,K,C,A,S,P,D)
18
subS′ ←Update(subS′,subA,E)
19 for each (suba,subs′)∈(subA id,subS i′ d) do
20 subT ←subT ∪{(subs,suba,subs′)}
21 Ag ←Communication(Ag)
22 S n ←Πn id=1subS i′ d, S ←S∪S n
23 Act n ←Πn id=1subA′ id, Act←Act∪Act n
24 T n ←Πn id=1subT id, T ←T ∪T n
25 D T ←D T ∪{s:S n},S next ←S next∪S n
26 else
27 states←D T[s], D T[s]←∅
28 for each state∈states do
29 s′ ←∅
30 for subs::=id:(I(B),I(goals))∈s′ do
31 if I(goals) is a original goal then
32
s′ ←s′∪{id:(I(B),I(goals[1:]))}
33 else
34
s′ ←s′∪{subs}
35 S next ←S next∪{s′}
36 D T[s]←D T[s]∪{s′}
37 if s′ ∈/ S then
38 S ←S∪{s′}, L←L∪{s′ :L[s]}
39 T ←T ∪{(s,Act(s,state),s′)}
40 ∀id.M R ←∅
8
41 S cur ←S next
42 return (S,Act,T,S 0,F,AP,L)the generated next states. Lines 10–25 describe the process of generating the next
state using the vGOAL decision-making process. Specifically, Lines 11–21 detail the
implementation of vGOAL semantics, the identical implementation of the vGOAL
interpreter. According to Definition 3, agents execute actions in a modular manner,
consequently updating the corresponding substate and subsequently modifying the
overall state. subS′ records all potential next substates of Agent and starts as an
id id
empty set. Simultaneously, subA records all possible actions of Agent , and subT
id id id
records all possible transitions of Agent . Lines 26-40 outline the generation of the
id
nextstatesbasedonthepreviouslygeneratednextstates.ThevGOALdecision-making
process generates decisions based on current beliefs and the current focused goal of
eachagent.Consequently,thegenerateddecisionsshouldremainconsistentwiththose
producedpreviously.Deviationsinthenextstatesareonlypossiblewhentransitioning
from one focused goal to the next.
4.1.2 DTMC Generation
Algorithm 2: Transform a vGOAL specification to a DTMC in Storm
Input: vGOALSpec::=(MAS,K,C,A,S,P,E,D,Prob,Safety),
(S ,Act,T,S ,F,AP ,L)
1 0 1
Output: (S ,P,ι ,AP )
2 init 2
1 S 2 ←S 1, S 0′ ←S 0, AP 2 ←AP 1, L 2 ←L 1, P ←{}
2 for each (s 1×Acts→s 2)∈T do
3 p←1.0
4 for each act∈Acts do
5 if act∈Prob.keys() then
6 p←p∗Prob[act]
7 if s 1 ∈P.keys() then
8 P[s 1].append(p,s 2)
9 else
10 P.update({s 1 :(p,s 2)})
11 P ←P ∪{s 1,p,s 2}
12 sum←0
13 for each s∈P.keys() do
14 for each (p,s′)∈P[s]] do
15 sum←sum+p
16 if sum̸=1 then
17 for each (p,s′)∈P[s]] do
18 p←p/sum
19 ι init ←P[S 0′]
20 return (S 2,P,ι init,AP 2,L 2)
9Algorithm 2 describes how to transform a vGOAL specification to a DTMC in
Storm. Following Definition 3, the main difference between the non-deterministic
model and the probabilistic model is the model of uncertainty. Therefore, we directly
use the generated output of Algorithm 1 to avoid unnecessary computation.
The inputs of Algorithm 2 consist of the vGOAL specification and the generated
transition system of Algorithm 1. The output of Algorithm 2 is the equivalent proba-
bilisticmodelofthegivenvGOALspecification.FollowingDefinition4andDefinition
8, a transition system is a tuple (S ,Act,→,S ,F,AP ,L ), and a DTMC is a tuple
1 0 1 1
(S ,P,ι ,AP ,L ).WecaneasilyconstructbijectionsfromS toS ,fromS toS′,
2 init 2 2 1 2 0 0
from AP to AP , and from L to L .
1 2 1 2
The most important part of Algorithm 2 is the probabilistic model of uncertainty,
whichinvolvesP andι .P isinitializedwithanemptyset.Lines2-11describehow
init
to compute the probability of each transition using the probabilistic specification of
eachaction(Prob).Notably,ifanactionhasnotbeenspecifiedinProb,theprobability
is calculated as 1. Lines 12-18 describe the adjustment of the probability of each
transition, ensuring the sum of the probabilistic distribution of a state is 1. ι is
init
obtained by computing the initial probabilistic distribution using P and S′.
0
4.2 Theoretical Proofs
Theorem 1. Algorithm 1 generates an equivalent transition system for a given
vGOALspecificationofn-agentautonomoussystemintermsofoperationalsemantics.
Proof. Following Definition 1, the given vGOAL specification is defined as
vGOALSpec ::= (MAS,K,C,A,S,P,E,D,Prob,Safety) and MAS ::=
(id,B,goals,M ,M )n, we denote the semantics of vGOALSpec as TS ; we denote
S R 1
the transition system generated by Algorithm 1 as TS . Following Definition 4, TS
2 1
and TS are in the form TS ::= (S ,Act ,→ ,S ,F ,AP ,L ),i ∈ {1,2}. We show
2 i i i i i0 i i i
TS is bisimulation-equivalent to TS , denoted TS ∼ TS , and ∼ is an equivalence
1 2 1 2
relation, denoted R ,therefore, TS ≡TS .
id 1 2
Following Definition 6, we prove the condition a of the bisimulation equivalence.
FollowingDefinition2,theinitialstateofthegivenvGOALspecificationistheseman-
tics of each agent’s beliefs and goals, denoted as S =
(cid:83)n
{id : (I(B),I(goals))}.
10 id=1
AccordingtoLine1inAlgorithm1,S
=(cid:83)n
{id:(I(B),I(goals))}.AsS =S ,
20 id=1 10 2,0
(S ,S )∈R holds for the initial state.
10 20 id
Second,weshowthebisimulationwithequivalencerelationonpaths.Paths(s )(i∈
i
{1,2}) follows Definition 5. For each finite path π = s s s ... ∈ Paths(s ), there
1 10 11 12 1
exists a path π = s s s ... ∈ Paths(s ) of the same length such that (s ,s ) ∈
2 20 21 22 2 1k 2k
R forallk.FollowingDefinition2,s
::=(cid:83)n
{id:(I(B ),I(goals ))}.Following
id 1k id=1 k k
Definition 6, we prove the condition b.2 by induction on k. For each case, we distin-
guish between s being a terminal state or not.
i
Base case (k =0): s =s , s =s , (s ,s )∈R
1 10 2 20 1 2 id
Case 1: In case s is a terminal state, that means all agents of the autonomous sys-
1
temdefinedbyvGOALSpechavenogoalstoachieve.Inthiscase,vGOALinterpreter
will not generate any decisions. Algorithm 1 will also not generate any decisions for
s , because the state will be considered as a final state of TS .
2 2
10Case 2: In case s is not a terminal state, s is updated by the vGOAL semantics,
1 1
s → s . As s = s is an initial state, it has goals to achieve. Algorithm 1 will
10 11 2 20
also generate the next state of s using the vGOAL semantics. Therefore, s → s ,
2 20 21
(s ,s )∈R , and s =s .
11 21 id 11 21
Induction step: Assume k ≥ 0, and the path fragment s s ...s is already con-
20 21 2k
structed with ∀0≤i≤k.(s ,s )∈R .
1i 2i id
Case 1: In case s is a terminal state, we have ∀id.I(goals )=∅, s will also be a
1k k 2k
final state according to Lines 6-7 in Algorithm 1.
Case 2:Incases isnot aterminal state,we have ∃id.I(goals )̸=∅. π isextended
1k k 1
by s s based on the vGOAL semantics. As (s ,s ) ∈ R , s is a non-final
1k 1(k+1) 1k 2k id 2k
state of TS . Algorithm 1 generates the next state of s based on two cases.
2 2k
Case 2a: If (s ,s ) ∈/ D , which means s has never been processed by
2k 2(k′+1) T 2k
the implementation of the vGOAL semantics during the transition system genera-
tion, it will be processed by the implementation of the vGOAL semantics, described
by lines 10-25. π is extended by s s based on vGOAL semantics. Therefore,
2 2k 2(k+1)
(s ,s ∈R .
1(k+1) 2(k+1) id
Case2b:If(s ,s )∈D ,s hasbeenprocessedbythevGOALsemanticsdur-
2k 2(k′+1) T 2k
ing the transition system generation. Algorithm 1 will generate the next state based
on the previous generation results, described by lines 26-40. The previous generation
certainly produced a path fragment with s s , where s = s . The vGOAL
2k′ 2(k′+1) 2k 2k′
semanticsisupdatedonlybasedonthestateforonevGOALspecification.Thedecision
changesthebeliefs,whichpossiblyachievesthecurrentgoal,subsequentlyshiftingthe
focused goal to the next goal. s and s will be the same except the current
2(k+1) 2(k′+1)
focusedgoalofanyagentisshiftedtothenext.Therefore,itisnecessarytomodifyall
agent goals to get the right next state of s . We denote a substate of s for agent i
2k 1k
as sub , where 1≤i≤n. The sub path fragment is denoted as sub sub ,
1(k)i 1(k)i 1(k+1)i
we prove (s ,s )∈R by proving ∀1≤i≤n.(sub ,sub )∈R .
1(k+1) 2(k+1) id 1(k+1)i 2(k+1)i id
Case 2b.1:IfI(goals ))∈/ I(goals ),thegenerateddecisiondoesnotresultin
1(k+1)i 10i
the shift of the current focus goal. Based on Lines 33-34, sub =sub , the
2(k+1)i 2(k′+1)i
substateupdateonlydependsonthevGOALsemantics.(sub ,sub )∈R
1(k+1)i 2(k+1)i id
holds for this case.
Case 2b.2: If I(goals )) ∈ I(goals ), the generated decision results in
1(k+1)i 10i
the shift of the current focused goal. Based on Lines 31-32, sub = id :
2(k+1)i
(I(B ),I(goals [1 :])). This modification calibration with the vGOAL
2(k+1) 2(k′+1)
semanticsupdateforthetwostates,s ands whereI(B )=I(B ),I(goals )=
2k 2k′ 2k 2k′ 2k
I(goals ), and goals ̸=goals .
2k′ 2k 2k′
Bysymmetry,foreachpathπ ∈Paths(s ),thereexistsapathπ ∈Paths(s )of
2 2 1 1
thesamelengthwhichisstatewiserelatedtoπ .Therefore,followingDefinition6,the
2
condition b.3 of the bisimulation equivalence is proven. Moreover, the state properties
of TS and TS are generated by vGOAL semantics updates, and the condition b.1 of
1 2
the bisimulation equivalence is proven.
Theorem 2. Algorithm 2 generates an equivalent DTMC for a given vGOAL
specification of n-agent autonomous system in terms of operational semantics.
11Proof. Following Definition 1, the given vGOAL specification is defined as
vGOALSpec ::= (MAS,K,C,A,S,P,E,D,Prob,Safety) and MAS ::=
(id,B,goals,M ,M )n, we denote the probabilistic semantics of vGOALSpec as D ;
S R 1
we denote the DTMC generated by Algorithm 1 as D . Following Definition 8, D
2 1
and D are in the form D ::= (S ,P,ι ,AP ,L ),i ∈ {1,2}. We show D is proba-
2 i i init i i 1
bilistic bisimulation-equivalent to D , denoted D ∼ D , and ∼ is an equivalence
2 1 D 2 D
relation for Markov chains, denoted R ,therefore, D ≡D .
id 1 2
Algorithm 2 computes the DTMC based on the generated transition system of
Algorithm 1. Therefore, D and TS (i = {1,2}) are equivalent except the model
i i
of uncertainty. According to Theorem 1, TS ≡ TS , D and D are equivalent on
1 2 1 2
(S ,AP ,L ),i ∈ {1,2}. Hence, to show D ≡ D , we only need to show the proba-
i i i 1 2
bilistic bisimulation between D and D .
1 2
Following Definition 10, we need to prove condition a and condition b to show the
equivalence. Each state of the vGOAL specification has a bijective state of D .
2
Consequently, condition a is proven. Each states in D have a bijective state in D .
1 2
Therefore, each probabilistic transition in D has a bijective probabilistic transition
1
in D . The form of each probabilistic transition in D is (s ,p,s ), which has a cor-
2 1 1 2
responding transition in TS in the form (s ,Acts,s ). p is determined by the Acts
1 1 2
and Prob. For each transition in TS , there is a corresponding equivalent transition
1
in TS . Each probabilistic transition in D is determined by its corresponding transi-
2 2
tion in TS and the probability specifications of each action. Hence the condition b is
2
proven.
5 Quick Error Detection
ThissectionpresentstwoalgorithmsthatareusedtoquicklydetecterrorsforavGOAL
specification, which involves many agents and each agent has multiple goals. The
hypothesis of the quick detection algorithms is a finite set of different goals for each
agent.
5.1 Algorithms
Algorithm3simplifiesavGOALspecificationforaone-agentsystem.Thegiveninput
is a vGOAL specification for a one-agent system. The agent has many goals. The
output is also a vGOAL specification. The difference between the input and output
is only the goal specification. goals is the goal specification of the input, and goals
1 2
is the goal specification of the output. Goals stores different goals. Each goal is an
i
element of Goals.
Algorithm4detectserrorsofavGOALspecificationforan-agentsystemthateach
agent has multiple goals by model checking safety properties and liveness properties.
First,itemploysAlgorithm3togenerateasetofvGOALspecificationsforaone-agent
system. Algorithm 1 transforms each generated specification to a transition system.
Second,itgeneratesasetofvGOALspecificationsforan-agentsystem,inwhicheach
agent has one goal. The generated vGOAL specifications for a n-agent system cover
all possibilities of the goal combination of all agents within the autonomous systems.
Safety checking is applied to each generated transition system. Liveness checking is
12Algorithm 3: Reduce a vGOAL specification for a one-agent system
Input: vGOALSpec ::=(MAS ,K,C,A,S,P,E,D),
1 1
MAS ::=(id,B,goals ,M ,M ),
1 S R
goals ::=goal goal ...goal goal , Goals::={G ,...,G }
1 1 2 n−1 n 1 m
∀1≤j ≤n.goal ∈Goals, 1≤n, 1≤m
j
Output: vGOALSpec ::=(MAS ,K,C,A,S,P,E,D),
2 2
MAS ::=(id,B,goals ,M ,M )
2 2 S R
1 vGOALSpec 2 ←vGOALSpec 1, goals 2 ←goal 1
2 goals 1 ←goal 2...goal n−1, D G ←∅
3 for each goal i ∈goals 1 do
4 if Goals̸=D G then
5 if goal i ∈/ D G then
6 goals 2 ←goals 2goal i
7 D G ←D G∪{goal i}
8 return vGOALSpec 2
used to check if all agent goals will be finally achieved. Errors records all property
violations during all model-checking processes.
5.2 Theoretical Proofs
Theorem 3. Given a vGOAL specification for a one-agent system, vGOALSpec ,
1
where goals ::= goal ...goal , Algorithm 3 reduces vGOALSpec to vGOALSpec ,
1 1 n 1 2
where goals ::= goal ...goal . Algorithm 1 generates a transition systems TS
1 1 k 1
with the state space S for vGOALSpec , and TS with the state space S for
1 1 2 2
vGOALSpec . S =S .
2 1 2
Proof. We prove the theorem by induction on n.
Base case (n=1) S ::= (I(B),I(goals )), S ::= (I(B), I(goals )), I(goals ) =
10 1 20 2 1
I(goals ). Algorithm 1 will go through the same transition system generation process
2
forthesameinitialstateuntilthecurrentfocusedgoalisshiftedfromtheinitialstate.
Therefore, S =S .
1 2
Induction Step Assume n≥0, S =S . For the n+1-th goal of goals , if ∀2≤i≤
1 2 1
n.goal ̸= goal , goals is also extended by goal . Algorithm 1 will go through
i n+1 2 n+1
the same transition system generation process for the same state until the current
focused goal is shifted. Therefore, S =S . If ∃2≤i≤n.goal =goal , goals will
1 2 i n+1 2
not be extended by goal . Algorithm 1 will extend TS to achieve goal , but the
n+1 1 n+1
generationprocessforgoal isthesameasthegenerationprocessforgoal .Nonew
n+1 i
stateswillbegeneratedinthiscase.S willnotbemodifiedbythegenerationprocess.
1
Therefore, S =S .
1 2
Theorem 4. Given a vGOAL specification for a n-agent system with multiple goals,
vGOALSpec, Algorithm 4 processes it to generate Errors as the output. Errors̸=∅
implies vGOALSpec isnot asoundspecification thatcansuccessivelyachieve allgoals
of each agent without violating all safety properties.
13Algorithm 4: Detect errors of a vGOAL specification for a n-agent system
with multiple goals
Input: vGOALSpec ::=(MAS ,K,C,A,S,P,E,D),
1 1
MAS ::=(i,B,goals ,M ,M )n, goals ::=goal goal ...goal ,
i S R i i1 i2 ini
1≤i≤n , Goals::={G ,...,G } ∀1≤j ≤n .goal ∈Goals, 1≤n,
i 1 m i ij
1≤m, P
safe
Output: Errors
1 D
←(cid:83)n
{i:∅}, Errors←∅
i=1
2 for each MAS i ∈MAS do
3 Spec←(MAS i,K,C,A,S,P,E,D)
4 Spec 1 ←Algorithm 3(Spec)
5 TS 1 ←Algorithm 1(vGOALSpec)
6 if TS 1 ̸|=P safe then
7 Errors←Errors∪{(i,TS 1 ̸|=P safe)}
8 for each goal∈goals do
9 if TS 1 ̸|=♢goal then
10 Errors←Errors∪{(i,TS 1 ̸|=♢goal)}
11 Goals←Πn i=1|D G[i]|
12 for each (g 1,...,g n)∈Goals do
13 vGOALSpec 2 ←vGOALSpec 1
14 for each agent i ∈MAS do
15 goals i ←g i
16 TS n ←Algorithm 1(vGOALSpec 2)
17 if TS n ̸|=P safe then
18 Errors←Errors∪{((g 1,...,g n),TS n ̸|=P safe)}
19 if TS n
̸|=♢(cid:86)n
i=1goal i then
20 Errors←Errors∪{TS n
̸|=♢(cid:86)n
i=1g i}
21 return Errors
Proof. Errors ̸= ∅ implies at least one error is detected during the model-checking
process. If (i,TS ̸|= P ) ∈ Errors, vGOALSpec will generate unsafe deci-
1 safe
sions when successively achieving all goals of agent . If (i,TS ̸|= ♢goal) ∈ Erros,
i 1
vGOALSpeccannotgeneratedecisionstoachievegoalforagent .If{((g ,...,g ),TS
i 1 n n
̸|= P )} ∈ Errors, vGOALSpec will generate unsafe decisions when generating
safe
decisions to simultaneously to achieve g for agent . If {TS
̸|=♢(cid:86)n
g }∈Errors,
i i n i=1 i
vGOALSpec cannot generate decisions for an n-agent system to achieve each goal of
each agent if the goals combination is (g ,...,g ). Any error of these four types makes
1 n
the vGOAL specification not sound.
146 Empirical Analysis
ThissectionillustratestheefficiencyandtheusageoftheautomatedCTLandPCTL
model-checking process of vGOAL. First, we briefly introduce the case study and its
scenarios for experiments. Second, we present how to use the CTL and PCTL model-
checking process to verify a vGOAL specification. Finally, we show how to quickly
detect errors in a complicated vGOAL specification. We use a real-world autonomous
logistic system, involving three autonomous mobile robots, to conduct an empirical
analysis. All experiments are conducted with a MacBook Air 2020 with an Apple M1
and16GBofRAM.AllvGOALspecificationsandexperimentresultsdescribedinthis
section are available at [23].
6.1 Case Study
The autonomous logistic system is expected to work in a warehouse environment,
shown in Figure 2. It aims to autonomously and continuously transport workpieces
from two pick-up stations (P and P ) to one drop-off station (P ) while adhering to
3 4 2
all safe requirements. Each agent can have many transportation goals, but it only can
have two different transportation goals, namely transporting a workpiece from P to
3
P or from P to P . Three agents collaboratively deliver workpieces, but they also
2 4 2
compete for permission for locations to avoid collision among agents.
Fig. 2 LayoutoftheWarehouseEnvironment
In this case study, each agent can perform four actions: pick, drop, charge, and
move.Eachactioncansucceedorfail.Forthetwoactions:pick anddrop,andcharge,
theirfailureisnotfatalfortheagent.Forthechargeaction,itsfailurewillleadtothe
failure of the corresponding agent. For the move action, its failure can have possible
consequences. The first possible consequence is a docking error, which is not fatal to
15the agent. The second possible consequence is a move-base error, which leads to a
system crash.
We use vGOAL to specify the decision-making mechanism of the autonomous
logistic systems. The agent specifications are listed as follows:
1 beliefs1 = ["at(6)", "battery(1)", "docked(6)", "assigned(6)"]
2 beliefs2 = ["at(7)", "battery(1)","docked(7)","assigned(7)"]
3 beliefs3 = ["at(8)", "battery(1)","docked(8)","assigned(8)"]
4 beliefs4 = ["idle(2)", "idle(3)", "idle(4)","idle(5)",
5 "reserved(A1,6)", "reserved(A2,7)", "reserved(A3,8)"]
6 g1 = [’transport(3,2)’]
7 g2 = [’transport(4,2)’]
8 goals4 = []
9 Agent1 = Agent("A1", beliefs1, goals1)
10 Agent2 = Agent("A2", beliefs2, goals2)
11 Agent3 = Agent("A3", beliefs3, goals3)
12 Resource = Agent("R", beliefs4, goals4)
13 System=[A1, A2, A3, R]
System specifies all agents involved in the specified autonomous system. Agent1
specifiestheautonomousmobilerobotlocatingatP ,Agent2specifiestheautonomous
6
mobilerobotlocatingatP ,andAgent3specifiestheautonomousmobilerobotlocat-
7
ing at P . Resource specifies a resource agent that manages the critical resources. g
8 1
and g are two delivery goals. goals , goals , and goals can contain many goals, but
2 1 2 3
each goal can be either g or g , e.g., goals1=[g ,g ,g ,g ,g ].
1 2 1 1 2 2 1
The autonomous logistic system is expected to always satisfy two safety require-
ments: safe battery levels and safe locations. The related safety specifications are
specified in vGOAL as follows:
1 "battery(1) implies safe1",
2 "battery(2) implies safe1",
3 "exists p. at(p) and not at(9) implies safe2",
4 safety_properties = {"A1": ["safe1", "safe2"], "A2": ["safe1","
safe2"], "A3": ["safe1","safe2"]}
6.2 Model-Checking Analyses
Given a vGOAL specification, the automated CTL and PCTL model-checking pro-
cesses will automatically generate the CTL and PCTL analyses. Obviously, CTL and
PCTL are not semantically equivalent. Hence, they can express different properties,
andwecanuseCTLandPCTLmodel-checkingprocessestoverifydifferentproperties.
However, CTL and PCTL can also equivalently express some qualitative properties,
and we can use them to compare the efficiency of CTL and PCTL model-checking
processes for vGOAL.
Toallowtheefficiencycomparisonofthesetwomodel-checkinganalyses,wedefine
twoqualitativepropertiesthatcanbeequivalentlyexpressedinbothCTLandPCTL.
Consequently, these properties have the same satisfaction results for a given vGOAL
specification.
16First, we verify there exists a path where no errors happen and it finally reaches a
final state, which can be equally formalized in CTL and PCTL as follows:
• CTLSPEC EG (non-errors→ EF (liveness)),
• P >0 [non-errors U non-errors ∧ liveness].
Both properties have the same satisfaction results.
Second, safety properties can be equally formalized in CTL and PCTL as follows:
• CTL in NuSMV: CTLSPEC AG safety.
• PCTL in Storm: P >=1 [G safety].
Table 1 EfficiencyofModelGenerationandModelChecking
NuSMV Storm NuSMV Storm
N Agent1 Agent2 Agent3 States
Input(s) Input(s) Check(s) Check(s)
3 g1 g1 g1 1799 90.19 89.37 1.70 6.96
3 g1 g2 g1 3338 213.38 213.31 4.75 13.44
3 g1,g1 g2 g1 5923 559.16 558.18 13.28 29.76
3 g1,g1 g1,g1 g2 9975 1398.40 1400.85 38.42 80.02
3 g1,g1 g2,g2 g1 10598 1581.14 1583.39 59.13 87.10
3 g1,g1 g1,g1 g1,g1 8484 1067.45 1069.13 27.94 61.68
3 g1,g1 g2,g2 g1,g1 16139 3321.36 3318.55 95.27 181.55
3 g1,g2 g2,g1 g1,g2 22572 6320.08 6362.64 224.78 348.48
3 g1,g1,g1 g2,g2,g2 g1,g1,g1 22652 6408.20 6687.92 220.19 322.29
3 g1,g2,g1 g2,g1,g1 g1,g2,g1 45743 25022.82 25008.40 1461.47 2153.32
Table1presentsthetimerequiredforgeneratingtheinputmodelsandperforming
model checking for 27 representative scenarios of the case study. N represents the
numberofagentsincludedinthesystem.Agent1,Agent2,andAgent3representthree
AMRs that can be part of the system, whose value represents its goals. States shows
the number of states of the generated model for the given vGOAL specification.
NuSMVInput and StormInput represent the time taken from the given vGOAL
specification to the inputs of NuSMV and PRISM, respectively. The time for
generating the inputs for both NuSMV and PRISM is almost the same.
NuSMVCheck andStormCheck representthetimetakentoverifythetwoquali-
tativepropertiesofNuSMVandPRISM,respectively.NuSMVgenerallyshowsslightly
faster to verify these properties compared with PRISM across all scenarios. However,
the magnitudes of their efficiency are still the same. We notice that the relative dif-
ference in the model checking between the NuSMV and Storm becomes smaller with
the increase in the complexity of the system.
The efficiency of the CTL and PCTL model-checking for vGOAL depends on the
efficiencyofthemodelgenerationandthemodelchecking.Basedontheresultsshown
in Table 1, the efficiency of the model generation is almost the same for both model-
checkinganalyses.Moreover,NuSMVisslightlyfasterthanStormbutwithinthesame
magnitude.
17ResultsinTable1reflectsthebottleneckofmodelchecking:state-spaceexplosion.
For example, the total state space increases dramatically from 1,799 to 45,743 states
as the goals for each agent expand from one to three. Consequently, the total time for
themodel-checkingprocessesincreasesfromlessthan2minutestomorethan7hours.
In autonomous systems, each agent typically has multiple goals. When dealing
with complex systems consisting of numerous agents, each with many goals, the time
required for model checking can become substantial. Thus, it is crucial and practical
to quickly detect errors for a complicated vGOAL specification. Instead of directly
verifying the whole state space for such a complicated system, we first choose to
efficiently verify the most properties such as safety and liveness of the complicated
system using Algorithm 4.
Table 2 EfficiencyofCTLModelCheckingUsingQuickErrorDetection
Algorithm
NuSMV NuSMV
N Agent1 Agent2 Agent3 States
Input(s) Check(s)
1 g1,g2,g1 142 4.26 0.09
1 g2,g1,g1 125 3.68 0.08
1 g1,g2,g1 142 4.24 0.08
3 g1 g1 g1 1799 90.19 1.70
3 g1 g2 g1 3338 213.38 4.75
3 g1 g1 g2 3660 240.56 5.694
3 g1 g2 g2 2976 179.33 4.22
3 g2 g1 g1 2976 181.05 4.26
3 g2 g2 g1 3660 242.06 5.77
3 g2 g1 g2 3338 211.61 4.84
3 g2 g2 g2 1799 90.68 2.07
Total 24355 1461.62 39.51
WeusethelastscenariopresentedinTable1astheexampletoillustratetheusage
and efficiency of Algorithm 4 for quick error detection. As shown in the last row of
Table1,thetotalstatesis45743,thetimeforgeneratingNuSMVinputsandNuSMV
checking is 25022.82 seconds and 1461.47 seconds, respectively.
For the last scenario, Algorithm 4 generates three one-agent autonomous systems
and eight three-agent autonomous systems. We use the automated CTL model-
checking processes to obtain 11 CTL model-checking analyses for safety and liveness
properties. The total verified states of the 11 model-checking analyses is 24355.
The total time for generating NuSMV inputs and NuSMV checking of the 11
model-checking analyses is 1461.62 seconds and 39.51 seconds, respectively.
Notably,thetotalverifiedstatesacrossthese11analysesarereducedfrom45743to
24355.However,thetimerequiredforgeneratingNuSMVinputsdecreasessignificantly
fromto25022.82to1461.62seconds.Moreover,theNuSMVcheckingprocessisfurther
drastically reduced from 1461.47 to 39.51 seconds. These results demonstrate that we
can use Algorithm 4 to efficiently detect errors of vGOAL specifications, particularly
in complex scenarios.
187 Conclusion
This paper presents CTL and PCTL automated model-checking processes for
vGOAL, enabling obtaining sound vGOAL specifications for complex and real-world
autonomous decision-making. Compared with other model-checking approaches of
APLs, the presented model-checking process of vGOAL has three main advantages.
First, it has an efficient model-checking process. The experiment results demonstrate
that the CTL and PCTL model-checking processes for vGOAL can efficiently verify
the vGOAL specifications in real-world scenarios. Second, the semantic equivalence
is established for both nondeterministic models and probabilistic models of vGOAL:
fromvGOALtotransitionsystemsorDTMCs.Third,Algorithm4isproposedtoeffi-
cientlyverifywhetheravGOALspecificationviolatessafetyorlivenessproperties.This
algorithm is especially useful for complex scenarios. We plan to conduct an empirical
analysis for similar approaches, like model checking Gwendolen using MCAPL.
References
[1] Shoham, Y.: Agent-oriented programming. Artificial intelligence 60(1), 51–92
(1993)
[2] Bordini,R.H.,Hu¨bner,J.F.:BDIagentprogramminginAgentSpeakusingJason.
In: International Workshop on Computational Logic in Multi-agent Systems, pp.
143–164 (2005). Springer
[3] Dennis, L.A., Farwer, B.: Gwendolen: A BDI language for verifiable agents. In:
ProceedingsoftheAISB2008SymposiumonLogicandtheSimulationofInterac-
tionandReasoning,SocietyfortheStudyofArtificialIntelligenceandSimulation
of Behaviour, pp. 16–23 (2008). Citeseer
[4] Hindriks,K.V.:ProgrammingrationalagentsinGOAL.In:Multi-agentProgram-
ming, pp. 119–157. Springer, Berlin, Heidelberg (2009)
[5] Yang, Y., Holvoet, T.: vGOAL: a GOAL-based specification language for safe
autonomous decision-making. In: Engineering Multi-Agent Systems: 11th Inter-
nationalWorkshop,EMAS2023,London,UK,29-30May2023,RevisedSelected
Papers (2023)
[6] Yang, Y., Holvoet, T.: Safe autonomous decision-making with vGOAL. In:
Advances in Practical Applications of Agents, Multi-Agent Systems, and Cogni-
tive Mimetics. The PAAMS Collection (2023). Guimar˜aes, Portugal
[7] Weiss,G.:MultiagentSystems,p.462.TheMITPress,Cambridge(2013).Chap.
14
[8] Bordini, R.H., Fisher, M., Pardavila, C., Wooldridge, M.: Model checking
AgentSpeak. In: Proceedings of the Second International Joint Conference on
Autonomous Agents and Multiagent Systems, pp. 409–416 (2003)
19[9] Dennis, L.A., Fisher, M., Webster, M.P., Bordini, R.H.: Model checking agent
programming languages. Automated software engineering 19(1), 5–63 (2012)
[10] Jongmans, S.-S.T., Hindriks, K.V., Van Riemsdijk, M.B.: Model checking agent
programs by using the program interpreter. In: Computational Logic in Multi-
Agent Systems: 11th International Workshop, CLIMA XI, Lisbon, Portugal,
August 16-17, 2010. Proceedings 11, pp. 219–237 (2010). Springer
[11] Dennis, L.A., Fisher, M., Webster, M.: Two-stage agent program verification.
Journal of Logic and Computation 28(3), 499–523 (2018)
[12] Cimatti,A.,Clarke,E.,Giunchiglia,F.,Roveri,M.,etal.:Nusmv:Anewsymbolic
model verifier. In: CAV, vol. 99, pp. 495–499 (1999). Citeseer
[13] Dehnert, C., Junges, S., Katoen, J.-P., Volk, M.: A Storm is coming: A modern
probabilistic model checker. In: International Conference on Computer Aided
Verification, pp. 592–600 (2017). Springer
[14] Holzmann, G.J.: The model checker spin. IEEE Transactions on software engi-
neering 23(5), 279–295 (1997)
[15] Dennis, L.A.: The mcapl framework including the agent infrastructure layer and
agent java pathfinder. The Journal of Open Source Software (2018)
[16] Winikoff, M.: Implementing commitment-based interactions. In: Proceedings of
the 6th International Joint Conference on Autonomous Agents and Multiagent
Systems, pp. 1–8 (2007)
[17] Dastani,M.,Tinnemeier,N.A.,Meyer,J.-J.C.:Aprogramminglanguagefornor-
mative multi-agent systems. In: Handbook of Research on Multi-Agent Systems:
SemanticsandDynamicsofOrganizationalModels,pp.397–417.IGIGlobal,???
(2009)
[18] Kwiatkowska,M.,Norman,G.,Parker,D.:Prism4.0:Verificationofprobabilistic
real-time systems. In: Computer Aided Verification: 23rd International Confer-
ence, CAV 2011, Snowbird, UT, USA, July 14-20, 2011. Proceedings 23, pp.
585–591 (2011). Springer
[19] Eker, S., Meseguer, J., Sridharanarayanan, A.: The maude ltl model checker.
Electronic Notes in Theoretical Computer Science 71, 162–187 (2004)
[20] Yang, Y., Holvoet, T.: Making model checking feasible for GOAL. In: 10th
International Workshop on Engineering Multi-Agent Systems (2022)
[21] Yang, Y., Holvoet, T.: Making model checking feasible for goal. Annals of
Mathematics and Artificial Intelligence (2023)
[22] Baier, C., Katoen, J.-P.: Principles of Model Checking. MIT Press, Cambridge,
20MA (2008)
[23] Yang, Y.: Supplementary Material. https://kuleuven-my.
sharepoint.com/:f:/g/personal/yi yang kuleuven be/
EjUTI-DUvkdBlBKoNWxcVgIB8GMfhyAZHSA i1b7ovskqw?e=Ox2qHh
(2024)
21