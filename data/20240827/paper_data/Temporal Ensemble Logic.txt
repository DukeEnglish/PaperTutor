Temporal Ensemble Logic
∗ Guo-Qiang Zhang
August 27, 2024
Abstract
We introduce Temporal Ensemble Logic (TEL), a monadic, first-
order modal logic for linear-time temporal reasoning. TEL includes
primitivetemporalconstructssuchas“alwaysuptottimelater”(□ ),
t
“sometimes before t time in the future” (♢ ), and “t-time later” φ .
t t
TEL has been motivated from the requirement for rigor and repro-
ducibility for cohort specification and discovery in clinical and popu-
lation health research, to fill a gap in formalizing temporal reasoning
in biomedicine. In this paper, we first introduce TEL in a general set
up, with discrete and dense time as special cases. We then focus on
the theoretical development of discrete TEL on the temporal domain
of positive integers N+, denoted as TELN+. TELN+ is strictly more
expressive than the standard monadic second order logic, character-
ized by Bu¨chi automata. We present its formal semantics, a proof
system, and provide a proof for the undecidability of the satisfiability
of TELN+. We also discuss expressiveness and decidability fragments
for TELN+, followed by illustrative applications.
1 Introduction
We introduce Temporal Ensemble Logic (TEL), motivated from the require-
ment for rigor and reproducibility for cohort specification and discovery in
∗
Department of Neurology, McGovern Medical School and Department of Health
Data Science and Artificial Intelligence, McWilliams School of Biomedical Informat-
ics; Texas Institute for Restorative Neurotechnologies; The University of Texas Health
Science Center at Houston; 1133 John Freemen Ave, Houston, Texas, 77030, USA;
guo-qiang.zhang@uth.tmc.edu
1
4202
guA
62
]OL.sc[
1v34441.8042:viXraclinical and population health research, to fill a gap in formalizing tempo-
ral reasoning in biomedicine [1, 2]. We treat clinical codes and ontological
terms [3] as atomic propositions; temporal relationships as temporal modal
operators [4]; real-world data records [5, 6, 7] as semantic models; cohort
specifications [8] as logical formulas; and cohort discovery [9] as model-
checking [10, 11], as summarized in the following table:
Table 1. Correspondence for logic-based cohort discovery
Biomedical entities Logical constructs Logical forms
Controlled vocabularies, Atomic propositions Prop
ontology terms
Temporal relationships Modal and logical op- □,♢,∧,∃
erators
Real-world Data Semantic models (E,s)
Cohort specifications Logical formulas φ
Cohort discovery Model-checking (E,s) |= φ
The development and contribution of this paper draw on background
knowledge around temporal logics [12, 13, 14, 15], especially linear tempo-
ral logic (LTL [16]). Temporal logic is a branch of symbolic logic involving
propositions that have truth values dependent on time. It extends clas-
sical logics with modality constructs for specifying temporal relationships
among propositions, such as “before,” “after,” “during,” and “until.” This
way, the expressiveness of logic is expanded to include temporal constraints
that can be used for modeling temporal properties of a “system.” Logical
formula specifying an abstract constraint on the behavior of dynamical (e.g.,
cyber-physical) systems can then be verified against semantic models that
represent the design of the systems at different levels of abstraction (or, of
interest). Such formulas often refer to qualitative or quantitative time, e.g.,
the relative order of events or specific moments of time when certain events
may occur or system dynamics may take specific values. Because of these
general attributes, temporal logics have found wide ranging applications in
cyber-physical systems: they can be used to formally specify the desired be-
havior of these systems and to verify that the systems satisfy the specified
properties.
The backbone of a temporal logic has two types of operators: modal op-
erators and logical operators. The precise meaning of formulas in temporal
logics is reflected in their formal semantics, usually interpreted in mathe-
2matical structures such as Kripke frames, labeled transition systems, or au-
tomata [14, 15]. Nodes in such structures represent basic temporal states (as
a time point or time interval) and temporal changes are captured as relations
amongthestates. Differentmodaloperatorsinsyntax, coupledwithdifferent
classes of semantic structures, further expand their richness and complexity.
Animportantapplicationparadigmoftemporallogicismodel-checking[10,
11]. Model-checking is concerned with efficient algorithms verifying that a
certainsystemoritsdesign(representedasasemanticstructureM)meetsin-
tended properties (represented as a formula φ), expressed as M |= φ. There
is a rich body of knowledge around the model-checking paradigm, reflecting
their modeling power and practical applicability.
InrecentworkguidedbytheconceptualcorrespondenceinTable1, wein-
troduced Temporal Cohort Logic (TCL [17]) by explicitly representing Allen
relations as modal operators in the syntax, rather than modeling them in
the semantic structure. We also developed experimental cohort discovery
systems leveraging TCL to demonstrate feasibility in implementing the tem-
poral operators for a large clinical Electronic Health Record (EHR) data set
with temporal query interfaces backed by a query engine.
Although formulas in TCL are more readable by humans, the temporal
modalities were not formulated at a level of granularity suitable for further
theoretical development. On the other hand, LTL [16] is too restrictive to
express temporal and sequential properties in biomedicine. This is the key
motivationbehindTEL(thefocusofthecurrentpaper), whichconsistsofthe
standard boolean connectives; bounded time-term modalities □ φ and ♢ φ;
t t
first-order quantification over time variables ∀tφ and ∃tφ; and perhaps most
important, the ability to turn any such formulas into a monadic relation φ .
t
For example, the standard “next-time” operator in discrete linear temporal
logic is captured by φ , representing 1-unit of time in the future.
1
Distinct features of TEL from existing temporal logics include:
1. TEL is a class of monadic first-order linear-time temporal logics with
first-order quantifiers over time-length variables, rather than references
to absolute time or location, nor to additional ontological apparatus
such as process identifiers or traces. Because of this, TEL can be seen
as a minimalistic extension of LTL.
2. Time-terms are explicitly and independently defined syntactic entities
withadditionastheonlyrequiredoperation, intheformofs+t. Thisis
3semantically interpreted over a totally ordered monoid, which contain
a variety of linear structures as special cases.
3. AnyTELformulaφcanbeturnedintoameaningfulmonadicpredicate
φ that can be combined freely with other temporal and first-order
t
constructs of TEL. Thus the syntactic overhead of TEL is minimal.
Intuitively, φ stands for “φ is true at t-time in the future.”
t
4. Thecombinationoftime-termadditions+twithlogicalconstructssuch
as □ φ, ♢ φ, ∀tφ, and ∃tφ provides tremendous expressive power, and
t t
yet allows fragments of TEL to be defined with better computational
tractability (e.g. the ∃,□ fragment).
5. Direct comparison of time-length terms, such as s ≤ t and associated
boundedquantifications,thoughtempting,isnotincludedinthesyntax
of TEL formulas in the treatment provided in this paper.
6. Constructs of TEL are motivated and expected to be well-suited to
express phenotypic properties in biomedicine adequately with logical
precision, without too much overhead or modification (see Sections 6
and 7). Because of this motivation, the semantic structures defined by
TEL formulas tend to be able to capture rich combinatorial properties.
7. The simple and straightforward set up of the syntax and semantics for
TEL makes it readily enrichable or modifiable to other settings, such
as interval, weighted, and metric logics.
In the rest of the paper we first introduce TEL in a general set up, with
discrete and dense time as special cases in Section 2. In Section 3, we fo-
cus on theoretical development of discrete TEL on the temporal domain of
N+, denoted as TEL for the set of positive integers. Note that TEL is
N+ N+
strictly more expressive than the standard monadic second order logic, char-
acterized by Bu¨chi automata. We believe that TEL is a new logic not studied
before and represents a unique approach to supporting temporal reasoning
in biomedicine. We also describe an equational proof system for TEL .
N+
In Section 4, we present a detailed proof that the satisfiability of TEL
N+
formulas is undecidable by reducing the Post-Correspondence Problem to
TEL -satisfiability. In Sections 5, we present results on expressiveness of
N+
TEL , followed by illustrative applications in Section 6 that have motivated
N+
TEL. Discussions and conclusions are provided at the end of the paper.
42 Temporal Ensemble Logic (TEL)
2.1 Syntax
The basic construct of TEL includes two types of terms: time-length terms
(or simply, time terms), and logical formulas. Time terms s,t,u,v,... consist
of time constants a,b,c,..., time variables x,y,z,... (from a set Var), and
the addition of these terms s + t. In Backus–Naur form (BNF), we define
the following syntax for time terms:
s,t ::= a | x | s+t,
where a comes from a set of time constants, x comes from a countable set
of time variables, and s+t represent the addition of two time valued terms.
For conciseness, we write nt to represent the addition (+) of n copies of t:
nt := t+t+···t. We write Term for the set of all terms.
Logical formulas φ consist of atomic propositions p, time-length indexed
formulas φ , Boolean connectors (∧, ∨, ¬), time-length indexed modalities
t
□ φ and ♢ φ, and existential quantification over time-lengths: ∃xφ, ∀xφ.
t t
We define, with t for time term and x for time-length variable:
φ,ψ ::= p | φ | ¬φ | φ∧ψ | φ∨ψ | □ φ | ♢ φ | ∃xφ | ∀xφ,
t t t
where atomic propositions p come from a pre-defined set Prop. We allow
the “nesting” of time-termed subscripts φ for an arbitrary TEL formula φ,
t
turning any such formula φ into a unary predicate (over time-lengths, or
simply, time).
We call TEL a timed, monadic, first-order linear-time, temporal logic.
From now on, we use the term “time” with “time-length” interchangeably.
It will be clear from our semantic definitions that we refer to time as time-
lengths, and it is not the intention of TEL to refer categorically to absolute
time values. TEL is a (class of) time-indexed modal logic because the in-
tuition for □ φ and ♢ φ is to capture the properties that φ is always true
t t
until t time later, and φ is sometimes true within t time in the future. For
convenience, we abbreviate □ as □, and ♢ as ♢, where □ φ stands for
∞ ∞ ∞
φ∧∀xφ and similarly, □ φ for φ∨∃xφ , assuming that x does not occur
x ∞ x
free in φ. Alternatively, one could explicitly introduce ∞ as an explicit time
term, with its usually intended meaning.
Note that TEL is not a conventional monadic, first-order modal logic in
that the monadic predicates are not supplied as a predetermined list of unary
5predicates, but rather any formula φ and any modalities □,♢ can become
monadic predicates in the form of: φ , □ φ, ♢ φ, where x is a time-length
x x x
variable (which can occur freely in φ as well).
For exposure, we have not been economical in using a minimal set of
logical constructs, which could be convenient when it comes to the number
of cases to be considered in proofs. For example, we can avoid using ∨
without loosing expressive power. Similarly, □ can be expressed as ¬♢ ¬,
t t
and ∀ can be expressed as ¬∃¬, and φ → ψ as ¬φ∨ψ.
Remarks. Some comments are in order to clarify the TEL syntax: (1)
by convention, we can use a ∨ ¬a for ⊤ (true), and a ∧ ¬a for ⊥ (false);
(2) nesting of time-indexed formula is allowed, such as (φ ) , but as can
u v
be seen immediately after we have introduced the semantic interpretation,
we have the entailment (φ ) |= φ . This implies that nesting of indices
u v u+v
does not necessarily increase expressive power; (3) the distinction between
the semantics of formulas ♢φ and ∃xφ is subtle but important. While ♢φ
capturesthesituationthatφ istrueatsometime-lengthafromnowon, ∃xφ
a
involves the instantiation (bounding) of all free variables x in the body of φ
by some common time-lenght value b, and the resulting formula φ evaluates
to true with the environment where the variable x is assigned value b in
the time-length domain. On the other hand, to evaluate ♢φ, all free (time)
variables in φ must already have their pre-assigned values in an evaluation
context (a.k.a “environment”), while the free variables in the body of ∃xφ
do not have pre-assigned values in an evaluation context; their values are to
be determined.
2.2 Semantics
To capture the formal semantics of TEL in the general setting, we describe
the mathematical structure in which TEL formulas can be interpreted or
evaluated. OurtimestructureisM+,whereMisanon-negativecommutative
monoid M that contains 0,+. Such structures include positive integers N+,
positive rational numbers Q+, positive real numbers R+, and positive p-adic
numbers. We also require that such commutative monoid M comes with
a total order < compatible with +, with the property that a < b if and
only if a + c = b for some c > 0. The order < is further assumed to be
non-degenerative, in the sense that for any x ̸= 0, a < a+x for all a ∈ M+.
The reason for considering positive numbers is for technical elegance for
the most part. In particular, for formulas of the form ∃x(□ φ) and ∀x(♢ φ)
x x
6to be non-degenerative, we need to assume that x ̸= 0. Otherwise, we would
have ∃x(□ φ) to be vacuously true because □ φ is true, and ∀x(♢ φ) to be
x 0 x
vacuously false because ♢ φ is false, irrespective of what φ is. Incorporating
0
the requirement that for positive time-length terms in the semantic setup
would avoid such degenerative cases and allow TEL to express genuinely
interesting properties using the ∃x(□ φ) and ∀x(♢ φ) combinations.
x x
An evaluation environment E consists of a triple (α,β,η), where α :
M+ → 2Prop is called an interpretation, β : Term → M+ a term assignment,
and η : Var → M+ a variable assignment. As usual, 2Prop represents the
power set of atomic propositions Prop. We require that the term assignment
β preserve the operational meanings of time terms, in the sense that
β(s+t) = β(s)+β(t)
for all terms s and t.
Definition 1. The meaning of TEL formulas can be specified as follows with
respect to an environment E := (α,β,η), and time point s ∈ M+:
(E,s) |= p if p ∈ α(s);
(E,s) |= ¬φ if (E,s) ̸|= φ;
(E,s) |= φ∧ψ if (E,s) |= φ and (E,s) |= ψ;
(E,s) |= φ∨ψ if (E,s) |= φ or (E,s) |= ψ;
(E,s) |= φ if (E,(s+β(t))) |= φ;
t
(E,s) |= ♢ φ if there exists u with s ≤ u < s+β(t), (E,u) |= φ;
t
(E,s) |= □ φ if for all u such that s ≤ u < s+β(t), (E,u) |= φ; and
t
(E,s) |= ∃xφ if there exists a ∈ M+, (E′,s) |= φ;
(E,s) |= ∀xφ if for all a ∈ M+, (E′,s) |= φ,
where E′ is obtained by modifying η in environment E as η[x := a], which is
the variable assignment modified from η by assigning x to a but with every-
thing else remains unchanged.
Intuitively, α defines, for each time point a ∈ M+, a subset (empty set
allowed) P of Prop where all the propositions in P holds at time a. Such set
a a
P can represent a patient’s medical history or other study item’s recorded
a
properties over time, often documented in EHR.
Remarks. (1)Tobefullyrigorous,weexplicitlyintroducedα,β,andη as
the evaluation context. However, as can be seen, not each of these functions
plays a role for each clause in the above definition. To avoid notational
7clutter, we sometimes avoid mentioning all such functions explicitly, but
assume such functions to be in the background without losing generality or
precision of the development. (2) The notation of simultaneous substitution
x := t of all occurrences of free variable x by time-length term t in the body
ofφ, denotedasφ[x := t], isastandardinstantiationmechanisminlogic. We
sometimeswillmisusenotationbywritingtheclause((α,β,η[x := a]),s) |= φ
as s |= φ[x := a], with the understanding that it is the variable assignment η
that fixes x to have value a. (3) We sometimes do not explicitly differentiate
the syntactic and semantic time-length terms because there is an obvious
homomorphism between the syntactic terms and the semantic values in the
time domain M+ by our deliberately suggestive notations. A particular case
in point is if we write “(E,s) |= φ if (E,s + t) |= φ,” we understand the
t
first occurrence of t belongs to syntax, and the second occurrence of t is
the meaning of t fixed by the implicit environmental function β, making the
operation s+β(t) meaningful in the monoid M+.
In the dense time setting, the semantics of modalities □ and ♢ can be
t t
defined in four different ways: open-open, close-close, open-close, close-open,
representing the possibility of whether to enforce the scope of modality at
each of the end points. Definition 1 adopts the closed-open option, and
the closed-closed setting can be expressed with additional assertions for end
points. For example, the reflexive version (including current) can be de-
fined as composite formulas, with φ ∧□ φ for closure on the right end, and
t t
similarly, φ ∨♢ φ for possibilities at the right end.
t t
Definition 2. A TEL formula φ is said to semantically entail another for-
mula ψ, φ |= ψ in notation, if for all environment E and for all s ∈ M+,
we have (E,s) |= ψ if (E,s) |= φ. Two TEL formulas φ,ψ are said to be se-
mantically equivalent, |= φ ≡ ψ in notation, if both φ |= ψ and ψ |= φ hold.
When it is clear from the context without ambiguity, we abbreviate |= φ ≡ ψ
simply as φ ≡ ψ.
As an alternative notation, we write [[φ]] for the set {(E,s) | (E,s) |= φ}.
Then the above definition can be written as φ |= ψ if and only if [[φ]] ⊆ [[ψ]],
and φ ≡ ψ if and only if [[φ]] = [[ψ]].
We have the following collection of semantic equivalences that can serve
as the starting point for the axiomatization of a proof system.
Theorem 1. For TEL, according to Definition 1 and Definition 2, we have,
8for any u,v,w ∈ Term:
Term-≡ ¬(φ ) ≡ (¬φ) , φ ≡ φ if β(u) = β(v),
u u u v
(φ ) ≡ φ where β(u+v) = β(w);
u v w
Term-∧-∨ (φ∧ψ) ≡ φ ∧ψ , (φ∨ψ) ≡ φ ∨ψ ;
u u u u u u
Term-□-♢ □ (φ ) ≡ (□ φ) , ♢ (φ ) ≡ (♢ φ) ;
u v u v u v u v
♢-∨ ♢ φ ≡ φ∨♢ φ, ♢ (φ∨ψ) ≡ (♢ φ)∨(♢ ψ);
u u u u u
□-∧ □ φ ≡ φ∧□ φ, □ (φ∧ψ) ≡ (□ φ)∧(□ ψ);
u u u u u
Monotonicity φ |= ♢ φ, □ φ |= φ;
u u
If β(u) < β(v) then φ |= ♢ φ, and □ φ |= φ ;
u v v u
If β(u) ≤ β(v) then ♢ φ |= ♢ φ, □ φ |= □ φ;
u v v u
If φ |= ψ then
φ |= ψ , ♢ φ |= ♢ ψ, and □ φ |= □ ψ;
u u u u u u
Dense-+ For dense M, we have these additional equivalences:
♢ (♢ φ) ≡ ♢ (♢ φ), □ (□ φ) ≡ □ (□ φ);
u v v u u v v u
♢ (♢ φ) ≡ ♢ φ, where β(u+v) = β(w);
u v w
□ (□ φ) ≡ □ φ, where β(u+v) = β(w);
u v w
For any free variables x,y and terms u,v,w, we have:
□ □ φ(x) |= ∀xφ, ∀xφ ≡ □ φ(x := v)∧∀y(φ(x := v)) ,
y u+w y+u
♢ ♢ φ(x := v) |= ∃xφ, ∃xφ ≡ ♢ φ∨(∃xφ) .
u u+v u
We break down the proofs of non-trivial equivalences as a collection of
propositions, due to the introduction of new modalities and interactions
among the constructs unique to TEL. To reduce notational clutter, we as-
sume that an environment (α,β,η) is fixed, as the steps involved in the proof
do not involve any changes in the environment. This allows the abbreviation
of “(E,s) |= φ” simply as “s |= φ.”
Proposition 1. If β(u) < β(v) then φ |= ♢ φ, and □ φ |= φ .
u v v u
Proof. Note that strict inequality < is needed because of the right-openness
of the time-line for ♢ φ and □ φ. Suppose s |= φ . Then s+β(u) |= φ. Let
v v u
c = s+β(u). We have s ≤ c < s+β(v) because β(u) < β(v). Therefore s |=
φ , with c as a witness. The proof for □ φ |= φ is also straightforward.
v v u
Proposition 2. Suppose M is endowed with a compatible subtraction opera-
tion (− in notation), in the sense that for all x < y, there exists z such that
x+z = y (so z can be expressed as y −x). Then
♢ (♢ φ) ≡ ♢ (♢ φ) and □ (□ φ) ≡ □ (□ φ).
u v v u u v v u
9Proof. We prove □ (□ φ) ≡ □ (□ φ), as an example. We show that (to
u v v u
avoid clutter we omitted β when referring to β(u) and β(v)):
∀x∀y[(s ≤ x < s+u & x ≤ y < x+v) ⇒ (y |= φ)]
implies
∀a∀b[(s ≤ a < s+v & a ≤ b < a+u) ⇒ (b |= φ)].
Suppose for some a with s ≤ a < s + v we have a ≤ b < a + u. Let
x = b−(a−s) and y = b. Note that since b−(a−s) = (b−a)+s and b ≥ a,
β(x) > 0. We have a ≤ b < a+u, so a−(a−s) ≤ b−(a−s) < a+u−(a−s).
Therefore, s ≤ x < s+u. Now for b, we have x ≤ b and b < b+(s+v)−a.
Hence x ≤ b < v +b−(a−s) = x+v. By assumption, we have b |= φ.
Proposition 3. Suppose M is dense, endowed with a compatible subtraction
operation, and β(u+v) = β(w). Then
♢ (♢ φ) ≡ ♢ φ, and □ (□ φ) ≡ □ φ.
u v w u v w
Proof. The direction ♢ (♢ φ) |= ♢ φ does not require the density property
u v w
of M and can proceed as follows:
s |= ♢ (♢ φ) ⇒ ∃c with s ≤ c < s+β(u), s.t. c |= ♢ φ
u v v
⇒ ∃d with c ≤ d < c+β(v), s.t. d |= φ
⇒ ∃d with s ≤ d < s+β(u+v), s.t. d |= φ
⇒ s |= ♢ φ.
u+v
For the less trivial entailment ♢ φ |= ♢ (♢ φ), we require that M is
w u v
dense, in the usual sense that for any two elements a,b in M with a < b, there
exits c ∈ M such that a < c < b. Let β(u+v) = β(w) for u,v,w ∈ Term and
s |= ♢ φ. We have β(w) = β(u)+β(v) and there exits s ≤ c < s+β(w) such
w
that c |= φ. Because < is a total order, either c < s+β(u) or c ≥ s+β(u). In
the case c < s+β(u), we have s |= ♢ φ. Therefore s |= ♢ (♢ φ) according
u v u
to ♢-∨. In the case s+β(u) ≤ c < s+β(u)+β(v), we have, by the density
property of M, there exists some s < ϵ < s+β(v) such that ϵ ≤ c < ϵ+β(u).
Intuitively, ϵ = (c − β(u)) + δ, with δ “small” enough so that we maintain
s ≤ c−β(u)+δ < s+β(v), while also having (c−β(u))+δ ≤ c < c+δ,
or ϵ ≤ c < (c − β(u)) + δ + β(u) = ϵ + β(u)). Therefore ϵ |= ♢ φ, and
u
so s |= (♢ φ) , where ⌈ϵ − s⌉ stands for a transient term with value
u ⌈ϵ−s⌉
β⌈ϵ − s⌉ = (ϵ − s). Since (ϵ − s) < β(v), we have (♢ φ) |= ♢ (♢ φ).
u ⌈ϵ−s⌉ v u
Therefore s |= ♢ (♢ φ).
v u
10Similarly, for □, the direction □ φ ≤ □ (□ φ) does not require the
w u v
density property of M and can proceed as follows:
s |= □ φ iff ∀x with s ≤ x < s+β(w),x |= φ
w
iff ∀x with s ≤ x < (s+β(u)+β(v)),x |= φ
⇒ ∀y,∀z with s ≤ y < s+β(u) and y ≤ z < y +β(v),z |= φ
iff ∀y with s ≤ y < s+β(u), y |= □ φ
v
iff s |= □ (□ φ).
u v
From the above steps, it is clear that the only property to be checked for the
direction □ (□ φ) ≤ □ φ is that, assuming s |= □ (□ φ), we have:
u v w u v
for all x with s ≤ x < (s+β(u)+β(v)),x |= φ.
To see this, suppose s ≤ x < (s + β(u) + β(v)). Then either x < s+ β(u)
or x ≥ s+β(u). In the case x < s+β(u), we have s ≤ x < (s+β(u)) and
because s |= □ (□ φ), we have x |= □ φ, and hence x |= φ.
u v v
Inthecasex ≥ s+β(u), wehaves+β(u) ≤ x < (s+β(u)+β(v)). Similar
to the interpolation strategies for the ♢ case above, we have, by the density
property of M, there exists some s < ϵ < s+β(v) such that ϵ ≤ x < ϵ+β(u).
Because s |= □ (□ φ), we have ϵ |= □ φ. Therefore x |= φ.
v u u
Proposition 4. For any free variables x,y and terms u,v,w, the following
four entailments hold:
1. □ φ(x) |= ∀xφ
y
2. ∀xφ ≡ □ φ(x := v)∧∀y(φ(x := v))
u+w y+u
3. ♢ φ(x := v) |= ∃xφ
u
4. ∃xφ ≡ ♢ φ∨(∃xφ)
u u
Thispropositionrepresentsthe□and♢entailmentsstatedinTheorem1.
Proof. Entailment 1 states that if a formula φ(x) with the indicated free
variable x in the body evaluates to true no matter what the “until” upper
limit y is (i.e. □ ), then the formula φ is true for all x.
y
Entailment 2 is a form of “unwinding” ∀x in the form of a maximal fixed
point. However,weneededtodothisunwindingwithoutastartingpoint(due
to the lack of such starting point in the dense domain). This is the reason we
allow instantiation of ∀xφ in the form □ φ(x := v) for arbitrarily selected
u+w
terms u,v and w for the initial segment (up to u+w) and picking up the tail
11part using the formula ∀y(φ(x := v)) . The term choice u+w in □ is
y+u u+w
to ensure no gaps between (up to) u+w and (from) y +u.
Entailment 3 and 4 have similar flavors, with entailment 4 representing
an unwinding of ∃x as a least fixed point.
3 TEL and an Equational Proof System
N+
The direction of theoretical developments (e.g., proof system, decidability,
expressiveness) of TEL is expected to be dependent on the specific choice of
time monoid M, particularly because dense vs. discrete settings are likely
to require different treatments with different results. In this section, we
focus on the most natural case of natural numbers N+, positive integers with
the usual addition. In this setting, it is unnecessary to make a distinction
between syntactic vs. semantic of integer time-length terms: they can be
used interchangeably, so time-length terms u,v ∈ Term are defined as:
N+
u,v ::= i ∈ N+ | x | u+v,
where x represent (a countable set of) time-length variables.
The alphabet for TEL is Σ (= 2Prop), to account for all possible truth-
N+
status of each proposition in Prop at each given time. Following standard
notational convention, Σ∗ represents the set of all finite words over Σ, Σ+
represents the set of all no-empty finite words over Σ, and Σω represents all
ω-words over Σ, of the form
α = σ[1]σ[2]···
with σ[i] ∈ Σ being the ith letter of α for all i ≥ 1. Regular expression
notations can be conveniently extended to describe ω-languages, which are
subsetsL ⊆ Σω. Thisofteninvolveconcatenation(orpostfixing)withinfinite
repetitions of regular languages [18].
For TEL formulas, we have, with t ∈ Term and x for time-length
N+ N+
variable:
φ,ψ ::= a ∈ Σ | φ | ¬φ | φ∧ψ | φ∨ψ | □ φ | ♢ φ | ∀xφ | ∃xφ.
t t t
Note that even though 0 is not a permissible time-constant, we can let φ
0
to stand for φ without causing any inconsistencies. As usual, we let φ → ψ
to stand for (¬φ)∨ψ.
12Definition 3. We define, given an ω-word α = σ[1]σ[2]··· (corresponding
to the interpretation part of an environment) over Σ and any i ≥ 1,
(α,i) |= a if a = σ[i];
(α,i) |= φ if (α,i+t) |= φ;
t
(α,i) |= ¬φ if (α,i) ̸|= φ;
(α,i) |= ϕ∧ψ if (α,i) |= φ and (α,i) |= ψ;
(α,i) |= ϕ∨ψ if (α,i) |= φ or (α,i) |= ψ;
(α,i) |= □ φ if (α,j) |= φ for all j with i ≤ j < i+t;
t
(α,i) |= ♢ φ if (α,j) |= φ for some j with i ≤ j < i+t;
t
(α,i) |= ∀xφ if for all k ≥ 1, (α,i) |= φ[x := k].
(α,i) |= ∃xφ if there exists k ≥ 1, (α,i) |= φ[x := k],
where φ[x := k] is the standard syntactic convention for the formula obtained
by replacing all free occurrences of variable x in φ by constant k. The lan-
guage determined by a formula φ is the set of all ω-words over Σ that satisfies
φ at initiation: L(φ) = {α | (α,1) |= φ}.
Note that as in our general set up for TEL, we could have defined the
first clause in Definition 3 as (α,i) |= p if p ∈ σ[i], with p ∈ Prop. Keep-
ing the option of setting Σ = 2Prop in mind, we could have recovered p as
(cid:87)
p = {a | p ∈ a;a ∈ Σ}. As can been seen in what follows, and from the
literature, the difference between treating p in Prop as primitive vs treat-
ing a ∈ Σ as primitive, is not that essential when theoretical properties are
concerned. However, treating members of Σ as logical primitives provides a
slightly higher level of abstraction and avoids non-essential details in propo-
sitional encoding.
We provide examples to show languages expressible in TEL . In Sec-
N+
tion 5, we will study its expressive power more systematically. To start with,
let a ∈ Σ and k ≥ 1 and we determine what the formula □ a captures. Ac-
k
cording to Definition 3, (α,1) |= □ a if and only if (α,j) |= a for all j with
k
1 ≤ j < k +1, i.e., σ[j] = a for j = 1,2,··· ,k, or, σ is of the form akΣω.
Lemma 1. Let w ∈ Σ+ be a finite word with length κ, and w[i] the i-th letter
of w. For any ω-word α = σ[1]σ[2]···,
(α,1) |= (w[1]∧(w[2]) ∧(w[κ]) )
1 κ−1 s
if and only if α = ΣswΣω. In the special case when s = 0, we have (α,1) |=
w[1]∧(w[2]) ∧(w[κ]) if and only if α = wΣω.
1 κ−1
13Proof. We have
(α,1) |= (w[1]∧(w[2]) ∧(w[κ]) )
1 κ−1 s
iff
(α,1+s) |= w[1]∧(w[2]) ∧(w[κ])
1 κ−1
iff
the (1+s)-th letter of α is w[1],
the (2+s)-th letter of α is w[2], ..., and
the (κ+s)-th letter of α is w[κ]
iff
α = ΣswΣω.
Example 1. Assume a,b,c ∈ Σ. We have
L(∃x(□ a∧(□ b) ∧(□ c) ∧(□ a) )) = {anbncnan | n ≥ 1}Σω.
x x x x 2x x 3x
This is our first non-trivial example illustrating the expressive power of
TEL . Therefore, it is worth spending some space explaining this example,
N+
whichalsoprovidessomeinsightonformulaconstructiontemplatescapturing
a range of patterns in ω-languages. We have:
(α,1) |= ∃x(□ a∧(□ b) ∧(□ c) ∧(□ a) ))
x x x x 2x x 3x
iff there exists k ≥ 1
(α,1) |= (□ a∧(□ b) ∧(□ c) ∧(□ a) ))
k k k k 2k k 3k
iff there exists k ≥ 1
(α,1) |= □ a, (α,1) |= (□ b) , (α,1) |= (□ c) , and (α,1) |= (□ a)
k k k k 2k k 3k
iff there exists k ≥ 1
(α,1) |= □ a, (α,k +1) |= □ b, (α,2k +1) |= □ c, and (α,3k +1) |= □ a
k k k k
iff there exists k ≥ 1
α[1,k] = ak, α[k +1,2k] = bk,α[2k +1,3k] = ck, and α[3k +1,4k] = ak.
(where, for convenience, α[i,j] stands for the fragment σ[i]σ[i+1]···σ[j]).
For these steps it is clear that any ω-word in the language determined by
this formula must have its initial segment starting from the form anbncnan
for some n ≥ 1, although the tail part of the word can be arbitrary.
Example 1 is a well-known example of ω-language not acceptable by any
Bu¨chi automata [18].
14Example 2. Let Σ = {a,b} and
φ := ∀x(a → ((□ b) ∧a )).
x x x+1 2x+1
The above formula φ captures the property that if one sees a at any x-time
in the future, then one must see some x numbers of consecutive b’s right
afterwards, ending with an a at the end of this stretch of b’s. It is clear that
if an ω-word α does not contain any a’s, i.e. α = bω, then (α,1) |= φ. If
the second letter of α is an a, i.e., (α,1) |= (a) , then (α,1) |= φ implies
1
that (α,1) |= (□ b) ∧ (a) , i.e., (α,3) |= □ b and (α,1) |= a . This says
1 2 3 1 3
that the 3-rd position of α is a b, and the 4-th position of α is an a. Now
that the 4-th position of α is an a, we have (α,1) |= a . We must also have
3
(α,1) |= (□ b) ∧a , i.e., (α,i) |= b for i = 5,6,7, and (α,8) |= a. In general,
3 4 7
we have
L(φ) = {bω,abω}∪{bnabh(0)abh(1)abh(2)abh(3)···abh(k)··· | n ≥ 1},
with h(0) := 20(n+1)−1, h(1) := 21(n+1)−1, h(k) := 2k(n+1)−1, so the
functionhhasthepropertythath(k+1) = 2h(k)+1(withnasaparameter).
The general inductive pattern can be seen by assuming (α,1) |= a , or
i−1
(α,i) |= a, for some i ≥ 2. Then:
(α,1) |= (□ b) ∧a
i−1 i 2i−1
iff
(α,1) |= (□ b) and (α,1) |= a
i−1 i 2i−1
iff
(α,i+1) |= □ b and (α,2i) |= a
i−1
This kicks off the induction that (α,i) |= a implies (α,2i) |= a, with every
position from i + 1 to 2i − 1 being a b. For example, when n = 3 we have
α = b3ab3ab7ab15ab31···
This example shows that the language L(φ) is neither semi-linear nor
ultimately periodic, hence there is unlikely any finite automata model to
accept it.
Example 3. We provide a formula for the language {wwc(a+b+c)ω |
w ∈ {a,b}+}, i.e. ω-words with prefixes of the form wwc, for w non-empty.
Here is the formula, and we omit the proof that this formula indeed captures
this language:
∃xc ∧(□ ((a → a )∧(b → b )∧(¬c))).
2x+1 x x x
Example 4. We leave it open for the reader to find a formula for the
language {anbncn | n ≥ 1}ω (taken from [18]).
153.1 A Deductive System for TEL
N+
In this subsection, we introduce a deductive system for TEL . This is an
N+
equational system involving equalities = and inequalities ≤. The standard
logical axioms (and rules) include substitution of equals for equals, distinc-
tion of bound and free variables and the permission to rename bound vari-
ables, and standard first order logical equivalences involving the associative
and commutative property of repeated (nested) ∀ and repeated (nested) ∃
quantifications, etc.
The deductive system consists of the following types of equational axioms
and rules:
Deductive System for TEL
N+
(cid:86) (cid:87) (cid:87)
Σ: (¬a) = (Σ\A) for A ⊆ Σ, with Σ = ⊤ a special case;
a∈A
Boolean: Axioms of Boolean algebra, where we write φ ≤ ψ for φ∨ψ = ψ;
∀∃: Standard axioms and inference rules for first-order logic;
Negation: ¬φ = (¬φ) , ¬♢ φ = □ (¬φ), ¬□ φ = ♢ (¬φ),
u u u u u u
¬(∀xφ) = ∃x(¬φ), ¬(∃xφ) = ∀x(¬φ);
Future: (φ ) = φ if u = s+t, φ = φ if s = t,
s t u s t
(φ∧ψ) = φ ∧ψ , (φ∨ψ) = φ ∨ψ ,
u u u u u u
(♢ φ) = ♢ (φ ), ♢ (♢ φ) = ♢ (♢ φ),
u v u v u v v u
(□ φ) = □ (φ ), □ (□ φ) = □ (□ φ);
u v u v u v v u
□□□: □ φ = φ, □ φ = (cid:86) φ , including the special case □ φ ≤ φ,
1 u 0≤i<u i u
where we define φ := φ for notational convenience;
0
♢♢♢: ♢ φ = φ, ♢ φ = (cid:87) φ , including the special case φ ≤ ♢ φ;
1 u 0≤i<u i u
Mono: φ ≤ ♢ φ, □ φ ≤ φ , and if φ ≤ ψ then
u u+1 u+1 u
□ φ ≤ □ ψ, ♢ φ ≤ ♢ ψ, φ ≤ φ , ∀xφ ≤ ∀xψ, ∃xφ ≤ ∃xψ;
s t s t s t
∃: ∃xφ = φ[x := 1]∨∃yφ(x := y ), (∃xφ) = ∃x(φ ), where y is a fresh
1 u u
variable and u is a constant or a fresh term (note that y represents y
1
at 1 time unit later);
∀: ∀xφ = φ[x := 1]∧∀yφ(x := y ), (∀xφ) = ∀x(φ ), where y is a fresh
1 u u
variable and u is a constant or a fresh term;
16Induction: φ ∧∀x(φ → φ ) ≤ ∀xφ .
1 x x+1 x
Note that rules in Σ is only valid for primitive propositions in Σ, due
to the exclusive nature of the fact that each position of the ω-word (as a
semantic structure) has one and only one letter from Σ.
(cid:86) (cid:87)
Indefiniteconjunctionsanddisjunctions, suchas φ and φ ,
0≤i<u i 0≤i<u i
with φ representing time-shifted evaluation of φ, are not part of our formal
i
syntax in the logic. They are introduced to concisely interpret the seman-
tics of □ φ and ♢ φ as intermediate steps of the equational proofs using
u u
propositional reasoning when needed.
Equational rules ∃ and ∀ represent least fixed point and greatest fixed
point properties of ∃ and ∀, now that we have the starting point 1 in N+.
Note that even though □ and ♢ can be expressed using finite conjunctions
t t
and disjunctions, we allow variable lengths of the conjunction and disjunction
formulas which can be further quantified. This is a source of the expressive
power for TEL .
N+
Proposition 5. The following statements are deducible from the equational
axioms and rules:
1. ⊢ □ φ ≤ ♢ φ,
t t
2. ⊢ □ φ ≥ □ φ, ♢ φ ≤ ♢ φ if s ≤ t,
s t s t
3. ♢ (♢ φ) = ♢ (♢ φ), □ (□ φ) = □ (□ φ),
u v v u u v v u
4. ⊢ ♢ (♢ φ) = ♢ φ if u = s+t,
s+1 t u
5. ⊢ □ (□ φ) = □ φ if u = s+t,
s+1 t u
6. ⊢ □ (φ ) = (□ φ) , □ (φ∧ψ) = (□ φ)∧(□ ψ),
u v u v u u u
7. ⊢ ♢ (φ ) = (♢ φ) , ♢ (φ∨ψ) = (♢ φ)∨(♢ ψ),
u v u v u u u
8. ⊢ □ (φ → ψ) ≤ (□ φ) → (□ ψ),
t t t
9. ⊢ ♢ (φ → ψ) ≤ (♢ φ) → (♢ ψ),
t t t
10. ⊢ □ (φ → (φ) ) = φ → □ φ.
t 1 t+1
17Proof. We jump to item 3 and 4, since items 1 and 2 follows directly from
the equational axioms □□□ and ♢♢♢ together with the Boolean laws.
Item 3: We prove ⊢ ♢ (♢ φ) = ♢ (♢ φ) as an illustration.
u v v u
(cid:95) (cid:95)
♢ (♢ φ) = ( φ ) ♢♢♢
u v j i
0≤i<u 0≤j<v
(cid:95) (cid:95)
= ( φ ) Future
i+j
0≤i<u 0≤j<v
(cid:95)
= φ Boolean
k
0≤k<(u+v−1)
(cid:95) (cid:95)
= ( φ ) Future
i+j
0≤j<v 0≤i<u
(cid:95) (cid:95)
= ( φ ) Boolean
i j
0≤j<v 0≤i<u
= ♢ (♢ φ) ♢♢♢
v u
Item 4 and 5: ⊢ ♢ (♢ φ) = ♢ φ where u = s+t. We have:
s+1 t u
(cid:95)
♢ φ = φ ♢♢♢
u k
0≤k<u
(cid:95) (cid:95)
= ( φ ) Boolean
i+j
0≤i<(s+1) 0≤j<t
(cid:95) (cid:95)
= ( φ ) Future
j i
0≤i<(s+1) 0≤j<t
= ♢ (♢ φ) ♢♢♢
s+1 t
Similarly, we have ⊢ ♢ (♢ φ) = ♢ φ, as well as ⊢ □ (□ φ) = □ φ
s t+1 u s t+1 u
and ⊢ □ (□ φ) = □ φ.
s+1 t u
Item 6 and 7: We prove item 6 as an example. For □ (φ ) = (□ φ) we
u v u v
have:
(cid:94)
□ (φ ) = (φ ) □□□
u v v k
0≤k<u
(cid:94)
= (φ ) Future
k v
0≤k<u
(cid:94)
= ( φ ) Future
k v
0≤k<u
= (□ φ) □□□
u v
18For □ (φ∧ψ) = (□ φ)∧(□ ψ) we have:
u u u
(cid:94)
□ (φ∧ψ) = (φ∧ψ) □□□
u k
0≤k<u
(cid:94)
= φ ∧ψ Future
k k
0≤k<u
(cid:94) (cid:94)
= ( φ )∧( ψ ) Boolean
k k
0≤k<u 0≤k<u
= (□ φ)∧(□ ψ) □□□
u u
Item 8 and 9: We provide a proof for item 8. The proof for item 9 is
similar. To show ⊢ □ (φ → ψ) ≤ (□ φ) → (□ ψ), we have:
t t t
(cid:94)
□ (φ → ψ) = (¬φ∨ψ) □□□
t i
0≤i<t
(cid:94)
= (¬φ) ∨(ψ) Future
i i
0≤i<t
(cid:94) (cid:95)
≤ (( (¬φ) )∨(ψ) ) Boolean
j i
0≤i<t 0≤j<t
(cid:94)
= (¬(□ φ)∨(ψ) ) □□□
t i
0≤i<t
(cid:94)
= ¬(□ φ)∨ (ψ) Boolean
t i
0≤i<t
= (□ φ) → (□ ψ) □□□
t t
Item 10: To show ⊢ □ (φ → (φ) ) = φ → □ φ, we have:
t 1 t+1
(cid:94)
□ (φ → (φ) ) = (φ → φ ) Boolean
t 1 i i+1
0≤i<t
(cid:94)
= φ → φ Boolean
i+1
0≤i<t
= φ → □ φ □□□
t+1
Theorem 2. All the equational axioms in the deductive system for TEL
N+
are valid, in the sense that if φ ≤ ψ, then φ |= ψ and if φ = ψ, then
|= φ ≡ ψ. Furthermore, the deductive system is sound, in the sense that all
the deducible equations are valid.
19Proof. Straightforward.
Theorem 3 (Negation-free Form). Using the deductive system for TEL ,
N+
we can obtain, for each formula φ, a formula ψ such that ⊢ φ = ψ and ψ is
negation-free.
Proof. By repeatedly applying the rules in Negation we can push all ¬’s
inward to the front of primitive propositions. Moreover, any negation in
front of a symbol from Σ can be translated into an equivalent negation free
form using the rules for Σ.
4 Undecidability of TEL
N+
The proof is by a reduction from Post’s Correspondence Problem (PCP).
Consider a finite alphabet Σ = {a ,a ,...,a }. An instance of infinite PCP
1 2 r
consists of m pairs (u ,v ) of words from Σ∗ and the question is whether
i i
there exists a finite sequence of indices i ,i ,...,i such that u u ···u =
0 1 k i0 i1 i
k
v v ···v . Although technically fundamentally distinct, our proof strategy
i0 i1 i
k
drawsinspirationfrom[19,20,21]. ThekeydistinctionisthatforHyperLTL,
the first-order variables are instantiated and quantified over traces π, which
are ω-sequences over a suitably given alphabet. For TEL , our first-order
N+
variablesareinstantiatedandquantifiedovertime-lengths, whichareintegers
in N+.
To prepare for the proof, we introduce a couple of lemmas that capture
more general patterns than in Example 3 for word sequence correspondences.
These lemmas also help illustrate the expressive power of TEL .
N+
Lemma 2 (Word Sequence Correspondence). Suppose W := {w | i =
i
1,...,n} is a set of non-empty words over an alphabet Σ. Suppose u and
v are obtained as concatenations u = u ···u and v = v ···v , where u ’s
1 ℓ 1 m i
and v ’s are drawn from W. There is a TEL formula φ which is satisfiable
j N+
if and only if ℓ = m and u = v for all i = 1,...,m.
i i
Proof. To prepare for the formula φ, we expand the alphabet with additional
˙ ¨ ˙ ¨
“mirror letters” from Σ and Σ, where Σ := {a˙ | a ∈ Σ}, and Σ := {a¨ | a ∈
˙
Σ}. We then write W for the set of words modified from W, with the only
change that the leading letter of each of its member w is replaced by its
i
˙ ¨
counterpart in Σ, and similarly for W. For each w ∈ W, we write w˙ for the
˙
corresponding member in W and, similarly, w¨ for the corresponding member
20¨
in W. These can also be named using subscripts as w˙ and w¨ , respectively,
i i
for i = 1,...,n. The purpose for introducing these unique leading letters
(mirror designations) is for us to be able to tell the relative positioning of
˙
the words. For example, we can enforce that all the words in W to appear
¨
before all the words in W easily.
The desired formula φ will be the conjunction of two parts, expressed as
φ := φ1∧φ2. Thefirst partφ1 makessurethattheplacementofwordsfollows
the pattern of u ···u ¢v ···v #Σω, where ¢ and # are letters distinct from
1 ℓ 1 m
those in Σ∪Σ˙ ∪Σ¨ . The letter ¢ marks the “center” that separates u and v,
and # marks the beginning of “don’t care.” Moreover, all the u ’s are from
i
W˙ and all the v ’s are from W¨ . The second part φ2 ensures that ℓ = m and
i
u = v for all i = 1,...,m, with the mirror designation of the leading letters
i i
∼ ∼
ignored, i.e. we treat a = a˙ = a¨ for each a ∈ Σ when testing word equality.
To describe φ1 and φ2, we need some preparations for simpler reusable
˙ ¨
components. For each word w ∈ W (and similarly for w ∈ W or w ∈ W),
i i i
there is a corresponding formula ιwi specifying a matching word (reading
from the beginning), defined as:
ιwi := σi[1]∧(σi[2]) ∧(σi[κ ])
1 i κi−1
where w = σi[1]σi[2]···σi[κ ], and σi[j] is the j-th letter for word w , for
i i j
i = 1,2,...,n and κ is the length of w .
i i
A word drawn from the set W can then be described as a disjunction:
(cid:95)
{ιw | w ∈ W},
˙ ¨
which will be abbreviated as ∃W. We define ∃W and ∃W in similar ways.
(cid:95) (cid:95)
˙
Along the same line, we abbreviate {a | a ∈ Σ} as ∃Σ, {a ∈ Σ} as
(cid:95)
˙ ¨ ¨ ˙ ¨
∃Σ and {a ∈ Σ} as ∃Σ, or simply as Σ, Σ and Σ when context permits
without ambiguity or confusion of types.
Formula φ1 can then be defined as:
φ1 :=
∃x∃y(¢ ∧# ∧□ (Σ∨Σ˙ )∧(□ (Σ∨Σ¨ )) ∧(□(Σ)) (1)
x x+y x y x+1 x+y+1
(cid:16) (cid:17)
∧∃W˙ ∧□ Σ˙ → (cid:87)n (ιw˙i ∧(Σ˙ ∨¢) ) (2)
x i=1 κi
(cid:16) (cid:17)
∧(∃W¨ ∧□ Σ¨ → (cid:87)n (ιw¨i ∧(Σ¨ ∨#) ) ) (3)
y i=1 κi x+1
21The sub-formulas for φ1 are numbered to explain their properties with
easier reference. Formula (1) specifies that the ω-word must consist of three
parts:
1. From the beginning up to position x, which is marked with ¢;
2. From position x+1 up to position x+y, which is marked with #; and
3. The remaining parts after # beginning from position (x+y +1).
Formula (1) further require that for the first part, letters other than the
boundary markers ¢ must consist of members from Σ ∪ Σ˙ , as indicated in
□ (Σ∨Σ˙ ). For the second part, letters other than the boundary markers ¢
x
¨
and and # must consist of members from Σ∪Σ, as indicated in the conjunct
(□ (Σ ∨ Σ¨ )) . All letters after (the unique) # must be from Σ only, as
y x+1
indicated in (□(Σ)) .
x+y+1
Formula (2) says that when inspecting the content of the first part (up to
˙
but not including position x), it must begin with a member from W. Also,
˙
any letter in Σ must be the start of the matching point for another word in
W˙ , ending with either a letter from Σ˙ again, or the boundary mark ¢ (which
marks the end of the first part).
Formula (3) says that when inspecting the content of the second part
¨
(starting from position x+1), it must begin with a member from W. Fur-
¨
thermore, any letter in Σ must be the start of the matching point for another
¨ ¨
word in W, ending with either a letter from Σ again, or the boundary mark
# (which marks the end of the second part).
Note that since both the first part and the second part must begin with
˙ ¨ ˙
a matching word from W or W (hence starting with a letter from either Σ
¨
or Σ), we do not have to worry about how to deal with any letters in Σ in
˙
these two parts: they must already be the tail part of a matching word in W
or in W¨ , as captured by the sub-formulas (∃Σ˙ ∨¢) and (∃Σ¨ ∨#) . These
κi κi
sub-formulas are abbreviated as (Σ˙ ∨¢) and (Σ¨ ∨#) in Formula (2) and
κi κi
(3), respectively.
We now define formula φ2, which is intended to capture a 1-1 correspon-
dence between the first part and second part, with respect to the ordering
˙ ¨
and members drawn from W and W:
22φ2 := ∃z¢ ∧ (4)
z
(cid:94)
(ιw˙i → ιw¨i )∧(ιw¨i → ιw˙i)∧ (5)
z+1 z+1
i=1,...,n
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x ιw˙i → ∃y ιw¨i ∧ ∀s(ιw˙j → ∃tιw¨j ) ∧ (6)
x y+z x+s (y+z)+t
i=1,...,n j=1,...,n
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x ιw¨i → ∃y ιw˙i ∧ ∀s(ιw¨j → ∃tιw˙j ) (7)
x+z y (x+z)+s t+y
i=1,...,n j=1,...,n
Formula (6) is designed to capture the property that for any consecu-
tive (as we can choose how to instantiate universally quantified variables x
˙ ¨
and s) pair of words from W, there are matching words from W with the
same sequential position (wrt before and after), consecutive or not. When
instantiating all the consecutive pairs for the u-part to matching words from
¨
W with the same relative sequential positioning, we can see that the v-part
must have as many members as the u-part.
Similarly, formula (7) captures the reverse direction, ensuring that the u-
part must involve at least as many members as the v-part. Working together,
(6) and (7) would result in a desired 1-1 correspondence between the u-part
and the v-part.
We prove by mathematical induction on ℓ, that φ1 ∧ φ2 is satisfiable if
and only if ℓ = m and u = v for all i = 1,...,m. By the property of φ1, we
i i
know that the ω-word α is already of the form u ···u ¢v ···v #Σω.
1 ℓ 1 m
For the induction basis ℓ = 1, suppose (α,1) |= φ1∧φ2. Because (α,1) |=
φ1, we have α = u ¢#Σω, α = u ¢v #Σω, or α = u ¢v v ···v #Σω. By the
1 1 1 1 1 2 m
requirement specified in (5) and (7), only the second case is possible, with
u = v .
1 1
For the inductive step, suppose the desired statement is true up to ℓ =
κ. For ℓ = κ + 1, suppose α = u ···u u ¢v ···v #Σω. We show that
1 κ κ+1 1 m
(α,1) |= φ2 if and only if κ + 1 = m and u = v for all i = 1,...,m.
i i
There are two directions. If κ + 1 = m and u = v for all i = 1,...,m,
i i
then clearly (α,1) |= φ2. Suppose, on the other hand, that (α,1) |= φ2,
with α = u ···u u ¢v ···v #Σω. For this to hold, we must have u = v
1 κ κ+1 1 m 1 1
because of formula (5). To invoke the induction hypothesis, we show that
β = u ···u u ¢v ···v #Σω still satisfies φ2, i.e., (β,1) |= φ2. Because
2 ℓ ℓ+1 2 m
23(α,1) |= φ2, formula (6) ensures that κ + 1 ≤ m and formula (7) ensures
that m ≤ κ+1. Also because u = v , we must have u = v , by invoking
1 1 2 2
formulas (6) and (7). Now using the induction hypothesis, we have ℓ+1 = m
and u = v for all i = 2,...,m.
i i
Lemma 3. Given a set of (non-empty) words W := {w | i = 1,...,n}, and
i
two words obtained by sequences u = u ···u and v = v ···v where u ’s
1 ℓ 1 m i
and v ’s are drawn from W, there is a TEL formula φ which is satisfiable
j N+
if and only if ℓ = m. We use the same convention to mark the beginning of
a word using underlined letters.
Proof. The general proof strategy is similar to that for Lemma 2. We just
need to modify the more strict word equality checking among w , w˙ and w¨
i i i
to an “any word” setting. With the same coding for the leading letters as
we used for Lemma 2, we provide a formula to specify the property for “is-
˙ ¨
a-word” from W, or W. This requires us to check that the letter following a
proper word satisfies ∃Σ˙ ∨¢ for the u-part and ∃Σ¨ ∨# for the v-part. With
this strategy, we define
n
(cid:95)
χW˙ := (ιw˙i ∧(∃(Σ˙ ∨¢)) ),
κi
i=1
n
(cid:95)
χW¨ := (ιw¨i ∧(∃(Σ¨ ∨#)) ).
κi
i=1
φ2 := ∃z¢ ∧ (8)
z
(cid:94)
(ιw˙i → (χW¨ ) )∧(ιw¨i → χW˙ )∧ (9)
z+1 z+1
i=1,...,n
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x ιw˙i → ∃y (χW¨ ) ∧ ∀s(ιw˙j → ∃t(χW¨ ) ) ∧ (10)
x y+z x+s (y+z)+t
i=1,...,n j=1,...,n
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x ιw¨i → ∃y (χW˙ ) ∧ ∀s(ιw¨j → ∃t(χW˙ ) ) (11)
x+z y (x+z)+s t+y
i=1,...,n j=1,...,n
With the above formulas (8) - (11), we ensure that the u-part and v-part
consist of the same number of words from W, irrespective of their specific
contents.
24Theorem 4. The satisfiability of TEL formula is undecidable.
N+
Proof. We provide a proof by representing instances of binary Post Corre-
spondence Problem (PCP) as TEL formulas. Binary PCP is a special
N+
version of the general PCP where the alphabet consists of two letters, 0
and 1. The binary PCP is to decide, given an instance of m pairs (u ,v )
i i
(i = 1,2,...,m)ofnon-emptybinarystringsfrom{0,1},whetherthereexists
a finite sequence of indices i ,i ,...,i such that u u ···u = v v ···v .
1 2 k i1 i2 i
k
i1 i2 i
k
Given such an instance of binary PCP, we consider the alphabet for
TEL to be (Σ∪Σ˙ ∪Σ¨ ∪{·})2∪{¢,#}, where Σ = {0,1}, Σ˙ = {0˙,1˙}, and
N+
Σ¨ = {¨0,¨1}. Each instance of the binary PCP can be represented as a set of
“dominos,” with the starting letter marked using members in {0˙,1˙}. To make
the domino metaphor visually intuitive, we represent a member (i,j) in (Σ∪
Σ˙ ∪Σ¨ ∪{·})2 as (cid:0)i(cid:1) . For example, the PCP instance (100,1),(0,100),(1,00)
j
can be represented as
(cid:0)1˙(cid:1)(cid:0)0(cid:1)(cid:0)0(cid:1)
,
(cid:0)0˙(cid:1)(cid:0)·(cid:1)(cid:0)·(cid:1)
, and
(cid:0)1˙(cid:1)(cid:0)·(cid:1)
.
1˙ · · 1˙ 0 0 0˙ 0
We capture a solution to a PCP instance using a number of TEL for-
N+
mulas to specify all the constraints that such a solution must satisfy, and vice
versa: constructing a PCP solution from a satisfying formula. Our general
strategy is to use the integer line to capture a PCP solution in two parts.
The first part represents the actual domino placement, involving possibly the
· symbol in the dominos. We encode each input pair (u ,v ) as a domino
i i
of width κ , with κ the larger length of u or v . To indicate clearly the
i i i i
different parts, we use ¢ to mark the end of the first part. The second part
represents the “solution string,” a binary string which has the upper part
and the lower part, differentiated from each other only with the possibility
of the placement (of an equal number) of letters in {¨0,¨1}. We use # to mark
the end of the second part. We do not care what follows after #.
1. φ1: All domino tiles must be presented from the beginning until the
appearance of ¢, as specified in (1) and (2). When concatenated together, the
top row and bottom row of binaries in the second part, between ¢ and the first
appearance of #, must be equal when treating 0 = ¨0 and 1 = ¨1, as specified
in (3). For a templated formula representing a domino, we have, for each
d := (u ,v ) := σ [1]σ [2]···σ [κ ], where σ [j]’s are the corresponding letters
i i i i i i i i
˙
of the i-th domino encoded using the specified set of symbols in Σ∪Σ. As
used in prior lemmas, let ιdi be the corresponding formula specifying domino
d . As usual, we abbreviate (cid:87)m {ιdi} as ∃∆, where ∆ = {d | i = 1,...,m}.
i i=1 i
25φ1 := ∃x∃y(¢ ∧# )∧
x x+y
□ ((Σ∪{·})2 ∪Σ˙2)∧(□ ((Σ∪Σ¨ )2) ∧(□#) ∧ (1)
x y x+1 x+y+1
(cid:16) (cid:17)
∃∆∧□ Σ˙2 → (cid:87)m (ιd˙ i ∧(Σ˙ 2 ∨¢) ) ∧ (2)
x i=1 κi
(cid:104) (cid:105)
□ (cid:87) (cid:0)i(cid:1) ∨(cid:87) (cid:0)i(cid:1) (3)
y i,j∈{0,¨0} j i,j∈{1,¨1} j
x+1
(cid:16) (cid:17)
Note that in (2), the □ Σ˙2 → (cid:87)m (ιd˙ i ∧(Σ˙ 2 ∨¢) ) component plays
x i=1 κi
a critical role in ensuring that the “dominos” are stacked against each other
sequentially, after the placement of the leading domino (∃∆), without any
content that is not a part of a domino delineated by the coded symbols in
Σ˙2, specifically representing the leading letter of a domino, or until we hit ¢.
2. φ2: Moreover, the binary string captured in component (3) of φ1 must
be equal to the top row of binaries concatenated from beginning to ¢, with all
· occurrences ignored (captured by φ2τ below). Similarly, this binary string
must be equal to the bottom row of binaries concatenated together, from the
beginning up to ¢, with all · occurrences ignored (captured by φ2λ below).
We introduce some auxiliary formulas in preparation for φ2. For each
domino tile d := (u ,v ) := σ [1]σ [2]···σ [κ ] (i = 1,2,...,m), we define
i i i i i i i
the corresponding upper binary string as
ϑi := {θ θ ···θ | θ = ⌈σi[j]⌉,j = 1,...,ν },
1 2 νi j i
where ⌈σi[j]⌉ represents the symbol on top of the corresponding domino’s
j-th component, and ν is the last position of di with ⌈σi[j]⌉ ≠ ·. Note that
i
ν can be smaller than κ , the latter being the length if the domino tile. By
i i
design, we have ⌈σi[1]⌉ ∈ Σ˙ , for all i = 1,...,m. When our focus is the top
row of the “solution,” we recognize any disjunct in the following τi to be a
matching segment in the second part of the overall placement, i.e.
(cid:18) (cid:19)(cid:18) (cid:19) (cid:18) (cid:19)
(cid:95) a¨ a a
τi := { 1 2 ··· νi | a˙ a ···a = ϑi,a ∈ Σ}.
b b b
1 2 νi 1
bj∈Σ∪Σ¨,j=1,...,νi 1 2 1 νi νi−1
With these preparations, we are ready to define φ2τ:
26φ2τ := ∃z¢ ∧ (4)
z
(cid:94)
(ιdi → τi)∧(τi → ιdi) ∧ (5)
z z
i=1,...,m
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x ιdi → ∃y τi ∧ ∀s(ιdj → ∃tτj ) ∧ (6)
x y+z x+s y+t+z
i=1,...,m j=1,...,m
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x τi → ∃y ιdi ∧ ∀s(τj → ∃tιdj ) (7)
x+z y x+s+z t+y
i=1,...,m j=1,...,m
Similarly, for φ2λ, we define the lower binary string as
ρi := {ζ ζ ···ζ | ζ = ⌊σi[j]⌋,j = 1,...,ν },
1 2 νi j i
where ⌊σi[j]⌋ represents the lower symbol of the corresponding domino’s j-th
component, and ν is the last position of di with ⌊σi[j]⌋ ≠ ·. To focus on the
i
bottom row of the “solution,” we recognize any disjunct in the following λi
to be a matching segment in the second part of the overall placement, i.e.
(cid:18) (cid:19)(cid:18) (cid:19) (cid:18) (cid:19)
(cid:95) a a a
λi := { 1 2 ··· νi | b˙ b ···b = ρi,b ∈ Σ}.
¨
b b b
1 2 νi 1
aj∈Σ∪Σ¨,j=1,...,νi 1 2 1 νi νi−1
We can now define φ2λ:
φ2λ := ∃z¢ ∧
z
(cid:94)
(ιdi → λi)∧(λi → ιdi) ∧ (8)
z z
i=1,...,m
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x ιdi → ∃y λi ∧ ∀s(ιdj → ∃tλj ) ∧ (9)
x y+z x+s y+t+z
i=1,...,m j=1,...,m
(cid:34) (cid:32) (cid:33)(cid:35)
(cid:94) (cid:94)
∀x λi → ∃y ιdi ∧ ∀s(λj → ∃tιdj ) (10)
x+z y x+s+z t+y
i=1,...,m j=1,...,m
By instantiating the Word Sequence Correspondence Lemma (Lemma 2),
we conclude that the formula φ := φ1 ∧φ2τ ∧φ2λ is satisfiable if and only if
the Post Correspondence instance ∆ has a solution.
275 Expressiveness
WedemonstratetheexpressivepowerofTEL throughthreeexercises. One
N+
is to fully embed LTL [16] in TEL ; the second is its relationship with Bu¨chi
N+
automata; and the third is to represent Allen’s temporal relations as logical
constructs in TEL through the set up of TCL [17].
M+
5.1 TEL and Linear Temporal Logic
N+
Our main reference for LTL is [22]. For a gentler introduction, please refer
to this textbook [23]. We adjust the set up for atomic propositions so it is
at the same level of abstraction as our TEL set up. LTL formulas over an
N+
alphabet Σ is defined as:
φ ::= a | ¬a | ¬φ | φ∧φ | φ∨φ | Xφ | Fφ | Gφ | φUφ | φWφ | φMφ | φRφ
where a ∈ Σ.
The satisfaction relation |= between ω-words α = σ[1]σ[2]··· at a time
point i over Σ and formulas is defined as:
(α,i) |= a if a = α[i]
(α,i) |= ¬a if a ̸= α[i]
(α,i) |= φ∧ψ if (α,i) |= φ and (α,i) |= ψ
(α,i) |= φ∨ψ if (α,i) |= φ or (α,i) |= ψ
(α,i) |= Xφ if (α,i+1) |= φ
(α,i) |= Fφ if ∃k(α,i+k) |= φ
(α,i) |= Gφ if ∀k(α,i+k) |= φ
(α,i) |= φUψ if ∃k(α,i+k) |= ψ and ∀j < k(α,i+j) |= φ
(α,i) |= φWψ if (α,i) |= Gφ or (α,i) |= φUψ
(α,i) |= φMψ if ∃k(α,i+k) |= φ and ∀j ≤ k(α,i+j) |= ψ
(α,i) |= φRψ if (α,i) |= Gψ or (α,i) |= φMψ
The standard reading of the temporal operators are: X for next, F for
eventually, G for always, U for until, W for weak until, R for release, and M
for strong release.
Proposition 6. All LTL temporal operators defined above, X, F,G,U,W,M,
and R can be equivalently defined in TEL .
N+
28There is a slight nuance in the translation, in that in LTL, the integer k
belongs to N, which includes the case k = 0. In our proof of this proposition,
we need to call-out such boundary cases.
Proof. For boolean operators, the translation is straightforward. We provide
a TEL translation for each LTL operator.
N+
X: It is clear that Xφ is equivalent to φ , “next-time.” For TEL , the
1 N+
semantics of φ is to evaluate φ with length 1 time-increment in the future.
1
F: Inspecting the definition, Fφ can be equivalently defined as φ∨∃xφ ,
x
where φ is a LTL formula (without x occurring free in φ). The disjunct φ is
included to cover the boundary case k = 0 in the LTL definition. In TEL ,
N+
we have x ≥ 1 when evaluating ∃xφ .
x
G: Gφ can be equivalently defined as φ∧∀xφ .
x
U: φUψ can be equivalently defined as ψ∨∃x(ψ ∧(□ φ)). The disjunct
x x
ψ is introduced to cover the case when ψ is satisfied at present.
M: φMψ can be equivalently translated as (φ∧ψ)∨∃x((φ∧ψ) ∧(□ ψ)).
x x
Again, the disjunct (φ∧ψ)’s role is to cover the case when k = 0.
W and R: They can be further translated using the translation strategy
for G, U and for G, M.
5.2 TEL and Bu¨chi Automata
N+
LTLformulascanbetranslatedsystematicallytoseveralformsofω-automata[22],
which represent the class of ω-regular languages [24, 25]. On the other hand,
LTL does not capture the entire class of ω-regular languages: they capture
the sub-class of star-free ω-regular languages only [26].
A Bu¨chi automaton is a non-deterministic finite automaton (NFA) A =
(Q,Σ,q ,∆,F) that takes ω-words over Σ as input. As usual, Q is a finite set
0
of states, Σ is the input alphabet, q ∈ Q is the initial state, ∆ ⊆ Q×Σ×Q is
0
the set of transitions, and F(⊆ Q) is the set of accepting states. A run of A
on ω-word σ[1]σ[2]σ[3]··· is an infinite sequence δ of pairs from Q×Σ, with
δ = (p[1],σ[1])(p[2],σ[2])(p[3],σ[3])··· such that (p[i],σ[i],p[i+1]) ∈ ∆ for
all i ≥ 1, where p[1] = q . We write R (A) for the set of all runs of A, which
0 ω
is a subset of (Q×Σ)ω. We say δ is accepting (an accepting run) if there are
infinitely many i with p[i] ∈ F. We define the ω-language recognized by A as
L (A) = {α ∈ Σω | there is an accepting run of A on α}. If an ω-language
ω
L is recognized by some Bu¨chi automaton A, we call L ω-regular.
29Theorem 5. [Bu¨chi [24]] With respect to an alphabet Σ and subset L ⊆ Σ∗,
we define Lω := {w w ··· | w ∈ L\{ε}}. A language L ⊆ Σω is ω-regular
1 2 i
if and only if there are regular languages U ,V ,...,U ,V ⊆ Σ∗ such that
1 1 n n
L = U V ω ∪U V ω ∪···∪U V ω.
1 1 2 2 n n
Theorem 6. For every Bu¨chi automaton A, there is a TEL formula φ
N+ A
such that R (A) = L(φ ).
ω A
Proof. GivenaBu¨chiautomatonA = (Q,Σ,q ,∆,F), weconstructaTEL
0 N+
formula φ such that for any ω-word δ in (Q×Σ)ω, δ ∈ R (A) if and only
A ω
if δ ∈ L(φ ).
A
ContinuingthetilinganalogyinSection4,wepresentamemberof(Q×Σ)
as
(cid:0)p(cid:1)
, with p ∈ Q and a ∈ Σ. A member of (Q×Σ)ω in the form
a
(cid:18) (cid:19)(cid:18) (cid:19)(cid:18) (cid:19)
p[1] p[2] p[3]
···
σ[1] σ[2] σ[3]
is a run of A on σ[1]σ[2]σ[3]··· if and only if (p[i],σ[i],p[i+1]) ∈ ∆ for all
i ≥ 1, where p[1] = q .
0
We use the following TEL formulas to capture the runs for A.
N+
φ0: This formula captures the property that the first steps of the run start
with the state q . We have
0
(cid:18) (cid:19)(cid:18) (cid:19)
(cid:95) q p
φ0 := 0
a b
a,b∈Σ,(q0,a,p)∈∆ 1
φ1: This formula captures the property that for all i ≥ 1, (p[i],σ[i],p[i+
1]) ∈ ∆. We have
 
(cid:18) (cid:19) (cid:18) (cid:19)
(cid:94) p (cid:95) q
φ1 := ∀x → 
a b
p∈Q,a∈Σ x b∈Σ,(p,a,q)∈∆ x+1
Thus a run of A is a one-dimensional, right-infinite tiling of domino tiles
from (Q × Σ) according to the rules specified in ∆. The tiling rules in
∆ define all legitimate ways of connecting two consecutive tiles. Formula φ0
specifiesthepropertythattheinitialtwotilesmustbelegitimatelyconnected,
with the starting tile marked by the property that the upper part must be
q . Formula φ1 specifies the property that for any two consecutive tiles at
0
positions marked by x and x+1, they must all obey the tiling rules defined
in ∆.
By setting φ := φ0 ∧φ1, we can verify that R (A) = L(φ ).
A ω A
30We need one more formula to capture the accepting runs, satisfying the
condition that states in F occurs infinitely often in the run. This can be
captured by the formula
(cid:18) (cid:19)
(cid:95) p
∀y∃x
a
p∈F,a∈Σ x+y
Proposition 7. The ω-language defined by TEL formula (see Example 2)
N+
∀x(a → ((□ b) ∧a ))
x x x+1 2x+1
is not ω-regular.
5.3 TEL and Allen’s Temporal Interval Relations
Allen’s Interval Algebra [4] is motivated from the need for AI systems to
model space and time in a qualitative, “human-like,” manner. The basic unit
of the algebra is intervals on the real line, which can represent the duration of
events, tasks, or actions over time. This algebra formalizes relations such as
precedes (i.e., before) and overlaps to encode the possible configurations be-
tween those intervals. Allen’s Interval Algebra has been used primarily as a
qualitative constraint language, with applications that involve planning and
scheduling, natural language processing, temporal databases, and multime-
dia databases. Halpern-Shoham logic (HS-logic [27]) is a well-known logical
framework that incorporates Allen’s Interval Algebra as a formal component
of the logic. HS-logic contains modal operators representing Allen’s binary
relations between intervals that include: begins or started-by (B), during or
contains (D), ends or finished-by (E), overlaps (O), meets or adjacent to (A),
later than (L), and their converses. For example, <B> φ reads that “there is
an interval beginning the current interval, in which φ holds.” Therefore, the
basic building block of reasoning in HS-logic is an interval, with its intrinsic
expressive power grounded in the semantic structures [28, 29].
Temporal Cohort Logic (TCL [17]), a precursor of this paper, was devel-
oped to explicitly capture Allen relations as (binary) modal operators in the
logic, rather than in the model (as in HS-logic). Formally, TCL formulas are
defined as:
φ,ψ ::= p | ¬φ | φ∧ψ | φ∨ψ | φXψ,
where atomic propositions p are drawn from the same predefined set Prop.
Binary modal operators X are drawn from the collection {A,L,B,E,D,O},
with respective intended denotations similar to HS-notations. To both relate
31to and differentiate from HS-logic, we use the same temporal modalities
syntactically. Classical boolean logic operators are included in the syntax:
¬ for “not” or negation; ∧ for “and” or conjunction; and ∨ for “or”, or
disjunction.
For example, “Intracerebral hemorrhage started by heart attack” is ex-
pressed by I61 B I219, where I61 is the ICD-10 code “nontraumatic intrac-
erebral hemorrhage,” and I219 is the ICD-10 code for “acute myocardial
infarction.”
Note that TCL formulas do not explicitly involve time-terms. However,
in order to relate TCL to TEL, we define the semantics of TCL formulas
using the same underlying structure M+. With respect to α : M+ → 2P and
s ∈ M+, we define:
(α,s) |= p if p ∈ α(s);
(α,s) |= ¬φ if (α,s) ̸|= φ;
(α,s) |= φ∨ψ if (α,s) |= φ or (α,s) |= ψ;
(α,s) |= φ∧ψ if (α,s) |= φ and (α,s) |= ψ.
Thus the Boolean connectors carry the standard semantics, which agrees
with TEL’s interpretation as well. Also note that the previously used en-
vironmental context E is not all relevant because of the lack of time terms
and free variables. What becomes involved is the semantics of binary Allen
modal operators, given in the definition below.
Definition 4. With respect to α : M+ → 2P and s ∈ M+, we define (where
φ stands for ¬φ):
Meets: (α,s) |= φAψ if there exists v > u > s ∈ M+ such that
for any t ∈ M+ with s ≤ t < u, (α,t) |= φ∧ψ;
for any t ∈ M+ with u ≤ t < v, (α,t) |= ψ ∧φ;
for any t ∈ M+ with t ≥ v, (α,t) |= φ∧ψ.
Before: (α,s) |= φLψ if there exists w > v > u > s ∈ M+ such that
for any t ∈ M+ with s ≤ t < u, (α,t) |= φ∧ψ;
for any t ∈ M+ with u ≤ t < v, (α,t) |= φ∧ψ;
for any t ∈ M+ with v ≤ t < w, (α,t) |= φ∧ψ;
for any t ∈ M+ with t ≥ w, (α,t) |= φ∧ψ;
32Started-by: (α,s) |= φBψ if there exists v > u > s ∈ M+ such that
for any t ∈ M+ with s ≤ t < u, (α,t) |= φ∧ψ;
for any t ∈ M+ with u ≤ t < v, (α,t) |= φ∧ψ;
for any t ∈ M+ with t ≥ v, (α,t) |= φ∧ψ.
Finished-by: (α,s) |= φEψ if there exists v > u > s ∈ M+ such that
for any t ∈ M+ with s ≤ t < u, (α,t) |= φ∧ψ;
for any t ∈ M+ with u ≤ t < v, (α,t) |= φ∧ψ;
for any t ∈ M+ with t ≥ v, (α,t) |= φ∧ψ.
Contains: (α,s) |= φDψ if there exists w > v > u > s ∈ M+ such that
for any t ∈ M+ with s ≤ t < u, (α,t) |= φ∧ψ;
for any t ∈ M+ with u ≤ t < v, (α,t) |= φ∧ψ;
for any t ∈ M+ with v ≤ t < w, (α,t) |= φ∧ψ;
for any t ∈ M+ with t ≥ w, (α,t) |= φ∧ψ;
Overlaps: (α,s) |= φOψ if there exists w > v > u > s ∈ M+ such that
for any t ∈ M+ with s ≤ t < u, (α,t) |= φ∧ψ;
for any t ∈ M+ with u ≤ t < v, (α,t) |= φ∧ψ;
for any t ∈ M+ with v ≤ t < w, (α,t) |= φ∧ψ;
for any t ∈ M+ with t ≥ w, (α,t) |= φ∧ψ;
The intended semantics of these TCL modal operators can be understood
as Allen’s interval relations on the “monochromatic substructure” induced
by the respective TCL formulas (see Figure 1 for an illustration).
Definition 5. A subset T ⊆ M+ is said to be φ-monochromatic with respect
to a semantic assignment function α : M+ → 2P if for each t ∈ T, we have
(α,t) |= φ. A φ-induced monochromatic set, or φ-set in short and [[φ]] in
α
notation, is defined as [[φ]] := {t ∈ M+ | (α,t) |= φ}.
α
The key distinction from the interpretation of Allen’s interval operator
or HS logic is that we do not require φ-set to be convex, in the sense that
if t falls in between two members in [[φ]] , it is not necessarily the case that
α
t is also a member in [[φ]] . Intuitively, [[φ]] can be “porous,” to reflect the
α α
general situation of non-consecutive events of the same kind taking place,
sometimes sporadically, overtime.
330<latexit sha1_base64="SvEw9j+G6/nNSZebhlvQwRvlSiI=">AAAB6HicbVBNS8NAEJ3Ur1q/qh69LBbBU0mkqMeiF48t2FpoQ9lsJ+3azSbsboQS+gu8eFDEqz/Jm//GbZuDtj4YeLw3w8y8IBFcG9f9dgpr6xubW8Xt0s7u3v5B+fCoreNUMWyxWMSqE1CNgktsGW4EdhKFNAoEPgTj25n/8IRK81jem0mCfkSHkoecUWOlptsvV9yqOwdZJV5OKpCj0S9/9QYxSyOUhgmqdddzE+NnVBnOBE5LvVRjQtmYDrFrqaQRaj+bHzolZ1YZkDBWtqQhc/X3REYjrSdRYDsjakZ62ZuJ/3nd1ITXfsZlkhqUbLEoTAUxMZl9TQZcITNiYgllittbCRtRRZmx2ZRsCN7yy6ukfVH1Lqu1Zq1Sv8njKMIJnMI5eHAFdbiDBrSAAcIzvMKb8+i8OO/Ox6K14OQzx/AHzucPfAeMvQ==</latexit> t<latexit sha1_base64="4mSRiAOC1HPbUsbyd7QN48TyFAA=">AAAB6HicbVBNS8NAEJ3Ur1q/qh69LBbBU0mkqMeiF48t2FpoQ9lsN+3azSbsToQS+gu8eFDEqz/Jm//GbZuDtj4YeLw3w8y8IJHCoOt+O4W19Y3NreJ2aWd3b/+gfHjUNnGqGW+xWMa6E1DDpVC8hQIl7ySa0yiQ/CEY3878hyeujYjVPU4S7kd0qEQoGEUrNbFfrrhVdw6ySrycVCBHo1/+6g1ilkZcIZPUmK7nJuhnVKNgkk9LvdTwhLIxHfKupYpG3PjZ/NApObPKgISxtqWQzNXfExmNjJlEge2MKI7MsjcT//O6KYbXfiZUkiJXbLEoTCXBmMy+JgOhOUM5sYQyLeythI2opgxtNiUbgrf88ippX1S9y2qtWavUb/I4inACp3AOHlxBHe6gAS1gwOEZXuHNeXRenHfnY9FacPKZY/gD5/MH4xeNAQ==</latexit>
'
<latexit sha1_base64="bxOprab7PZ3NYj9lgTqUs5KPTJ8=">AAAB7nicbVDLSgNBEOyNrxhfUY+KDAbBU9gVUY9BLx4TMA9IljA7mU2GzM4OM7OBsOToB3jxoIhXPyHf4c1v8CecPA6aWNBQVHXT3RVIzrRx3S8ns7K6tr6R3cxtbe/s7uX3D2o6ThShVRLzWDUCrClnglYNM5w2pKI4CjitB/27iV8fUKVZLB7MUFI/wl3BQkawsVK9NcBK9lg7X3CL7hRomXhzUigdjyvfjyfjcjv/2erEJImoMIRjrZueK42fYmUY4XSUayWaSkz6uEublgocUe2n03NH6MwqHRTGypYwaKr+nkhxpPUwCmxnhE1PL3oT8T+vmZjwxk+ZkImhgswWhQlHJkaT31GHKUoMH1qCiWL2VkR6WGFibEI5G4K3+PIyqV0UvaviZcWmcQszZOEITuEcPLiGEtxDGapAoA9P8AKvjnSenTfnfdaaceYzh/AHzscPazeTVg==</latexit>
'
<latexit sha1_base64="bxOprab7PZ3NYj9lgTqUs5KPTJ8=">AAAB7nicbVDLSgNBEOyNrxhfUY+KDAbBU9gVUY9BLx4TMA9IljA7mU2GzM4OM7OBsOToB3jxoIhXPyHf4c1v8CecPA6aWNBQVHXT3RVIzrRx3S8ns7K6tr6R3cxtbe/s7uX3D2o6ThShVRLzWDUCrClnglYNM5w2pKI4CjitB/27iV8fUKVZLB7MUFI/wl3BQkawsVK9NcBK9lg7X3CL7hRomXhzUigdjyvfjyfjcjv/2erEJImoMIRjrZueK42fYmUY4XSUayWaSkz6uEublgocUe2n03NH6MwqHRTGypYwaKr+nkhxpPUwCmxnhE1PL3oT8T+vmZjwxk+ZkImhgswWhQlHJkaT31GHKUoMH1qCiWL2VkR6WGFibEI5G4K3+PIyqV0UvaviZcWmcQszZOEITuEcPLiGEtxDGapAoA9P8AKvjnSenTfnfdaaceYzh/AHzscPazeTVg==</latexit> -monochromatic
<latexit sha1_base64="Ork8C09ZsRFIeIIHK5fWHY/LnMs=">AAAB63icbVDLSgNBEOz1GeMr6lGRwSB4Crsi6jHoxWMC5gHJEmYns8mQmdllZlYIS45evXhQxKv/kO/w5jf4E84mOWhiQUNR1U13VxBzpo3rfjlLyyura+u5jfzm1vbObmFvv66jRBFaIxGPVDPAmnImac0ww2kzVhSLgNNGMLjN/MYDVZpF8t4MY+oL3JMsZASbTGrHmnUKRbfkToAWiTcjxfLRuPr9eDyudAqf7W5EEkGlIRxr3fLc2PgpVoYRTkf5dqJpjMkA92jLUokF1X46uXWETq3SRWGkbEmDJurviRQLrYcisJ0Cm76e9zLxP6+VmPDaT5mME0MlmS4KE45MhLLHUZcpSgwfWoKJYvZWRPpYYWJsPHkbgjf/8iKpn5e8y9JF1aZxA1Pk4BBO4Aw8uIIy3EEFakCgD0/wAq+OcJ6dN+d92rrkzGYO4A+cjx8ULJH6</latexit> -monochromatic
<latexit sha1_base64="Ork8C09ZsRFIeIIHK5fWHY/LnMs=">AAAB63icbVDLSgNBEOz1GeMr6lGRwSB4Crsi6jHoxWMC5gHJEmYns8mQmdllZlYIS45evXhQxKv/kO/w5jf4E84mOWhiQUNR1U13VxBzpo3rfjlLyyura+u5jfzm1vbObmFvv66jRBFaIxGPVDPAmnImac0ww2kzVhSLgNNGMLjN/MYDVZpF8t4MY+oL3JMsZASbTGrHmnUKRbfkToAWiTcjxfLRuPr9eDyudAqf7W5EEkGlIRxr3fLc2PgpVoYRTkf5dqJpjMkA92jLUokF1X46uXWETq3SRWGkbEmDJurviRQLrYcisJ0Cm76e9zLxP6+VmPDaT5mME0MlmS4KE45MhLLHUZcpSgwfWoKJYvZWRPpYYWJsPHkbgjf/8iKpn5e8y9JF1aZxA1Pk4BBO4Aw8uIIy3EEFakCgD0/wAq+OcJ6dN+d92rrkzGYO4A+cjx8ULJH6</latexit>
t<latexit sha1_base64="4mSRiAOC1HPbUsbyd7QN48TyFAA=">AAAB6HicbVBNS8NAEJ3Ur1q/qh69LBbBU0mkqMeiF48t2FpoQ9lsN+3azSbsToQS+gu8eFDEqz/Jm//GbZuDtj4YeLw3w8y8IJHCoOt+O4W19Y3NreJ2aWd3b/+gfHjUNnGqGW+xWMa6E1DDpVC8hQIl7ySa0yiQ/CEY3878hyeujYjVPU4S7kd0qEQoGEUrNbFfrrhVdw6ySrycVCBHo1/+6g1ilkZcIZPUmK7nJuhnVKNgkk9LvdTwhLIxHfKupYpG3PjZ/NApObPKgISxtqWQzNXfExmNjJlEge2MKI7MsjcT//O6KYbXfiZUkiJXbLEoTCXBmMy+JgOhOUM5sYQyLeythI2opgxtNiUbgrf88ippX1S9y2qtWavUb/I4inACp3AOHlxBHe6gAS1gwOEZXuHNeXRenHfnY9FacPKZY/gD5/MH4xeNAQ==</latexit>
0<latexit sha1_base64="SvEw9j+G6/nNSZebhlvQwRvlSiI=">AAAB6HicbVBNS8NAEJ3Ur1q/qh69LBbBU0mkqMeiF48t2FpoQ9lsJ+3azSbsboQS+gu8eFDEqz/Jm//GbZuDtj4YeLw3w8y8IBFcG9f9dgpr6xubW8Xt0s7u3v5B+fCoreNUMWyxWMSqE1CNgktsGW4EdhKFNAoEPgTj25n/8IRK81jem0mCfkSHkoecUWOlptsvV9yqOwdZJV5OKpCj0S9/9QYxSyOUhgmqdddzE+NnVBnOBE5LvVRjQtmYDrFrqaQRaj+bHzolZ1YZkDBWtqQhc/X3REYjrSdRYDsjakZ62ZuJ/3nd1ITXfsZlkhqUbLEoTAUxMZl9TQZcITNiYgllittbCRtRRZmx2ZRsCN7yy6ukfVH1Lqu1Zq1Sv8njKMIJnMI5eHAFdbiDBrSAAcIzvMKb8+i8OO/Ox6K14OQzx/AHzucPfAeMvQ==</latexit>
Figure 1: Illustration of the “before” relationship between φ- and ψ-
monochromatic substructures.
For example, the satisfaction definition for “started-by,” (α,s) |= φBψ,
can be interpreted as: “φ-set is started by ψ-set in the co-finite segment
[s,∞),” where we treat φ-set and ψ-set in the usual sense of Allen inter-
vals (as monochromatic substructures). Note that our definition allows open
ended, “infinitely large” intervals to be in scope of the relational comparison,
although the con-finiteness property of φ-sets makes them not too unwieldy.
Theorem 7. For each modal operator in {A,L,B,E,D,O}, the temporal re-
lation between the corresponding φ- and ψ-monochromatic substructures of
M+ induced by any assignment α : M+ → 2P, according to Definition 5,
satisfies the standard definition of Allen relationships.
To see why Theorem 7 is true, consider, for “Meets,” a fixed assignment
α : M+ → 2P, and let (α,s) |= φAψ, S = [s,∞)∩[[φ]] , and T = [s,∞)∩
α
[[ψ]] . By Definition 4, we have a < b for any a ∈ S and b ∈ T, and
α
[s,u) ∩ S = [s,u), [u,v) ∩ T = T. Moreover, (S ∪ T) ∩ [u,∞) = ∅. This
results in the Allen’s relation that the observed monochromatic substructure
S meets the monochromatic substructure T (precisely) at u.
Similarly, for “Before,” if we invoke the same contextual information for
φLψ, the “intervals” S and T have the relationship that S ∩[s,u) = [s,u),
and T ∩[v,w] = T, (S ∪T)∩[u,v) = ∅, and (S ∪T)∩[w,∞) = ∅. Thus S
is “Before” T in the Allen interval relationship (see Figure 1).
For “Started-by,” we invoke the same contextual information for φBψ.
34The “intervals” S and T have the relationship that S ∩[s,u) = T ∩[s,u) =
[s,u), and T ∩[u,∞) = ∅. This means that in the initial segment [s,u), both
φ and ψ are true, but then only φ is true in [u,v), while in the remainder of
the open-ended interval [v,∞), both are false.
For “Finished-by,” φEψ, the “intervals” S and T have the properties
that S ∩ [s,u) = [s,u), T ∩ [s,u) = ∅, S ∩ [u,v) = T ∩ [u,v) = [u,v), and
(S∪T)∩[v,∞) = ∅, capturing the corresponding Allen relationship between
S and T. Similar inspections can demonstrate validity for “Contains,” and
“Overlaps.”
With the introduction of TCL provided in the previous section, we are in
a position to present the following result.
Theorem 8. All Allen modal operators in {A,L,B,E,D,O} are expressible
in Temporal Ensemble Logic.
The proof of Theorem 8 amounts to representing each of the formulas
φAψ, φLψ, φBψ, φEψ, φDψ, φOψ using the syntax of TEL while pre-
serving their semantics. We provide a general translation strategy as follows.
Suppose we are interested in the pattern that φ1 (we use superscripts
to represent different formulas in order to reserve subscripts for time terms)
holdsintheentireinterval(s,b), φ2 holdsintheentireinterval(b,c), φ3 holds
in the entire interval (c,d), and φ4 holds in the entire interval (d,e), where
b = s+a , c = s+a +a , d = s+a +a +a , and e = s+a +a +a +a .
1 1 2 1 2 3 1 2 3 4
This can be captured precisely using the following formula by carefully
examining the semantic definition for TEL:
∃x ∃x ∃x ∃x [(□ φ1)∧(□ φ2) ∧(□ φ3) )∧(□ φ4) )] (1)
1 2 3 4 x1 x2 x1 x3 x1+x2 x4 x1+x2+x3
By instantiating φi’s with different formulas, we can require different
properties to hold in each of the consecutive intervals between s,b,c,d,e
to have different properties, whereby representing different relationships be-
tween φ and ψ in Allens operators. To avoid notational clutter, we specify
the following abbreviations.
Definition 6. In TEL we define the following formula templates for a se-
quence of TEL formulas {φi | i ≥ 1} without containing any x as free
i
35variables:
{φ1} := ∃x (□ φ1)
1 x1
{φ1;φ2} := ∃x ∃x [(□ φ1)∧(□ φ2) ]
1 2 x1 x2 x1
{φ1;φ2;φ3} := ∃x ∃x ∃x [(□ φ1)∧(□ φ2) ∧(□ φ3) )]
1 2 3 x1 x2 x1 x3 x1+x2
{φ1;φ2;φ3;φ4} := Formula 1 above
···
We also introduce variants of this notation with open-ending, where the
last occurrence of □ is unbounded on the right:
{φ1) := □φ1
{φ1;φ2) := ∃x [(□ φ1)∧(□φ2) ]
1 x1 x1
{φ1;φ2;φ3) := ∃x ∃x [(□ φ1)∧(□ φ2) ∧(□φ3) )]
1 2 x1 x2 x1 x1+x2
{φ1;φ2;φ3;φ4) :=
∃x ∃x ∃x [(□ φ1)∧(□ φ2) ∧(□ φ3) )∧(□φ4) )]
1 2 3 x1 x2 x1 x3 x1+x2 x1+x2+x3
···
As usual, naming of bound variables do not affect the semantics. So x ’s
i
can be replaced by any variable names.
For illustration, the formula {φ;ψ;ξ} captures the pattern in Figure 2.
To see why this is true, we have
(E,s) |= {φ;ψ;ξ}
iff
(E,s) |= ∃x ∃x ∃x [(□ φ)∧(□ ψ) ∧(□ ξ) )]
1 2 3 x1 x2 x1 x3 x1+x2
iff there exist a,b,c ∈ M+
(E[x := a;x := b;x := c],s) |= [(□ φ)∧(□ ψ) ∧(□ ξ) )]
1 2 3 x1 x2 x1 x3 x1+x2
iff there exist a,b,c ∈ M+
(E[x := a;x := b;x := c],s) |= □ φ and
1 2 3 x1
(E[x := a;x := b;x := c],s) |= (□ ψ) and
1 2 3 x2 x1
(E[x := a;x := b;x := c],s) |= (□ ξ)
1 2 3 x3 x1+x2
iff
for all t ∈ M+ such that s ≤ t < s+a,(E,t) |= φ and
(E[x := a;x := b;x := c],s+a) |= □ ψ and
1 2 3 x2
(E[x := a;x := b;x := c],s+a+b) |= □ ξ
1 2 3 x3
iff
for all t ∈ M+ such that s ≤ t < s+a,(E,t) |= φ and
for all t ∈ M+ such that s+a ≤ t < s+a+b,(E,t) |= ψ and
for all t ∈ M+ such that s+a+b ≤ t < s+a+b+c, (E,t) |= ξ.
36φ ψ ξ
s s+a s+a+b s+a+b+c
a c
b
Figure 2: Illustration of the pattern for {φ;ψ;ξ}. The red interval is φ-
monochromatic, the blue π-monochromatic, and the green ξ-monochromatic.
All intervals are closed on the left end and open on the right end.
Note that our notational convention (Definition 6) assumes that φ,ψ,ξ
do not contain any x ,x , or x as free variables. Therefore, when evaluating
1 2 3
the formulas φ,ψ,ξ, the environments E and E[x := a;x := b;x := c] give
1 2 3
the same result and we used a concise version in the proof line above.
With these validation and notional preparations, we provide the following
translation of TCL Allen formulas into TEL formulas.
Table 2. TCL to TEL Translation Table
Allen operator TCL TEL (ξ stands for ¬ξ)
Meets φAψ {φ∧ψ;ψ ∧φ;φ∧ψ)
Before φLψ {φ∧ψ;φ∧ψ;ψ ∧φ;φ∧ψ)
Started-by φBψ {φ∧ψ;φ∧ψ;φ∧ψ)
Finished-by φEψ {φ∧ψ;φ∧ψ;φ∧ψ)
Contains φDψ {φ∧ψ;φ∧ψ;φ∧ψ;φ∧ψ)
Overlaps φOψ {φ∧ψ;φ∧ψ;ψ ∧φ;φ∧ψ)
We can see from the semantic definitions that the TEL formulas in Table
1capturespreciselythesamesemanticsforthecorrespondingAllenrelations.
6 Applications in Biomedicine: an Outlook
Formal methods in general, and logic in particular, have been applied in
biomedicine in two broad categories of scenarios. One is for modeling and
simulationinsystemsbiology[30,31,32,33,34],andtheotherisformodeling
phenotypesofbiologicalorganisms[2,3,17]. Theworkreportedinthispaper
is motivated from the need to advance the scope of the latter.
In biology, phenotype represents the collection of observable traits of an
organism, comprising morphology and physiology at the levels of the cell,
37the organ, and the body. Behavior and epigenetic profiles in response to
environmental cues are also considered as a part of an organism’s phenotype.
Inbiomedicine,theterm“phenotype”isoftenusedtorefertodeviationsfrom
normal morphology, physiology, or behavior. This latter notion is routinely
used in clinical and healthcare settings (Table 3).
Table 3. Sample temporal/sequential phenotypes from
epilepsy, cardiology, sleep, and genetics
Term Description
Generalized tonic- A type of seizure with a generalized muscle stiff-
clonic seizure ening tonic phase, followed by rhythmical jerking
clonic phase.
Long QT syndrome An electrocardiogram labels the heart’s electrical
signals as five patterns using the letters P, Q, R,
S and T. Waves Q through T show the electrical
activity in the heart’s lower chambers. Prolonged
QT-interval, if undiagnosed and untreated, may
lead to erratic heartbeats and death.
Constitutive and Constitutive splicing is the process that mRNA is
alternative-splicing spliced identically, producing the same isoforms.
Alternativesplicinginducesformationofdifferent
isoforms of cell surface receptors in cancer cell
proliferation.
Non-REM sleep Non-REM sleep has three stages, each lasting 5
to 15 minutes. During stage 3, the body repairs
and regrows tissues, builds bone and muscle, and
strengthens the immune system.
As can be gleaned from Table 3, temporal patterns are a basic build-
ing block for phenotypes in biomedicine. A logic-based phenotyping frame-
work can benefit the documentation, communication, and implementation of
health records systems, their interfaces and applications with elevated pre-
cision for rigor and reproducibility. It adds a layer with mathematical rigor
in clinical and translational research based on observational data. All efforts
databasing RWD (e.g., i2b2 [35, 36], ACE [37], CALYPSO [38], ELII [39])
can enrich the query engine and query interfaces more formally and system-
atically guided by temporal-logic-based specifications as queries. Data struc-
tures accelerating the algorithm for logic-based phenotyping and cohort dis-
38coverycouldbedevelopedaccordinglytoelevatetherigorandreproducibility
while taming the computational complexity.
The entire area of genotyping for health and for disease can be amendable
for a temporal logic treatment, in a similar way neurophysiological data are
treated [17] but perhaps with different requirements and techniques. “Tem-
poral” reasoning for genome sequences is a common practice but has so far
not been connected or elevated to logical levels. Perhaps the only work hint-
ing possibility in this direction is reported in [40], which employs Allen’s in-
tervalalgebraforefficientimplementationofasequencealignmentalgorithm.
This all represents opportunities for the development of formal frameworks
for logic-based phenotyping.
7 Discussion
Given the extensive body of work and sustained interest in temporal logics,
several remarks are in order to clarify the shared theoretical grounding and
distinct features that differentiate TEL from existing logical frameworks, as
well as open-ended research topics.
7.1 Trade-off of expressive power between syntax and
semantic structures
There is in general a set-up decision between the syntax and semantics of
a logical framework. The more rich and expressive the semantic structures
allowed, thelessneedthereistoenrichthesyntacticconstructs. Ontheother
hand, the simpler the semantic structure, the richer the syntactic logical
constructs are required to attain similar overall expressive power. Therefore,
we consider the syntax and semantic structures together as a whole package
for the expressive power of a logic. Minimizing both while still achieving
similar expressive powers would be a worth-while goal for simplicity and
elegance, as well as for applications.
We use several examples to illustrate this point. In HS-logic [27], Allen’s
binaryrelationsbetweenintervalsareexpressedusingunarymodaloperators.
Its semantic structure models the possible corresponding binary relations,
with the computational complexity and expressive power mostly afforded
from the semantic structure side [28, 29]. In HyperLTL [19, 20, 21], the
expressive power comes from the extension of LTL by adding traces (paths)
39in the semantic structure, as well as by making the traces quantifiable in
the syntax. In freeze-LTL [41, 42], the overall expressive power comes by
extending(ω)-wordswithassociatedvalues,andbuildinginlogicalconstructs
to deal with data values.
7.2 Minimalist nature of first-order quantifications on
time-length in TEL
In contrast, TEL uses the same semantic structures as those in LTL, formal-
ized generally through a monoid M structure that covers discrete linear time
and dense linear time. The only addition in syntax is the introduction of
time-length variables and its first-order quantifications. Time-terms are ex-
plicitly and independently defined syntactic entities with addition as the only
required operation, in the form of s+t. We can then use first-order quanti-
fiers and modal operators by turning any TEL formula φ into a meaningful
monadic predicate φ . Because of the simple and straightforward manner of
t
the syntax and semantics, TEL can be readily enriched or modified to other
settings, such weighted, metric, and interval logics.
7.3 Expressiveness, decidability, complexity, and spa-
tial reasoning
Although we have established the undecidability of TEL , many theoreti-
N+
cal questions remain. For example, what is the overall expressive power of
TEL in terms of the language class defined by TEL -formulas? It seems
N+ N+
anticipatable that TEL would be able to capture, in addition to ω-regular
N+
languages [24], other types of ω-languages constructed using the approach of
various types of ω-automata [18].
What is the value and consequence of explicitly incorporating subtraction
(−) or past into time-length terms (s − t; with positive results required)?
There are several studies that highlight the incorporation of “past” being a
line between decidability and undecidability (e.g., [43, 44]), but that should
not completely deter us from incorporating it as a construct in forming de-
cidable fragments.
What are the decidable fragments of TEL ? In general, decidability
N+
results can be achieved by automata-theoretical constructs [22, 44]. Based
on the development in Section 5, it seems that the negation-free, {∃,□ ,□}
t
40fragment of TEL would be an interesting initial setting to study both the
N+
decidability and expressiveness properties [45].
Computationalcomplexityfordecidabilityandformodel-checking,etc[46,
47, 48], would be topics naturally motivated by application and implemen-
tation needs.
Additionally, enrichment or modification through weighted [49], met-
ric [50, 51], interval logics [52, 53], the formulation of TEL to spatial set-
ting [54, 55] and the interplay between temporal-spatial domains a can be
meaningfully explored.
8 Conclusion
WeintroducedTemporalEnsembleLogic, atimedmonadic, first-ordermodal
logic for linear-time temporal reasoning with an intuitive and minimalistic
set of temporal constructs. We provided syntax and semantics for TEL and
established basic semantic equivalences, with distinctions between dense and
discrete settings. We proved the undecidability of the satisfiability of TEL
for the positive integer domain, and discussed its expressive power through
ω-languages, as well as offered application outlook in biomedicine. The hope
is work to inspire a line of concentrated work to develop a foundation for
logic-based phenotyping in biomedicine. Clearly, much remains to be done.
Acknowledgment
We thank Anthony Cohn, Licong Cui, Manfred Droste, Yan Huang and Xi-
aojin Li for feedback and illuminating discussions. This work was supported
by the National Institutes of Health grants R01NS126690 and R01NS116287
of the United States. The views of the paper are those of the authors and
do not reflect those of the funding agencies.
References
[1] Juan Carlos Augusto. Temporal reasoning for decision support in
medicine. Artificial intelligence in medicine, 33(1):1–24, 2005.
41[2] Klaus-Peter Adlassnig, Carlo Combi, Amar K Das, Elpida T Keravnou,
andGiuseppePozzi. Temporalrepresentationandreasoninginmedicine:
Research directions and challenges. Artificial intelligence in medicine,
38(2):101–113, 2006.
[3] Frank W Hartel, Sherri de Coronado, Robert Dionne, Gilberto Fragoso,
andJenniferGolbeck. Modelingadescriptionlogicvocabularyforcancer
research. Journal of biomedical informatics, 38(2):114–129, 2005.
[4] James F Allen. Maintaining knowledge about temporal intervals. Com-
munications of the ACM, 26(11):832–843, 1983.
[5] www.fda.gov/science-research/science-and-research-special-topics/real-
world evidence. Real-world evidence.
[6] James R Rogers, Junghwan Lee, Ziheng Zhou, Ying Kuen Cheung,
George Hripcsak, and Chunhua Weng. Contemporary use of real-world
data for clinical trial conduct in the united states: a scoping review.
Journal of the American Medical Informatics Association, 28(1):144–
154, 2021.
[7] JueHou, RachelZhao, JessicaGronsbell, YucongLin, Clara-LeaBonzel,
Qingyi Zeng, Sinian Zhang, Brett K Beaulieu-Jones, Griffin M Weber,
Thomas Jemielita, et al. Generate analysis-ready data for real-world ev-
idence: Tutorial for harnessing electronic health records with advanced
informatictechnologies. Journal of medical Internet research, 25:e45662,
2023.
[8] James R Rogers, Junghwan Lee, Ziheng Zhou, Ying Kuen Cheung,
George Hripcsak, and Chunhua Weng. Contemporary use of real-world
data for clinical trial conduct in the united states: a scoping review.
Journal of the American Medical Informatics Association, 28(1):144–
154, 2021.
[9] Christian Maier, Lorenz A Kapsner, Sebastian Mate, Hans-Ulrich
Prokosch, and Stefan Kraus. Patient cohort identification on time series
data using the omop common data model. Applied Clinical Informatics,
12(01):057–064, 2021.
[10] Edmund M Clarke. Model checking. In Foundations of Software Tech-
nology and Theoretical Computer Science: 17th Conference Kharagpur,
42India, December 18–20, 1997 Proceedings 17, pages 54–56. Springer,
1997.
[11] Moshe Y Vardi. Model checking for database theoreticians. In Interna-
tional Conference on Database Theory, pages 1–16. Springer, 2005.
[12] Nicholas Rescher and Alasdair Urquhart. Temporal logic, volume 3.
Springer Science & Business Media, 2012.
[13] Amir Pnueli and Zohar Manna. The temporal logic of reactive and con-
current systems: specifications, volume 16:12. Springer, 1992.
[14] Patrick Blackburn, Maarten De Rijke, and Yde Venema. Modal logic:
graph. Darst, volume 53. Cambridge University Press, 2001.
[15] Colin Stirling. Modal and temporal logics. LFCS, Department of Com-
puter Science, University of Edinburgh, 1991.
[16] AmirPnueli. Thetemporallogicofprograms. In18th annual symposium
on foundations of computer science (sfcs 1977), pages 46–57. ieee, 1977.
[17] Guo-Qiang Zhang, Xiaojin Li, Yan Huang, and Licong Cui. Temporal
cohort logic. In AMIA Annual Symposium Proceedings, volume 2022,
page 1237. American Medical Informatics Association, 2022.
[18] Mario Grobler and Sebastian Siebertz. B\” uchi-like character-
izations for parikh-recognizable omega-languages. arXiv preprint
arXiv:2302.04087, 2023.
[19] Michael R Clarkson, Bernd Finkbeiner, Masoud Koleini, Kristopher K
Micinski, Markus N Rabe, and C´esar S´anchez. Temporal logics for hy-
perproperties. In Principles of Security and Trust: Third International
Conference, POST 2014, Held as Part of the European Joint Confer-
ences on Theory and Practice of Software, ETAPS 2014, Grenoble,
France, April 5-13, 2014, Proceedings 3, pages 265–284. Springer, 2014.
[20] Bernd Finkbeiner and Christopher Hahn. Deciding hyperproperties.
arXiv preprint arXiv:1606.07047, 2016.
[21] Raven Beutner, David Carral, Bernd Finkbeiner, Jana Hofmann, and
Markus Kr¨otzsch. Deciding hyperproperties combined with functional
43specifications. In Proceedings of the 37th Annual ACM/IEEE Sympo-
sium on Logic in Computer Science, pages 1–13, 2022.
[22] Javier Esparza, Jan Kˇret´ınsky`, and Salomon Sickert. One theorem to
rule them all: A unified translation of ltl into ω-automata. In Proceed-
ings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer
Science, pages 384–393, 2018.
[23] St´ephane Demri, Valentin Goranko, and Martin Lange. Temporal log-
ics in computer science: finite-state systems, volume 58. Cambridge
University Press, 2016.
[24] J Richard Bu¨chi. Weak second-order arithmetic and finite automata.
Mathematical Logic Quarterly, 6(1-6), 1960.
[25] Moshe Y Vardi. An automata-theoretic approach to linear temporal
logic. Logics for concurrency: structure versus automata, pages 238–
266, 2005.
[26] Wolfgang Thomas. Automata on infinite objects. In Formal Models and
Semantics, pages 133–191. Elsevier, 1990.
[27] Joseph Y Halpern and Yoav Shoham. A propositional modal logic of
time intervals. Journal of the ACM (JACM), 38(4):935–962, 1991.
[28] Davide Bresolin, Angelo Montanari, Pietro Sala, and Guido Sciavicco.
What’s decidable about halpern and shoham’s interval logic? the max-
imal fragment abbl. In 2011 IEEE 26th Annual Symposium on Logic in
Computer Science, pages 387–396. IEEE, 2011.
[29] Jerzy Marcinkowski and Jakub Michaliszyn. The ultimate undecidabil-
ity result for the halpern-shoham logic. In 2011 IEEE 26th Annual
Symposium on Logic in Computer Science, pages 377–386. IEEE, 2011.
[30] Aviv Regev. Computational systems biology: a calculus for biomolecular
knowledge. PhD thesis, PhD thesis, Tel Aviv University, 2002.
[31] Marek Kwiatkowski and Ian Stark. The continuous π-calculus: A pro-
cess algebra for biochemical modelling. In International Conference on
Computational Methods in Systems Biology, pages 103–122. Springer,
2008.
44[32] Federica Ciocchetta and Jane Hillston. Bio-pepa: A framework for the
modelling and analysis of biological systems. Theoretical Computer Sci-
ence, 410(33-34):3065–3084, 2009.
[33] JasminFisherandThomasAHenzinger. Executablecellbiology. Nature
biotechnology, 25(11):1239–1249, 2007.
[34] Elisabetta De Maria, Jo¨elle Despeyroux, Amy Felty, Pietro Lio´, Carlos
Olarte, and Abdorrahim Bahrami. Computational logic for biomedicine
and neurosciences. Symbolic Approaches to Modeling and Analysis of
Biological Systems, page 187, 2023.
[35] Shawn N Murphy, Michael Mendis, Kristel Hackett, Rajesh Kuttan,
Wensong Pan, Lori C Phillips, Vivian Gainer, David Berkowicz, John P
Glaser, Isaac Kohane, et al. Architecture of the open-source clinical re-
search chart from informatics for integrating biology and the bedside. In
AMIA annual symposium proceedings, volume 2007, page 548. American
Medical Informatics Association, 2007.
[36] Shawn N Murphy, Griffin Weber, Michael Mendis, Vivian Gainer,
Henry C Chueh, Susanne Churchill, and Isaac Kohane. Serving the
enterprise and beyond with informatics for integrating biology and the
bedside (i2b2). Journal of the American Medical Informatics Associa-
tion, 17(2):124–130, 2010.
[37] Alison Callahan, Vladimir Polony, Jos´e D Posada, Juan M Banda,
Saurabh Gombar, and Nigam H Shah. Ace: the advanced cohort en-
gine for searching longitudinal patient records. Journal of the American
Medical Informatics Association, 28(7):1468–1479, 2021.
[38] Konstadina D Kourou, Vasileios C Pezoulas, Eleni I Georga, Themis P
Exarchos, Panayiotis Tsanakas, Manolis Tsiknakis, Theodora Var-
varigou, Salvatore De Vita, Athanasios Tzioufas, and Dimitrios I Fo-
tiadis. Cohort harmonization and integrative analysis from a biomed-
ical engineering perspective. IEEE reviews in biomedical engineering,
12:303–318, 2018.
[39] Yan Huang, Xiaojin Li, and Guo-Qiang Zhang. Elii: A novel inverted
index for fast temporal query, with application to a large covid-19 ehr
dataset. Journal of Biomedical Informatics, 117:103744, 2021.
45[40] Chengsheng Mao, Alal Eran, and Yuan Luo. Efficient genomic interval
queries using augmented range trees. Scientific reports, 9(1):5059, 2019.
[41] Mikolaj Bojanczyk, Anca Muscholl, Thomas Schwentick, Luc Segoufin,
andClaireDavid. Two-variablelogiconwordswithdata. In21st Annual
IEEE Symposium on Logic in Computer Science (LICS’06), pages 7–16.
IEEE, 2006.
[42] Ahmet Kara, Thomas Schwentick, and Thomas Zeume. Temporal logics
on words with multiple data values. arXiv preprint arXiv:1010.1139,
2010.
[43] AlexanderRabinovich. Temporallogicswithincommensurabledistances
are undecidable. Information and Computation, 205(5):707–715, 2007.
[44] Jo¨el Ouaknine and James Worrell. On the decidability of metric tem-
poral logic. In 20th Annual IEEE Symposium on Logic in Computer
Science (LICS’05), pages 188–197. IEEE, 2005.
[45] DimitarPGuelevandBenMoszkowski. Expressivecompletenessbysep-
aration for discrete time interval temporal logic with expanding modal-
ities. Information Processing Letters, 186:106480, 2024.
[46] Laura Bozzelli, Angelo Montanari, Adriano Peron, and Pietro Sala.
Pspace-completeness of the temporal logic of sub-intervals and suffixes.
Information and Computation, 294:105083, 2023.
[47] Przemys(cid:32)law Andrzej Wa(cid:32)l´ega. Computational complexity of hybrid in-
tervaltemporallogics. Annals of Pure and Applied Logic, 174(1):103165,
2023.
[48] Mark Reynolds. The complexity of temporal logic over the reals. Annals
of Pure and Applied Logic, 161(8):1063–1096, 2010.
[49] Manfred Droste and Paul Gastin. Weighted automata and weighted
logics. In Handbook of weighted automata, pages 175–211. Springer,
2009.
[50] Ron Koymans. Specifying real-time properties with metric temporal
logic. Real-time systems, 2(4):255–299, 1990.
46[51] Rajeev Alur and David L Dill. A theory of timed automata. Theoretical
computer science, 126(2):183–235, 1994.
[52] Rajeev Alur, Thomas A Henzinger, and Moshe Y Vardi. Parametric
real-time reasoning. In Proceedings of the twenty-fifth annual ACM sym-
posium on Theory of computing, pages 592–601, 1993.
[53] Barbara Di Giampaolo, Salvatore La Torre, and Margherita Napoli.
Parametric metric interval temporal logic. Theoretical Computer Sci-
ence, 564:131–148, 2015.
[54] David A Randell, Zhan Cui, and Anthony G Cohn. A spatial logic based
on regions and connection. KR, 92:165–176, 1992.
[55] Danil Akhtiamov, Anthony G Cohn, and Yuri Dabaghian. Spatial rep-
resentability of neuronal activity. Scientific Reports, 11(1):20957, 2021.
47