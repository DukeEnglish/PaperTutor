Noname manuscript No.
(will be inserted by theeditor)
A Mechanism for Discovering Semantic Relationships
among Agent Communication Protocols
Idoia Berges · Jesu´s Bermu´dez · Alfredo
Gon˜i · Arantza Illarramendi
Received: date/Accepted: date
Abstract One relevant aspect in the development of the Semantic Web framework
is the achievement of a real inter-agents communication capability at the semantic
level. Agents should be able to communicate with each other freely using different
communication protocols, constituted bycommunication acts.
Forthatscenario,weintroduceinthispaperanefficientmechanismpresentingthe
following main features:
– It promotes thedescription of the communication acts of protocols as classes that
belong to a communication acts ontology, and associates to those acts a social
commitment semantics formalized through predicates in theEvent Calculus.
– It is sustained on the idea that different protocols can be compared semantically
by looking to the set of fluents associated to each branch of the protocols. Those
sets are generated using Semantic Web technology rules.
– Itdiscoversthefollowingtypesofprotocolrelationships:equivalence,specialization,
restriction, prefix,suffix,infix and complement to infix.
Keywords Agents and the Semantic Web · Ontologies for agent systems · Agent
communication protocols · Agent communication semantics
I.Berges
University of the Basque Country, Paseo Manuel de Lardizabal, 1, Donostia-San Sebasti´an,
Spain
Tel.:+34-943015109
E-mail:idoia-berges@ikasle.ehu.es
J.Bermu´dez
E-mail:jesus.bermudez@ehu.es
A.Gon˜i
E-mail:alfredo@ehu.es
A.Illarramendi
E-mail:a.illarramendi@ehu.es
4202
naJ
92
]AM.sc[
1v61261.1042:viXra2
1 Introduction
InthescenariopromotedbytheemergingWeb,administratorsofexistingInformation
Systems distributed along the Internet are encouraged to provide the functionalities
of those systems, either through agents that represent them or through Web Services.
The underlyingidea is toget real interoperation among those Information Systemsin
order toenlarge thebenefitsthat users can get from theWeb byincreasing machines’
processable tasks.
Although agent technology and Web Services technology have been developed in
separate ways, there exists a recent work (Greenwood and M.Lyell, 2007) which tries
to consolidate their approaches into a common specification describing how to seam-
lessly interconnect FIPA compliant agent systems (FIPA, 2005) with W3C compliant
Web Services. The purpose of specifying an infrastructure for integrating these two
technologies is to provide a common means of allowing each to discover and invoke
instancesof theother.Considering thepreviousapproach,in therest ofthispaperwe
will only concentrate on aspects of inter-agent communication.
In general, communication among agents is based on the interchange of messages,
whichinthiscontextarealsoknownascommunicationacts.However,sinceInformation
Systems are developed independently, they incorporate different classes of communi-
cation acts as their Agent Communication Language (acl) to the point that they do
not understand each other. Moreover, protocols play an integral role in agents com-
munication. A protocol specifies the rules of interaction between agents by restricting
therange of allowed follow-up communication acts for each agent at any stage during
a communicative interaction.
The importance of using communication protocols is widely recognized. However,
thatdoesnotmeanthatalltheagentsshouldusethesameuniversalprotocols. Inour
opiniondifferentcommunication protocolsshouldcoexist andeveryagentshouldhave
the opportunity of selecting the one that better fulfills its needs. Thus, one possible
procedurethattheadministrators of theInformation Systemscouldfollow in orderto
implementtheagentsthatwillrepresenttheirsystemsisthefollowing:Theyshouldfirst
select,from arepositoryofstandardprotocols (morethanonerepositories mayexist),
thoseprotocolsthatbestsuitthegoalsoftheiragents.Sometimesasingleprotocolwill
beenough,whileothertimesitwillbenecessarytodesignaprotocolasacomposition
of other protocols. Then, the selected protocols may be customized before they are
embedded into the agents. This flexibility at the time of choosing and customizing
communicationprotocolshasadrawback:itislikelythattwoprotocolsthathavebeen
designedforthesamegoalhavedifferentstructure.Therefore,areasoningprocessover
theprotocols embeddedin theagents will be necessary todiscover relationships -such
as equivalence and restriction- between them.
Inthispaperwepresentamechanismthatdiscoverssemanticrelationshipsamong
protocols focusing on three main aspects: 1. The semantic representation of the main
elements of theprotocols, that is, of communication acts; 2. Thesemantic representa-
tionoftheprotocols’branchesusingSemanticWebTechnology;and3.Thedefinitions
of a set of semantic relationships between protocols.
Concerning the first point, communication acts that constitute protocols are de-
scribed as classes that belong to a communication acts ontology, which we have de-
veloped, called CommOnt (see more details about the ontology in (Bermu´dez et al,
2007)).Theuseof thatontology favoursboththeexplicit representation of themean-
ingofthecommunicationactsandthecustomizationofexistingstandardprotocolsby3
allowingtheuseofparticularcommunicationactsthatcanbedefinedasspecializations
ofexistingstandardcommunicationacts.Wehaveadoptedthesocalledsocialapproach
(Singh,1998,2000)forexpressingtheintendedsemanticsofthosecommunicationacts.
Accordingtothesocial approach,whenagentsinteracttheybecomeinvolvedinsocial
commitments or obligations to each other.
With respect to the second point, one fundamental step of the mechanism is to
extractthesemanticsassociated toeachprotocol’s branches.Thisstepissustainedon
theideathatthesemanticsofeachbranchisrepresentedbyasetofpredicatesgenerated
after the whole branch is analyzed. During this step Semantic Web technology rules
are used.
Finally, a semantically founded set of basic relationships between protocols is de-
fined,which later can becomposed toexpressmore complex relationships. Ourmech-
anism isabletodiscoverthosecomplexsemanticrelationships takingintoaccountthe
previously mentioned protocol analysis.
Insummary,themain contributionsofthemechanismpresentedinthispaperare:
– ItfavoursaflexibleinteroperationamongagentsofheterogeneousInformationSys-
temsthat usedifferent communication protocols and therefore avoidstheneed for
prior agreement on how themessages are interchanged.
– It facilitates the customization of standard communication protocols by means of
specializedcommunicationactsthatbelongtospecificaclofInformationSystems.
Theparticular communication acts are described in an ontology.
– It provides a basis to reason about protocol relationships founded on the follow-
ing basic relations: equivalence, specialization, restriction, prefix, suffix, infix and
complement to infix. Moreover, notice that our approach allows the comparison
between protocols in terms of the intended semantics of communication acts that
appear in those protocols.
Therestofthepaperisorganizedasfollows: Section2providesbackgroundonthe
communication ontology, which contains terms corresponding to communication acts
that appear in the protocols, and on thesemantics associated to those acts. Section 3
explains how protocols are described in our proposal and introduces our algorithm
that makes a semantic analysis of protocols. Section 5 presents the formal definitions
of those relationships. In Section 6 there is a scenario where the proposed mechanism
is applied. Section 7 discusses different related works, and the conclusions appear in
thelast section.
2 Representation of the semantics of communication acts
Among thedifferent models proposed for representing protocols one which stands out
is that of State Transition Systems (STS).
Definition 1 AStateTransitionSystem isatuple(S,s0,L,T,F),whereS isafinite
set of states, s0 ∈S is the initial state, L is a finite set of labels, T ⊆S×L×S is a
set of transitions and F ⊆S is a set of final states.
In our proposal we use STSs where transitions are labeled with communication act
classes described in a communication acts ontology called CommOnt. That is to say,
the set of labels L is a set of class names taken from that ontology. CommOnt is a
OWL-DLontology,thereforeitstermdescriptionsarefoundedonaDescriptionLogic4
(DL). DLs are well designed for expressing conceptual knowledge and representing
static structural knowledge. However, protocols exhibit a dynamic aspect due to the
effectofcommunication acts.Thus,wehavedecidedtorepresenttheeffectsofactions
through predicates in theEvent Calculus.
Inanutshell,theCommOntontologydescribesstructuralandhierarchicalaspects
of communication acts and a knowledge base of Event Calculus predicates specifies
theeffectsofcommunicationacts.TermsthatappearintheEventCalculuspredicates
come from names of classes and properties in CommOnt.
Reasoningovertheeffectsofcommunicationactsisachievedthroughanencodingof
eventcalculuspredicatesandrulesintoSWRL(SemanticWebRuleLanguage).SWRL
isan extension of OWL-DLaxioms toincludeHorn-likerules. Therefore, thatencod-
ing provides an executable mechanism that integrates satisfactorily thedual semantic
representation of communication acts.
Inthe following threesubsections we present respectively themain features of the
CommOntontology,thedynamicsemanticsassociatedtocommunicationacts,andan
explanation of how these formalisms interact.
2.1 Main features of the CommOntontology
The goal of the CommOnt ontology is to facilitate the interoperation among agents
belonging to different Information Systems. The leading categories of that ontology
are: first, communication acts that are used for interaction by actors and that have
differentpurposesanddealwithdifferentkindsofcontents;andsecond,contents,which
are thesentences included in thecommunication acts.
ThemaindesigncriteriaadoptedforthecommunicationactscategoryoftheCom-
mOnt ontology is to follow the speech acts theory (Austin, 1962), a linguistic theory
thatisrecognizedastheprincipalsourceofinspirationfordesigningthemost familiar
standardagentcommunicationlanguages.Followingthattheory,everycommunication
actisthesender’sexpressionofanattitudetowardsomepossiblycomplexproposition.
A sender performs a communication act, which is expressed by a coded message, and
is directed to a receiver. Therefore, a communication act has two main components.
First, the attitude of the sender, which is called the illocutionary force (F), that ex-
pressessocialinteractionssuchasinforming,requestingorpromising.Andsecond,the
propositional content (p),whichisthesubjectoftheattitude.InCommOntthisF(p)
framework is followed, and different kindsof illocutionary forces and contents leading
to different classes of communication acts are described.
CommOnt is divided into three interrelated layers: upper, standards and appli-
cations, that group communication acts at different levels of abstraction. CommOnt
terminology is described using OWL-DL,thedescription logic profileof theWebOn-
tology Language OWL(OWL, 2008). Therefore, communication acts among agents
that commit to CommOnt have an abstract representation as individuals of classes
which are specializations of a shared universal class of communication acts.
In the upperlayer —according to Austin’s speech acts theory— five upperclasses
of communication acts corresponding to Assertives, Directives, Commissives, Expres-
sives and Declaratives are specified. In addition, the top class CommunicationAct1 is
defined, which represents the universal class of communication acts. Every particular
1 This typestylereferstotermsspecifiedintheontology.5
communication act is an individualof thisclass. In CommOnt,componentsof aclass
are represented by properties. The most important properties of CommunicationAct
arethecontentandtheactorswhosendandreceivethecommunicationact.Following
is DL axiom representing that structurecan be found:
CommunicationAct⊑=1 hasSender⊓∀hasSender.Actor⊓∀hasReceiver.Actor
⊓∀hasContent.Content
There are some other properties related to the context of a communication act
such as the conversation in which it is inserted or a link to the domain ontology that
includes the terms used in the content, but those details are out of the scope of this
paper. In addition to the principal classes Assertive, Directive, Commissive, and
Declarative, some other interesting subclasses are defined.For example:
Request⊑ Directive⊓∃hasContent.Command
Accept⊑ Declarative
Responsive⊑ Assertive⊓∃inReplyTo.Request
Inquiry⊑ Directive⊓∃hasContent.ReportAct
Astandardslayerextendstheupperlayerof theontology with specific termsthat
represent classes of communication acts of general purpose agent communication lan-
guages, like those from KQML or FIPA-ACL. Although the semantic framework of
thoseagentcommunicationlanguagesmaydifferfromthesemanticframeworkadopted
in CommOnt, in our opinion enough basic conceptsand principles are shared tosuch
an extent that a commitment to ontological relationships can be undertaken in the
context of theinteroperation of Information Systems.
With respect to FIPA-ACL, we can observe that it proposes four primitive com-
municative acts (FIPA, 2005): Confirm, Disconfirm, Inform and Request. The terms
FIPA-Confirm, FIPA-Disconfirm, FIPA-Inform and FIPA-Request are used to repre-
sent them as classes in CommOnt. Furthermore,the rest of theFIPA communicative
actsarederivedfrom thesementionedfourprimitives.Followingaresomeexamplesof
descriptions:
FIPA-Request⊑ Request
FIPA-Query-If⊑ Inquiry⊓FIPA-Request⊓=1 hasContent⊓
∀hasContent.InformIf
FIPA-Agree⊑ Accept
Analogously,communicationactsfromKQMLcanbeanalyzedandthecorrespond-
ingtermscanbespecifiedinCommOnt.Itisvitalfortheinteroperabilityaimtohave
theabilitytospecifyontologicalrelationshipsamongclassesofdifferentstandards.For
example:
KQML-Ask-If≡ FIPA-Query-If
KQML-Tell≡ FIPA-Inform
KQML-Achieve≡ FIPA-Request⊓∃hasContent.Achieve
Finally,itisoftenthecasethateveryInformationSystemusesalimitedcollection
of communication acts that constitute its particular agent communication language.
The applications layer reflects the terms describing communication acts used in such6
particular Information Systems. The applications layer of the CommOnt ontology
provides a framework for the description of the nuances of such communication acts.
Some of thesecommunication acts can bedefined as specializations of existing classes
in the standards layer and some others as specializations of upper layer classes. For
example:
A-MedicineModify≡ Request⊓=1 hasContent⊓
∀hasContent.(Overwrite ⊓∃hasSubject.Medicine)
A-MedicineModify⊑ FIPA-Request
A-VitalSignInform⊑ Responsive⊓=1 hasContent⊓
∀hasContent.(Proposition ⊓∃hasSubject.VitalSignData)⊓
=1 inReplyTo⊓∀inReplyTo.VitalSignQuery
A-VitalSignInform⊑ FIPA-Inform
Interoperation between agents of two systems using different kinds of communication
acts will proceed through theseupperand standard layer classes.
Insummary,CommOntprovidesaterminologyforcommunicationactsandformal
term relationships of equivalence and subsumption that allow to reason for interoper-
ability purposes.
2.2 Dynamicsemantics associated to communication acts
Communication actshavereceivedformalsemanticsbasedonmentalconceptssuchas
beliefs,desires andintentions.However,thatoptionhasbeencriticizedfortheapproach
(Singh,1998)aswellasonitsanalyticaldifficulties(Wooldridge,2000).Bycontrast,we
haveadoptedthesocalledsocialapproach(Singh,2000;Venkatramanand Singh,1999;
Fornara and Colombetti, 2002) to express the dynamic semantics of communication
acts described in the CommOnt ontology. According to the social approach, when
agents interact they become involved in social commitments or obligations to each
other.Those commitments arepublic,and therefore theyare suitablefor an objective
and verifiable semantics of agent interaction.
Definition 2 A base-level commitment C(x, y, p) is a ternary relation representing
a commitment made by x (the debtor) to y (the creditor) to bring about a certain
proposition p.
Sometimes an agent accepts a commitment only if a certain condition holds or,
interestingly,onlywhenacertaincommitmentismadebyanotheragent.Thisiscalled
a conditional commitment.
Definition 3 Aconditionalcommitment CC(x,y,p,q)isaquaternaryrelationrepre-
sentingthatiftheconditionp isbroughtout,x willbecommittedtoy tobringabout
theproposition q.
Moreover, theformalism we usefor reasoning about commitments is based on the
Event Calculus, which is a logic-based formalism for representing actions and their
effects. The basic ontology of the Event Calculus comprises events, fluents and time
points:events correspondtoactions inourcontext;fluents arepredicateswhosetruth
valuemaychangeovertime.Eventcalculusincludespredicatesforsayingwhathappens7
and when (Happens), for describing the initial situation (Initially),for describing the
effectsofactions(Initiates andTerminates), andforsayingwhatfluentsholdatwhat
times (HoldsAt). See(Shanahan, 1999) for more explanations.
Commitments(base-levelandconditional)canbeconsideredfluents,andsemantics
of communication acts can be expressed with predicates in theEvent Calculus.
Forexample,following therearesomepredicatesthatdescribethesemanticsasso-
ciated to the classes of communication acts Request, Accept and Responsive, which
appearintheupperlevelof CommOntandwhosedescriptionshavebeenshowninthe
previous subsection. The semantics is determined by the fluents that are initiated or
terminatedasaresultofdeliveringamessageofthatclassfrom asendertoareceiver.
The set of fluentsthat hold at a moment describe thestate of theinteraction.
– Initiates(Request(s, r, P), CC(r, s, accept(r, s, P), P), t).
ARequestfrom s tor producestheeffectofgeneratingaconditionalcommitment
expressing that if the receiver r accepts the demand, it will be commited to the
proposition P in thecontent of thecommunication act.
– Initiates(Accept(s, r, P), accept(s, r, P), t).
Thesending of an Accept produces theeffect of generating the accept fluent.
– Terminates(Responsive(s, r, P, RA),C(s, r, RA), t).
Terminates(Responsive(s, r, P, RA),CC(s, r, accept(s, r, RA), RA), t).
By sending a message of the class Responsive, the commitment (either base-level
or conditional) of the sender s towards the receiver r to bring about proposition
RA ceases to hold.
In summary, communication acts have a dual semantic representation. They are de-
scribed in CommOnt in terms of their structure and hierarchical relationships and
moreover there are some Event Calculus predicates which specify their effects.
Furthermore, some rules are needed to capture the dynamics of commitments.
Commitments are a typeof fluent,typically put in force by communication acts, that
become inoperative after the appearance of other fluents. In the following rules e(x)
represents an event caused by x. The first rule declares that when a debtor of a com-
mitment that is in force causes an eventthat initiates thecommitted proposition, the
commitment ceases to hold.
Rule 1: HoldsAt(C(x, y, p), t) ∧ Happens(e(x), t) ∧ Initiates(e(x), p, t) → Ter-
minates(e(x),C(x, y, p), t).
Thesecondruledeclaresthataconditionalcommitmentthatisinforcedisappears
and generates a base-level commitment when the announced condition is brought out
by thecreditor.
Rule 2: HoldsAt(CC(x, y, c, p), t) ∧ Happens(e(y), t) ∧ Initiates(e(y), c, t) →
Initiates(e(y),C(x, y, p), t) ∧ Terminates(e(y),CC(x, y, c, p), t).
2.3 Encoding of the interaction of thedualsemantic representation
SWRLisacombination ofOWLDLwith theUnary/BinaryDatalogRuleMLsublan-
guages of the Rule Markup Language. Therefore, CommOnt axioms can be managed
naturally.Eventcalculus predicatesand rulescanbesistematically encodedin SWRL
usingareification technique.Forexample,actionRequest(s, r, P) isencodedasanin-
dividualx in class Request and with s, r and P as valuesfor itscorresponding object8
properties:hasSender,hasReceiverandhasContent(specifiedinCommOnt).Analo-
gously,afluentaccept(r, s, P) mayberepresentedwith thefollowing assertions about
individuals: Acceptance(a), hasSignatory(a,r), hasAddressee(a,s), and hasObject(a,P).
Then, the aforementioned rules, as well as effects of the application of commu-
nication acts, can be encoded with SWRL rules. For instance, the predicate Initi-
ates(Request(s, r, P), CC(r, s, accept(r, s, P), P), t) can beencoded as follows2:
Request(x) ∧ hasSender(x,s) ∧ hasReceiver(x,r) ∧ hasContent(x,p) ∧ hasCom-
mit(x,c) ∧ isConditionedTo(c,a) → initiates(x,c) ∧ hasDebtor(c,r) ∧ hasCreditor(c,s)
∧ hascondition(c,p) ∧ Acceptance(a) ∧ hasSignatory(a,r) ∧ hasAddressee(a,s) ∧ ha-
sObject(a,p)
3 Representations of the semantics of protocols
Similarly to the representation of communication acts, presented in the previous sec-
tion, we propose a dual representation for protocols. On the one hand, we define a
structure-based representation, using OWL-DL descriptions; on the other hand, we
definea fluent-basedsemantics of protocols.
3.1 OWL-DLdescription of protocols
Asmentionedintheprevioussection,weuseSTSasmodelsforrepresentingprotocols.
Morespecifically,inthispaperwerestrictourworktodeterministicSTSwithoutcycles.
InordertorepresentthosemodelsusingOWL-DL,wehavedefinedfivedifferentclasses:
Protocol, State, Transition, Fluent and Commitment, which respectively represent
protocols, states, transitions in protocols, and fluents and commitments associated to
states.Withthesefiveclassesandsome(specialized)subclassesweareabletorepresent
enough structure in order to fully describe the components of individual instances of
our protocols.
We model those class descriptions with the following guidelines. Fluents are asso-
ciated to states where theyhold3:
∃hasFluent⊑ State ; ∃hasFluent−⊑Fluent
Transitions get out of states and every transition is labelled with the communication
act that is delivered by that event, and it is associated to the state reached by that
transition:
∃hasTransition⊑ State ; ∃hasTransition−⊑Transition
Transition≡ =1 hasCommAct⊓=1 hasNextState
∃hasCommAct⊑ Transition ; ∃hasCommAct−⊑CommunicationAct
∃hasNextState⊑ Transition ; ∃hasNextState−⊑State
2 Weareawarethat inthe humanreadablesyntax ofSWRL, variablesareprefixed witha
question mark (e.g. ?x). However, for the sake of visual clarity, the question mark has been
removedfromalltheSWRLvariablesinthispaper
3 ∃hasFluent⊑ State and∃hasFluent− ⊑Fluent mean thatthe classState andthe class
Fluentarerespectivelythedomainandrangeoftheproperty hasFluent.9
AprotocolisanindividualoftheclassProtocolanditisdeterminedbytheproperties
of its initial state, dueto our conceptual modeling of states and transitions.
Protocol≡∃hasInitialState.State
∃hasInitialState⊑Protocol ; ∃hasInitialState−⊑State
Some other interesting subclasses are specified in order to describe the elements that
compose ourprotocols:
FinalState⊑ State
Commitment⊑ Fluent⊓ =1 hasDebtor⊓∀hasDebtor.Actor⊓=1 hasCreditor⊓
∀hasCreditor.Actor⊓=1 hasCondition⊓∀hasCondition.Fluent
ConditionalCommitment⊑ Fluent⊓ =1 hasDebtor⊓∀hasDebtor.Actor⊓=1 hasCreditor⊓
∀hasCreditor.Actor⊓=1 hasCondition⊓∀hasCondition.Fluent⊓
=1 isConditionedTo⊓∀isConditionedTo.Fluent
Weareconsciousthatalternativedescriptionsmay beconsidered,butourconcep-
tual modeling is disposed to favor therule encoding of dynamic aspects of a protocol,
as will be shown in the next subsection.
3.2 Fluent-based semantics of protocols
Oneofthemostcommonapproachesforcomparingtwoprotocolsinvolvesthediscovery
of structural relationships between them. However, we believe that dealing only with
structural relationships is too rigid if a flexible interoperation among agents that use
different standard protocols is to be promoted. For that reason, we propose to obtain
an additionaldescription ofprotocols, representedbytheirfinalstates andthefluents
that hold at those final states. In order to do so, we propose to consider thefollowing
definitions.
Let WR betheset of SWRLrules encoding Rule 1 and Rule 2 presented in the
previous section. Let G and G′ be sets of fluents; and let (s,l,s′) be a transition in
a STS. Then, G : <(s,l,s′)> ⊢WR G′ is a transition derivation, which means that,
in the context of WR, if G is the set of fluents that hold at state s, when transition
(s,l,s′) happens,G′ is the set of fluentsthat hold at state s′.
Transition derivations represent the dynamics of a protocol. When a transition is
accomplished some fluents may become true, others may become false, and the rest
remain unchanged.
The encoding of G :<(s,l,s′)> ⊢WR G′ into SWRL rules is done by taking into
account our OWL-DL descriptions of STS presented in the previous subsection. Two
mainruleshavebeendefined:Ontheonehand,thefluentattachmentruleattachesto
state s′ thefluentsinitiated as a result of sending thecommunication act l:
Transition(t) ∧ hasNextState(t,s’) ∧ hasCommAct(t,l) ∧ initiates(l,f) → hasFlu-
ent(s’,f)
On the other hand, the fluent transmission rule transfers the fluents that hold in
statesandthatmustalsoholdinstates′becausetheactofsendingthecommunication
act l has noeffect on them:
hasFluent(s, f) ∧ hasTransition(s, t) ∧ hasNextState(t, s’) → hasFluent(s’, ?f)10
Definition 4 A branch of a protocol P =(S,s0,L,T,F) is a sequence of transitions
from T, <(si−1,li,si)>i=1..n, that begins in the initial state s0 and ends in a final
state sn∈ F. Wedenote Ω(P) tothe set of branches of protocol P.
LetB=<(si−1,li,si)>i=1..nbeabranch,thenG0 :B ⊢WRGnmeansthatthere
exists thesets of fluentsGi i=1..n such that Gi−1 :<(si−1,li,si)>⊢WR Gi
Definition 5 If B is a branch of protocol P(S, s0, L, T, F), G0 is the set of fluents
that hold in s0 and G0 :B ⊢WR Gn, then Gn is a protocol trace. Wedenote T(B) to
thefinal set of fluentsgenerated by B. That is to say,T(B)=Gn.
Noticethatprotocoltracesaredefinedintermsofthesemanticsofcommunication
acts, taking into account the content of the communication and not only the type of
communication. By contrast, many other related works (see section 7) consider only
communicationactsasatomicactswithoutconsideringtheircontentortheirsemantics.
From our viewpoint, the semantics of a protocol is determined by the traces of
the protocol. That is to say, from a set-theoretical approach {T(B)| B ∈Ω(P)} is an
interpretation of protocol P.
4 Algorithm
Inthissectionwepresentthemainstepsofthealgorithmthatcomparestwoprotocols.
As the semantics of the protocol is determined by ist traces, in order to perform the
comparisonweneedtodealwiththebrachesoftheprotocol.Thealgorithm comprises
threemain steps:
1. Separation of each protocol into branches: each protocol is separated into all the
branchesthat can be generated from the initial state to a finalstate.
2. Generation of protocol traces: theprotocol traces corresponding toeach branch of
each protocol are calculated.
3. Pairing up branches: the branches of one of the protocols are compared to the
branchesof the otherprotocol.
Moreover, once the previous steps have been concluded, several relationships be-
tween both protocols can be established from a global point of view.
Nowwe will develop these steps more thoroughly.
4.1 Separation of the protocol intobranches
In the first step, theprotocol is separated into all the branches that can begenerated
from the initial state to a finalstate.
Algorithm 3.3.1 (see Fig. 1) shows how to do that. In line 2, a global vector
(branches) is created, which will be used to store the different branches of a pro-
tocolPaftertheyhavebeencalculated.Inline3anothervector(partialBranches) is
created. Thisvectorwill beused asan auxiliary tostorethepartial branchesthatare
generatedintheprocessofcalculatingthecompletebranches.Thisvectorisinitialized,
inline4,withapartialbranchthatcontainsonlytheinitialstateoftheprotocol(s0).
Taking into account the transitions of protocol P, this partial branch is repeatedly
modified by adding new states to it (lines 5 to 13). Moreover, once one of the partial11
Fig. 1 Algorithm:Generationofbranches
Fig. 2 Separationofbranches
Fig. 3 Protocol diagram
branches is completed (i.e. a final state has been reached), it is added to the global
vectorbranches(lines12-13),whichwillbereturnedonceallthepartialbrancheshave
been completed. An examplecan be found in Fig. 2.
4.2 Generation of protocol traces
Given a branch B, with a simulation of its corresponding G0 :B ⊢WR Gn, the corre-
spondingtraceT(B)iscalculated.DuringthatsimulationtheSWRLrulesthatencode
thesemantics ofthecommunication acts (seesection 3.2) appearingin thebranchare
applied. Then, the set of fluents that hold at the final state of each branch is the
corresponding trace. That set represents theeffects of theprotocol branch.
Forexample,let ustakeprotocolAskTimein Fig.3.Byusingthisprotocol, agent
A intends to get from agent B information about the time. So, in the first transition,
agent A requests about the time. Then, agent B sends a message accepting to give
theinformation about thetime, and finally, in the third transition, agent B sends the12
Fig. 4 Protocol fluents
requested information. The descriptions in the CommOnt ontology of the communi-
cation acts that appear in theprotocol AskTime are thefollowing:
TimeRequest≡ Request⊓=1 hasContent⊓∀hasContent.TimeReq
TimeAccept≡ Accept⊓=1 hasContent⊓∀hasContent.TimeReq
TimeInform≡ Responsive⊓=1 hasContent⊓∀hasContent.TimeInfo⊓=1 inReplyTo⊓
∀inReplyTo.TimeRequest
In Fig. 4 we show which fluents are associated to the states of the protocol and
howtheyvaryasaconsequenceofthecommunication actsthataresentandtherules
described in section 3.2. We depart from a situation where the set of fluents is empty
(F0). The impact the communication acts of the protocol have over the set of fluents
that hold at each moment is explained next:
TimeRequest: A→B
WhentheTimeRequestmessageissent,theconditionalcommitmentCC1isinitiated
(F1), which states that if agent B accepts to give information about the time, then
it will be committed to do so. This happens because according to the definitions in
the CommOnt ontology, TimeRequest is a subclass of Request, and as a result, the
absatract predicate Initiates(Request(s, r, P), CC(r, s, accept(r,s,P), P), t) can be
applied.Moreprecisely,inthiscasethepredicateisinstanciatedasInitiates(Request(A,
B, TimeReq), CC(B, A, accept(B,A,TimeReq), TimeReq), t1). The following SWRL
rule, which encodes theabstract predicate, can beexecuted at this moment:
Request(x) ∧ hasSender(x,s) ∧ hasReceiver(x,r) ∧ hasContent(x,p) ∧ hasCom-
mit(x,c) ∧ isConditionedTo(c,a) → initiates(x,c) ∧ hasDebtor(c,r) ∧ hasCreditor(c,s)
∧ hascondition(c,p) ∧ Acceptance(a) ∧ hasSignatory(a,r) ∧ hasAddressee(a,s) ∧ ha-
sObject(a,p)
ThisruleinitiatestheaforementionedconditionalcommitmentCC1,andduetothe
fluent attatchment rule (section 3.2, CC1 is attached to state S1, and thus it holds in
F1.
TimeAccept: B→A
Then, agent B agrees to respond by sending the TimeAccept message. Due to the
predicateInitiates(Accept(s,r,P), accept(s,r,P), t) —instanciated inthiscaseasIniti-
ates(Accept(B,A,TimeReq), accept(B,A,TimeReq), t2)—andthefactthatTimeAccept
is a subclass of Accept, therule13
Accept(x)∧hasSender(x,s)∧hasReceiver(x,r)∧hasContent(x,p)∧hasCommit(x,c)
→ initiates(x,c) ∧ Acceptance(c) ∧ hasSignatory(c,s) ∧ hasAddressee(c,r) ∧ hasOb-
ject(a,p)
isexecutedandconsequently,thefluentaccept(B, A,TimeReq)isinitiated.Atthis
point, Rule 2 (see section 3.2) can be applied because accept(B,A,TimeReq) is the
conditionoftheconditionalcommitmentCC1.Asaconsequence,CC1isterminatedand
thebasecommitmentC1isinitiatedandattachedtostateS2duetotheaforementioned
fluent attachment rule. We would like to remark that, since SWRLdoes not offer any
primitivefor retraction, thedeletion of thefluentCC1 is performed using themethods
of the OWL-API(?)that allow the manipulation of the ABox.
TimeInform: B→A
Finally, agent B sends the TimeInform message. As TimeInform is a subclass of
Responsive and because of the predicate Initiates(Responsive(s,r,P, RA), P, t), —
instanciated as Initiates(Responsive(B,A,TimeInfo, TimeReq), TimeInfo, t4)— the
fluent TimeInfo, is initiated. Moreover, C1 is terminated due to the predicate Termi-
nates(Responsive(s,r,P, RA),C(s,r,RA),t),instanciatedasTerminates(Responsive(B,
A, TimeInfo, TimeReq), C(B,A,TimeReq), t4). In our environment, these predicates
havebeen encoded with therule:
Responsive(x) ∧ hasContent(x,p) ∧ inReplyTo(x,irt) ∧ initiates(irt, f) → termi-
nates(x,f) ∧ initiates(x, p)
In addition, due to the fluent transmission rule, the fluent accept(B, A, TimeReq)
is transferred from state S2 to state S3. So, at this point (F3) we can say that the
fluentsthatholdatthefinalstateoftheprotocolare(accept(B, A, TimeReq),t2)and
(TimeInfo,t4)andso,theprotocoltrace[(accept(B, A,TimeReq),t2),(TimeInfo,t4)]
isgenerated forthebranch.Asouralgorithmdoesnotmakeuseofthetime parameter,
it will beomitted in thefollowing analysis.
4.3 Pairing up branchesfrom two different protocols
Once protocol traces have been generated, it is necessary to establish relationships
betweenbranchesofthetwoprotocolsP1andP2beingcompared.Inordertocompare
two branches, we compare their protocol traces, and thus, their fluents. To do so, the
algorithmfirstevaluatesthecartesianproductofbranchesΩ(P1)×Ω(P2),takinginto
account thefollowing considerations:
GivenB1∈Ω(P1)andB2∈Ω(P2),fourseparatecasesmayoccurwhencompar-
ing two fluentst1 ∈T(B1) and t2 ∈ T(B2) :
(eq) t1 and t2 are equivalent: msc(t1) ≡ msc(t2), being msc(t) the most specific con-
ceptofafluenttinregardtoanontologyoffluents.Inthiscasewecouldseethose
fluentsas clones, their names being their sole difference.
(g1) t1is more general than t2: msc(t2) ⊑ msc(t1) and msc(t2) 6≡ msc(t1).
(g2) t2is more general than t1: msc(t1) ⊑ msc(t2) and msc(t1) 6≡ msc(t2).
(in) t1 and t2 are incomparable: msc(t1) 6⊑ msc(t2) and msc(t2) 6⊑ msc(t1) (They
havenorelationship to each other).14
ItmayhappenthatafluentexistsinT(B1)whichisincomparable withanyfluent
inT(B2),andafluentinT(B2)whichisincomparable withanyfluentinT(B1);then,
wesaythatthepairingupofB1andB2isnotfeasible.ThismeansthatB1generates
some fluent that is not generated by B2 and viceversa.
Definition 6 (B1,B2)∈Ω(P1)×Ω(P2)isafeasible pair iff [∀t1∈B1.∃t2∈B2.t1
and t2 satisfy (eq),(g1) or (g2)] ∨ [∀t2∈B2. ∃t1∈B1. t1 and t2 satisfy (eq),(g1) or
(g2)]
We are not interested in unfeasible pairs of branches because, as will be shown in
section 5, the relationships we are interested in are those where all the fluents in at
least oneof thetraces must be related to some fluent in theother.
Each feasible pair (Bi,Bj) ∈ Ω(P1)×Ω(P2) receives a 4-place tuple valuation
ij ij ij ij
(x ,x ,x ,x ) where:
0 1 2 3
– xij is the numberof pairs of fluentsthat fulfill case (eq).
0
– xij is the numberof pairs of fluentsthat fulfill case (g1).
1
– xij is the numberof pairs of fluentsthat fulfill case (g2).
2
– xij is the exceeding number of fluents: xij =|#T(B1)−#T(B2)|, where #T(B1)
3 3
and #T(B2) are thenumberof fluentsof T(B1) and T(B2) respectively.
Then,asimilaritymetricisdefinedbymeansofthefollowingfunction,whichyields
a valuein [0,1] for every 4-place tuple:
f(x0,x1,x2,x3)=
x0+m 3ax(x1,x2)
Pi=0xi
Theintuitionbehindthisformulaisthatagreatervaluerepresentsmoresimilarity.
Ourinterestistorelateasmanyfluentsaspossiblewithinapairofbranches,regardless
ofwhethertheirrelationship isof equivalenceorsubsumption(thatiswhyx0 isgiven
3
the same weight as max(x1,x2) in the formula). Division by Pi=0xi assures the
function valuedoesn’t go beyond1.
Definition 7 A matching π is a subset of feasible pairs from Ω(P1)×Ω(P2) such
thateverybranchfrom thesmallest setofΩ(P1),Ω(P2)ispairedup,andanybranch
is paired up with at most another branch.(π is the graph of an injective map.)
Ouraimistoobtainthematchingthatmaximizesthesumofthesimilaritymetric
applied to thevaluation of its pairs. Formally, we look for the matching π that
ij ij ij ij
maximizes X f(x 0,x 1,x 2,x 3)
(Bi,Bj)∈π
Inthecasethatthereexisttwoormorematchingsπk(k∈1...n)thatmaximizethe
sumabove,wepriorizetheequivalencerelationshipsbetweenfluentsoversubsumption
relationships. Then, the best matching is anyone of the set {πk : (k ∈ 1...n)} such
that
maximizes X
g(xi 0j ,xi 1j ,xi 2j ,xi 3j
), with g(x0,x1,x2,x3)=
3x0
(Bi,Bj)∈πk
Pi=0xi
InFig. 5we present an exampleof theprocess of pairing upbranches. Ontheone
hand, in protocol P1 agent A requests and later receives information about the time15
Fig. 5 Pairingupbranches ofdifferentprotocols
(branch1.1)oraboutthetemperature(branch1.2).Threetransitionsarenecessaryin
eachofthebranchestoreachthefinalstateoftheprotocol.Ontheotherhandprotocol
P2 is composed of three branches: Branch 2.1 has the same semantics as branch 1.2
but in this case only two transitions are needed, since with the TempAccept&Inform
communication act, agent B both accepts and responds to therequest. In branch 2.2,
agent A requests for information about the date and the time and gets the respective
responses (two transitions for each of the parameters). Finally, information about the
time is requested in branch 2.3, also in two steps. The table in Fig. 5 registers the
valuationandsimilarity metricvalueofthefeasible pairsfrom Ω(P1)×Ω(P2).When
a pair is not feasible we represent it with an X in thecorresponding cell.
5 Protocol relationships
Once the algorithm described in the previous section has finished the analysis of
branchesof protocols, thenext step consists on discovering thesemanticrelationships
between those protocols. This section presents thecollection of semantic relationships
we are considering. Firstly, we present the definitions of relationships between two
protocol branches, followed by thedefinitions of relationships between protocols.16
5.1 Relationships between branches
Let A,B betwo protocol branches,and T(A),T(B) betheprotocol traces generated
by branchesA and B respectively.
Definition 8 BranchAisaequivalent tobranchB (A=bB)ifthereexistsabijective
function φ:T(A)→T(B) such that ∀t∈T(A).msc(t)≡msc(φ(t)).
Definition 9 Branch A is a specialization of branch B (A≪bB) if there exists a bi-
jective function φ:T(A)→T(B) such that ∀t∈T(A).msc(t)⊑msc(φ(t)).
We denote Prune[B/sk] to the branch that results from pruning branch B from
state sk onwards. Given a branch B =< (si−1,li,si) >i=1..n, and 1 ≤ k ≤ n,
Prune[B/sk]= <(si−1,li,si)>i=1..k.
Definition 10 Branch A is a prefix of branch B (A=preB) if there exists a state sk
in B such that A=bPrune[B/sk].
BranchAisaspecialized-prefix ofbranchB (A≪preB)ifthereexistsastatesk in
B such that A≪bPrune[B/sk].
Letsk(1≤k<n)astateinthedefinitionofbranchB.WedenoteChangeInit[B/sk]
to the new branch that results from modifying the definition of branch B in such a
way that sk becomes the initial state of the new branch: ChangeInit[B/sk]=<(si−1,
li,si)>i=k+1..n
Definition 11 Branch A is a suffix of branch B (A=sufB) if there exists a state sk
in B such that A=bChangeInit[B/sk].
BranchAisaspecialized-suffix ofbranchB (A≪sufB)ifthereexistsastatesk in
B such that A≪bChangeInit[B/sk].
Definition 12 Branch A is an infix of branch B (A=infB) if there exists a state sk
in B such that A=preChangeInit[B/sk] (i.e. A is a prefix of a suffix of B).
Branch A is an specialized-infix of branch B (A≪infB) if there exists a state sk
in B such that A≪preChangeInit[B/sk].
Definition 13 BranchAisancomplement to infix ofbranchB (A=cB)ifthereexists
a state sk in A such that Prune[A/sk]=preB and ChangeInit[A/sk]=sufB.
BranchAisanspecialized-complement to infix ofbranchB (A≪cB)ifthereexists
a state sk in A such that Prune[A/sk]≪preB and ChangeInit[A/sk]≪sufB.
Takingintoaccountthepreviousdefinitionswehavedevelopedareasoningservice
thatdecidesifabranchisaprefix,asuffix,aninfixoracomplement to infixofanother
branch,either in an equivalent or specialization sense.
5.2 Relationships between protocols
Protocols are constituted by branches, and therefore we use the definitions in the
previous subsection to definetherelationships between protocols.
Definition 14 ProtocolP isequivalent toprotocolQ(P[E]Q)ifthereexistsabijective
function φ:Ω(P)→Ω(Q) such that ∀A∈Ω(P).A=bφ(A).17
Definition 15 Protocol P is a specialization of protocol Q (P[Z]Q) if there exists a
bijective function φ:Ω(P)→Ω(Q) such that ∀A∈Ω(P).A≪b φ(A).
Sometimes, a protocol is defined by restrictions on the allowable communication
acts at some states of a general protocol. In those situations the application of those
restrictions is reflected in the corresponding effects.
Definition 16 Let Ω′(Q) a proper subset of Ω(Q) (Ω′(Q)⊂Ω(Q)). Protocol P is a
restriction ofprotocolQ(P[R]Q)ifthereexistsabijectivefunctionφ:Ω(P)→Ω′(Q)
such that ∀A∈Ω(P).A=bφ(A).
Definition 17 Protocol P isaprefix ofprotocol Q(P[P]Q)ifthereexistsabijective
function φ:Ω(P)→Ω(Q) such that ∀A∈Ω(P).A=preφ(A).
Definition 18 Protocol P isa suffix ofprotocol Q (P[S]Q)if thereexists abijective
function φ:Ω(P)→Ω(Q) such that ∀A∈Ω(P).A=sufφ(A).
Definition 19 Protocol P is aninfix ofprotocol Q(P[I]Q) ifthereexistsabijective
function φ:Ω(P)→Ω(Q) such that ∀A∈Ω(P).A=infφ(A).
Definition 20 Protocol P is a complement to infix of protocol Q (P[C]Q) if there
exists a bijective function φ:Ω(P)→Ω(Q) such that ∀A∈Ω(P).A=cφ(A).
We denote the composition of relations by sequencing the names of the relations.
For instance, the relationship P[ZRP]Q means that protocol P is a specialization of
a restriction of a prefix of protocol Q.
Following, wepresentfirst alist of relevantproperties regarding thepreviousrela-
tionships and then some proofs of those properties.
5.2.1 Properties of the protocol relationships
Let P and Q be two protocols. Then,the following properties can be highlighted:
1. P,S,I, C, Z and E are reflexive.
2. Ris irreflexive.
3. P,S,I, C, Z, E and Rare transitive.
4. ∀X ∈{P,S,I,C,E,Z}. [XR]=[RX].
5. ∀X ∈{P,S,I,C}. ∀Y ∈{E,Z}. [YX]⇒[XY] but [XY];[YX].
6. ∀X ∈{P,S,I}. ∀Y ∈{P,S,I}. (X =6 Y → (P[XY]Q⇔ P[I]Q)).
5.2.2 Proofs
Next,weprovideproofs forsome ofthepropertieslisted above.Remaining proofs can
be figured out accordingly.
Property 1 : P, S,I, C, Z and E are reflexive.
– P is reflexive.
Proof: We need to provethat P[P]P.
Itsufficestodefineφastheidentityfunction,andobviously,∀A∈Ω(P).A=pre A,
because A=bPrune[A/sn], where sn is thefinal state of A.18
– Z is reflexive.
Proof: We need to provethat P[Z]P.
It suffices to define φ as the identity function, and obviously ∀A ∈ Ω(P), A ≪b
A, because for the identity function id : T(A) → T(A), ∀t ∈ T(A). msc(t) ⊑
msc(id(t)).
Property 2 : R is irreflexive.
– Proof: We need to prove that P[R]P is false. The set Ω(P) is finite, therefore it
is impossible to definea bijective function from Ω(P) to a proper subset Ω′(P)⊂
Ω(P).
Property 3 : P, S,I, C, Z, E and R are transitive.
– Z is transitive.
Proof: We need to provethat P[ZZ]Q ⇒ P[Z]Q.
P[ZZ]Q means that there exists a protocol M such that P[Z]M and M[Z]Q.
Looking at the definition of Z, M[Z]Q means that there exists a bijective func-
tion φ : Ω(M) → Ω(Q) such that ∀A ∈ Ω(M). A ≪b φ(A). Moreover, P[Z]M
means that there exists a bijective function φ′ : Ω(P) → Ω(M) such that ∀A ∈
Ω(P).A≪b φ′(A).Then,thebijectivefunctionφ◦φ′ :Ω(P)→Ω(Q)satisfiesthe
neededpropertiessince∀A∈Ω(P)A≪bφ′(A)≪bφ◦φ′(A)and≪b istransitive.
– P is transitive.
Proof: We need to provethat P[PP]Q ⇒ P[P]Q.
P[PP]Q means that there exists a protocol M such that P[P]M and M[P]Q.
LookingatthedefinitionofP,M[P]Qmeansthatthereexistsabijectivefunction
φ:Ω(M)→ Ω(Q) such that ∀A∈Ω(M). ∃sqi ∈Q. A=bPrune[φ(A)/sqi]. More-
over, P[P]M means that there exists a bijective function φ′ :Ω(P)→Ω(M) such
that ∀B ∈Ω(P). ∃smi ∈M. B=bPrune[φ′(B)/smi]. We ask for a small abuse of
notation,denotingφ(smi)tothestateinQcorrespondingtosmi afterapplyingφ
to branch φ′(B). Then, the bijective function φ◦φ′ : Ω(P) → Ω(Q) is such that
∀B∈Ω(P).∃φ(smi)∈Q. B=bPrune[φ◦φ′(B)/φ(smi)].
– Ris transitive.
Proof: We need to provethat P[RR]Q ⇒ P[R]Q.
P[RR]Q means that there exists a protocol M such that P[R]M and M[R]Q.
Looking at the definition of R, M[R]Q means that there exists a bijective func-
tion φ : Ω(M) → Ω′(Q) such that ∀A ∈ Ω(M). A =b φ(A). Moreover, P[R]M
means that there exists a bijective function φ′ : Ω(P) → Ω′(M) such that ∀B ∈
Ω(P) B =b φ′(B). Then, the bijective function φ◦φ′ : Ω(P) → Ω′′(Q) ⊂ Ω(Q),
whereΩ′′(Q)=φ◦φ′(Ω(P))=φ(Ω′(M)),issuchthat∀A∈Ω(P).A=bφ◦φ′(A).
Property 4 : ∀X ∈{P,S,I,C,E,Z}. [XR]=[RX].
– [PR]=[RP].
Proof: First, we proveP[PR]Q ⇒ P[RP]Q.
Because of P[PR]Q, there exists a protocol M such that P[P]M and M[R]Q.
According to definitions of P and R, ∃φ : Ω(P) → Ω(M) bijective, such that
∀A ∈ Ω(P). A =pre φ(A) and ∃φ′ : Ω(M) → Ω′(Q) ⊂ Ω(Q) bijective, such that
∀A∈Ω(M).A=b φ′(A).19
We must prove that there exists a protocol M′ such that P[R]M′ and M′[P]Q.
Let usdefineΩ(M) as theset of branchesof protocol Q that donot havea corre-
spondingbranchinM (Ω(M)=Ω(Q)−Ω′(Q),noticethatΩ(M)6=∅).Then,M′
is a protocol with Ω(M′)=Ω(P)∪Ω(M).
In orderto proveM′[P]Q we definethebijective function ψ:Ω(M′)→Ω(Q)
– if A∈Ω(P) then ψ(A)=φ′(φ(A)).
– if A∈/ Ω(P) then ψ(A)=A.
Then, ∀A∈Ω(M′). A=pre ψ(A), since A=pre φ(A)=b φ′(φ(A)) implies A=pre
φ′(φ(A)).
To prove P[R]M′, we use the identity function id : Ω(P) → Ω(P) ⊂ Ω(M′) so
that ∀A∈Ω(P).A=b id(A).
Second,we proveP[RP]Q ⇒ P[PR]Q.
Because of P[RP]Q, there exists a protocol M such that P[R]M and M[P]Q.
According to definitions of R and P, ∃φ′ : Ω(P) → Ω′(M) ⊂ Ω(M) bijective,
such that ∀A ∈ Ω(P). A =b φ′(A) and ∃φ : Ω(M) → Ω(Q) bijective, such that
∀A∈Ω(M).A=pre φ(A).
Wemust provethat thereexists a protocol M′ such that P[P]M′ and M′[R]Q.
We build a protocol M′ in such a way that Ω(M′) = {φ(φ′(A)) ∈ Ω(Q) | A ∈
Ω(P)}. In order to prove P[P]M′, we define the function ψ : Ω(P) → Ω(M′)
such that ψ(A)=φ(φ′(A). Then, ψ is bijective and ∀A∈Ω(P). A=b φ′(A)=pre
φ(φ′(A),and consequently A=pre ψ(A).
Moreover, the identity function id : Ω(M′) → Ω(M′) ⊂ Ω(Q) is bijective and
satisfies the condition for M′[R]Q, by construction of Ω(M′).
– [ZR]=[RZ].
Proof: First, we proveP[ZR]Q ⇒ P[RZ]Q.
Because of P[ZR]Q, there exists a protocol M such that P[Z]M and M[R]Q.
According to definitions of Z and R, ∃φ : Ω(P) → Ω(M) bijective, such that
∀A ∈ Ω(P). A ≪b φ(A) and ∃φ′ : Ω(M) → Ω′(Q) ⊂ Ω(Q) bijective, such that
∀A∈Ω(M).A=b φ′(A).
Wemust provethat thereexists a protocol M′ such that P[R]M′ and M′[Z]Q.
Let us define Ω(M) as the set of branches of protocol Q that do not have a cor-
responding branch in M (Ω(M) = Ω(Q)−Ω′(Q)). Then, M′ is a protocol with
Ω(M′)=Ω(P)∪Ω(M).
In orderto proveM′[Z]Q we definethebijective function ψ:Ω(M′)→Ω(Q)
– if A∈Ω(P) then ψ(A)=φ′(φ(A)).
– if A∈/ Ω(P) then ψ(A)=A.
Then, ∀A ∈ Ω(M′). A ≪b ψ(A), since A ≪b φ(A) =b φ′(φ(A)) implies A ≪b
φ′(φ(A)).
Moreover, P[R]M′ because the identity function id : Ω(P) → Ω(P) ⊂ Ω(M′) is
bijective and satisfies theneeded properties, by construction of Ω(M′).
Second,we proveP[RZ]Q ⇒ P[ZR]Q.
Because of P[RZ]Q, there exists a protocol M such that P[R]M and M[Z]Q.
According to definitions of R and Z, ∃φ : Ω(P) → Ω′(M) ⊂ Ω(M) bijective,
such that ∀A ∈ Ω(P). A =b φ(A) and ∃φ′ : Ω(M) → Ω(Q) bijective, such that
∀A∈Ω(M).A≪b φ′(A).
Wemust provethat thereexists a protocol M′ such that P[Z]M′ and M′[R]Q.20
Fig. 6 Counter-example: PZ;ZP
Then we build a protocol M′ with the branches of Q that have a corresponding
branch in Ω(M) dueto φ′ (Ω(M′)=φ′(Ω′(M))).
InordertoproveP[Z]M′ wedefinethebijectivefunctionψ:Ω(P)→Ω(M′)with
ψ(A) = φ′(φ(A)). Then, ∀A ∈ Ω(P). A ≪b ψ(A), since A =b φ(A) ≪b φ′(φ(A))
implies A≪b φ′(φ(A)).
Finally, M′[R]Q because the identity function id : Ω(M′) → Ω(M′) ⊂ Ω(Q) is
bijective and satisfies theneeded properties, by construction of Ω(M′).
Property 5 : ∀X ∈{P,S,I,C}. ∀Y ∈{E,Z}. [YX]⇒[XY] but [XY];[YX].
– P[ZP]Q ⇒ P[PZ]Q.
Proof:BecauseofP[ZP]Q,thereexistsaprotocolM suchthatP[Z]M andM[P]Q.
According to the definitions of Z and P, ∃φ : Ω(P) → Ω(M) bijective, such
that ∀A ∈ Ω(P). A ≪b φ(A) and ∃φ′ : Ω(M) → Ω(Q) bijective, such that
∀B ∈ Ω(M). B =pre φ′(B), which implies that ∀B ∈ Ω(M). ∃s φ′(B). B =b
Prune[φ′(B)/s φ′(B)] and exists Suff(φ′(B))=ChangeInit[φ′(B)|s φ′(B)] (In other
words, each branch of Q can be seen as a concatenation of two subbranches:
B·Suff(φ′(B))).Let usdefineΩ(M)={Suff(φ′(B))|B∈Ω(M)}.
Wemust provethat thereexists a protocol M′ such that P[P]M′ and M′[Z]Q.
ThenwebuildaprotocolM′withthebranchesformedbytheconcatenationofeach
branch in Ω(P) with its corresponding branch in Ω(M) (Ω(M′) = {A·Suff(φ′◦
φ(A))|A∈Ω(P)}).
InordertoproveP[P]M′ wedefinethebijectivefunctionψ:Ω(P)→Ω(M′)with
ψ(A)=A·Suff(φ′◦φ(A)),which satisfies A=pre ψ(A)by construction.
In order to prove M′[Z]Q, notice that every B ∈ Ω(M′) is of the form A ·
Suff(φ′ ◦ φ(A)) for some A ∈ Ω(P); then we define the bijective function ψ :
Ω(M′)→Ω(Q)withψ(A·Suff(φ′◦φ(A)))=φ(A)·Suff(φ′◦φ(A)),whichsatisfies
A·Suff(φ′◦φ(A))≪bφ(A)·Suff(φ′◦φ(A)) bydefinition of φ.
– P[PZ]Q ; P[ZP]Q.
Weshow a counter-example.
Because of P[PZ]Q, there exists a protocol M such that P[P]M and M[Z]Q.
Looking at Fig. 6, let us suppose that msc(fbb)⊑msc(fb), msc(faa)⊑msc(fa)
and no other relationship exists between fluents, so Q′ in the picture fulfills the
requirements.
We must prove that there does not exist a protocol M′ such that P[Z]M′ and
M′[P]Q.NoticethatanyprotocolM′ suchthatM′[P]Q,shouldsatisfyM′[E]Qor
M′[E]Q′; butit is obvious that not P[Z]Q neither P[Z]Q′.
Property 6 : ∀X ∈{P,S,I}. ∀Y ∈{P,S,I}. (X =6 Y → (P[XY]Q⇔ P[I]Q)).21
– P[PS]Q ⇔ P[I]Q. (A prefixof a suffix is an infix,and viceversa).
Proof: First we prove[PS]⇒[I].
Because of P[PS]Q, there exists a protocol M such that P[P]M and M[S]Q.
According to the definitions of P and S, ∃φ : Ω(P) → Ω(M) bijective, such
that ∀A ∈ Ω(P). A =pre φ(A) and ∃φ′ : Ω(M) → Ω(Q) bijective, such that
∀B∈Ω(M). B=suf φ′(B).
Then, the bijective function ψ : Ω(P) → Ω(Q) with ψ(A) = φ′(φ(A)) satisfies
A =inf ψ(A), since ∀A ∈ Ω(P). A =pre φ(A) =suf φ′(φ(A)), and due to def-
inition of =suf, there exists a state sa in φ′(φ(A)) such that A =pre φ(A) =b
ChangeInit[φ′(φ(A))/sa],whichimpliesthatA=preChangeInit[φ′(φ(A))/sa],which
is thedefinition for P[I]Q.
Nextwe prove[I]⇒[PS].
Because of P[I]Q, ∃φ : Ω(P) → Ω(Q) bijective, such that ∀A ∈ Ω(P). A =inf
φ(A), which means that ∀A ∈ Ω(P) there exists a state s in φ(A) such that
φ(A)
A=preChangeInit[φ(A)/s φ(A)]=suf φ(A).Wemustprovethatthereexistsaproto-
colM suchthatP[P]M andM[S]Q.WedefineΩ(M)={ChangeInit[φ(A)/s ]|
φ(A)
A∈Ω(P)}.Then,thefunctionsψ:Ω(P)→Ω(M)withψ(A)=ChangeInit[φ(A)/s ]
φ(A)
andψ′:Ω(M)→Ω(Q)withψ′(ChangeInit[φ(A)/s ])=φ(A)arebijectiveand
φ(A)
justify P[P]M and M[S]Q.
To conclude this section, we want to point out that our implemented mechanism
discovers complex composition relationships, like those presented in this section, be-
tween two given protocols. The following section presents an example.
6 One scenario of the proposed mechanism at work
The aim of this section is to show one scenario that illustrates the different steps
thattheproposedmechanismfollowsinordertodiscovertherelationshipbetweentwo
different protocols that could be activated in case of a road accident. In both cases,
theactorsthatinteractareanursefromtheambulancethatcoverstheemergencyand
a doctor from the emergency staff from a hospital. Those actors are represented by
softwareagentsthatbelongtodifferentInformationSystems.Noticethatthoseagents
useprotocols constituted bycommunication actsthat arespecifictoeach Information
System,andwhichareaspecialization ofgeneralcommunicationactclassesdefinedin
theupperlevel of theCommOntontology.
On the one hand, protocol P1 in Fig. 7 illustrates the interaction with a public
hospital.Theprotocolisinitiatedbyanursefromtheambulance,whosendsarequest
(IdentifiedHelpReq) for help identifying herself within the message. Depending on
the situation, the hospital staff can either reject (HelpReject) or accept the request
and ask information about the accident (HelpAcceptance). In the latter case, then
the nurse requests a helicopter to take the injured to the hospital (HelicopterReq)
and sends a message with the information about the accident (AccidentInform). Fi-
nally, the hospital staff responds whether it is possible or not to send a helicoper
(HelicopterInform).
Ontheotherhand,protocolP2showstheinteractionwithaprivatehospital,where
patients are required to have an insurance policy. In the first step, the nurse sends a
requestforhelp(HelpReq)followed byamessageofself-identification(Identify).The
hospitalstaffmayeitherrejecttherequest(HelpRefusal)oracceptit(InsuranceReq),22
Fig. 7 Onescenariooftheproposedmechanism.
inwhichcasethenurseinformsaboutthepatient’sinsurancedetails(InsuranceInform).
Aftercheckingthosedetails,thehospitalstaffdecideswhetherthepatientiseligiblefor
help (HelpAgreement) or not (HelpRefusal). In the former case, then thenurse sends
amessage inwhichshegivesinformation about theaccidentandrequestsahelicopter
(AccidentManagement). Finally, the hospital staff responds whether it is possible or
not tosend a helicoper (HelicopterResponse).
It can be noticed that both protocols are quite different. In Fig. 8 the description
andexplanationsofthecommunicationactsthatappearintheprotocolsareprovided.
Inthefollowing, thedifferentstepspresentedintheprevioussections(4.1,4.2and
4.3) are illustrated for thescenario underconsideration.
Separation intobranches:TherearetwodifferentbranchesinprotocolP1andthree
differentbranchesinprotocolP2.Forbrevity,werepresentabranchwiththesequence
of its states. Then, protocol P1 is separated into the branches B1.1=[A,B,C] and
B1.2=[A,B,D,E,F,G]andprotocolP2intoB2.1=[A,B,C,D],B2.2=[A,B,C,E,F,G] and
B2.3=[A,B,C,E,F,H,I,J].
Generation of fluents: In Fig. 9 the fluents generated by each branch are shown.
ThefluentsgeneratedbyprotocolP1andtheinstancesofcommunicationactsinthat
protocol are prefixed by u (public), while the ones generated by protocol P2 are pre-
fixedbyr (private).Belowadetaileddescriptionofthegenerationprocessofthefluents
in branch B1.1 is provided. The generation process of the remaining branches can be
found in appendix A.
Branch B1.1
<A,IdentifiedHelpReq,B>: Nursen sends themessage uIdentifiedHelpReq
Duetothe following knowledge:23
Fig. 8 Descriptionofthecommunicationacts
Fig. 9 Fluents generatedbythebranches24
Fig. 10 Fluentcomparisontable
uIdentifiedHelpReq∈IdentifiedHelpReq
IdentifiedHelpReq⊑Request
IdentifiedHelpReq⊑Inform⊑Assertive
Initiates(Request(s,r,P),CC(r, s,accept(r,s,P),P), t)
Initiates(Assertive(s,r,P), P, t)
fluentsu01.1 and u02.1 are generated.
<B,HelpReject,C >:Hospital h sendsthemessage uHelpReject.
Duetothe following knowledge:
uHelpReject∈HelpReject
HelpReject⊑Reject
Initiates(Reject(s,r,P), Rejection(s,r,P), t)
fluentu03.1 is generated.
Comparison of branches:Forthesakeoftheexample,wehavere-labelled thegen-
erated fluents with a code in the format pX.Y, where p ∈ {u,r} refers to the protocol
that generates thefluent,X ∈{01,...,n} is a key numberfor identifyingfluentsand Y
∈ {1,2,3} is a number for distinguising fluents from diferent branches. Notice that in
ourcoding, numberX identifiesafluent,thatistosayr02.1 isthesameindividualas
u02.1, theirstringlabels isthesole difference.Takingthepreviousconsiderations into
account, thebranches comparison table displays theresults in Fig. 10.
Remember that the tuple (4,0,0,1) indicates that four fluents in the trace of B2.3
andfourfluentsinthetraceofB1.2canbepairedupthroughanequivalencerelation-
ship, noone fluentcan be paired up through a specialization relationship and thereis
one exceeding fluent (due to the fact that the trace of B2.3 has five fluents and the
trace of B1.2 has only four fluents).
Moreover, there are four infeasible pairs (B1.2, B2.1), (B1.1, B2.2), (B1.2, B2.2)
and (B1.1, B2.3). For example, (B1.1, B2.2) is not feasible because in the trace of
B1.1 thereare some fluents(u01.1 andu03.1) which donot hold in thetraceof B2.2,
and in turn, in trace of B2.2 there are other fluents (r10.2 and r11.2) which do not
hold in trace of B1.1.
The best pairing can be obtained pairing up branch B1.1 with branch B2.1 and
branch B1.2 with B2.3 (π = {(B1.1,B2.1),(B1.2,B2.3)}). In addition, since all the25
fluentsinB1.1havebeenrelatedthroughanequivalencerelationship(eq)withthosein
B2.1((3,0,0,0) inthetable)itcanbesaidthatthosebranchesareequivalent(B1.1=b
B2.1).Furthermore,duetothe(4,0,0,1)valuationgivento(B1.2,B2.3),itcanbeseen
that B1.2 is somehow included in B2.3. Since the fluent that has not been paired up
(r10.3) is generated in an inner state of B2.3, it results B1.2=cB2.3.
In summary, two of the three branches of P2 can be related with the ones in P1
(notion of restriction R), those branches are related via thecomplement to infix rela-
tionshipC andtherelationship betweenthecomparedfluentsistheoneofequivalence
E,so we can say that P1[ECR]P2.
7 Related Works
Different criteria can be considered for a classification of related works that can be
found in the specialized literature. One significant criterion, with respect to protocol
definitions, is that which distinguishes among those works that prevail in a semantic
approachincontrastwithothersthatonlyconsiderastructuralone.Anotherinterest-
ing criterion is the consideration or not of formal relationships between protocols. A
third criterion is if the works consider a notion of protocol composition.
We will firstly review the first criterion that is, works which introduce semantic
considerations when definingprotocols.
The closer work is (Mallya and Singh, 2007), where protocols are represented as
transition systems where transitions are formalized as operations on commitments.
Subsumptionandequivalenceof protocols are definedwith respect tothreestate sim-
ilarity funtions. We share some goals with that work, but in that paper there are no
references to how protocol relationships are computed. In contrast, according to our
proposal, protocol relationships can be computed by straightforward algorithms. It is
worth mentioning that protocol relationships considered in that paper deserve study
withinourframework.Anotherworkthatconsiderprotocolrelationshipsis(Desai et al,
2005),whereprotocolsarerepresentedwithasetofruleswithtermsobtainedfroman
ontology. In particular they formalize protocols into the π-calculus; then, equivalence
through bisimulation is the only relationship considered.
Withrespecttothegroupofworksthatdonotconsiderthestudyofrelationships
between protocols, the works (Yolum and Singh, 2002) and (Fornara and Colombetti,
2003) are quite similar one to another. Both capture the semantics of communication
actsthrough agents’commitments andrepresent communication protocols usinga set
ofrulesthatoperateonthesecommitments.Moreover,thoserulesetscanbecompiled
as Finite State Machines. In (Kagal and Finin, 2007), protocols are defined as a set
ofpermissionsandobligationsofagentsparticipatinginthecommunication.Theyuse
an OWL ontology for defining the terms of the specification language, but their basic
reasoningismadewithanadhocreasoningengine.Wesharetheirmaingoalofdefining
protocols in a general framework that allows them to bere-used.
Oneworkthatfocusesontheproblemofprotocolcompositionis(Yolum and Singh,
2007). It introduces considerations of rationality on the enactment of protocols. Our
proposal could becomplemented with theideas presented in that work.
Wereviewsecondlyworksthatdealsolelywithstructuralaspectsofprotocols.We
advocate for a more flexibleapproach dealing with semantics.
The work presented in (Montes-Rendo´n et al, 2006) describes a methodology that
facilitatescommunicationamongheterogeneousnegotiationagentsbasedonthealign-26
ment of communication primitives. Finite State Machines are used as a model to rep-
resent negotiation protocols and as abase for aligning primitives.This is quitearigid
approachbecausecommunication willonlybepossibleifprotocols havesuchasimilar
structurethat theircommunication primitives can bealigned two bytwo.
(d’Invernoet al, 1998) and (Mazouzi et al, 2002) use Finite State Machines and
Petri nets, respectively, to represent protocols but without taking into account the
meaningof thecommunication actsinterchanged orconsidering relationships between
protocols.Theworkof(Ryuet al,2007)hasaninterestingapproachtomanagechanges
inbusinessprotocols.Moreprecisely,itpresentsanextensivestudyonhowtotranslate
active instances from an old protocol to a new one, without violating several types of
constraints. Inorder todoso, it compares theold protocol with thenew onebutonly
examines structural differences between them, which results in a more rigid approach
that the one allowed by our mechanism, which considers semantics representation of
protocols.
Forthethirdcriterionweissuetheproblemofdeterminingifanagent’spolicycon-
formstoaprotocol.Thisisaveryrelevantproblembutnotonewhichweareexamining
inthispaper.Nevertheless,thetopiciscloselyrelatedtooursanditisworthmention-
inghere.In(Endriss et al,2003),deterministicFiniteStateMachinesaretheabstract
modelsforprotocols,whicharedescribedbysimplelogic-basedprograms.Threelevels
of conformance are defined: weak, exhaustive and robust. They consider communica-
tion acts as atomic actions, in contrast to our semantic view. In (Baldoni et al, 2006)
a nondeterministic Finite State Automatais used to support a notion of conformance
thatguaranteesinteroperabilityamongagentswhichconformtoaprotocol.Theircon-
formancenotionconsidersthebranchingstructureofpoliciesandprotocolsandapplies
a simulation-based test. Communication acts are considered atomic actions, without
considering their semantics. In (Chopra and Singh, 2006), a notion of conformance is
defined and, moreover, it is proved orthogonal to their proposed notions of coverage
and interoperability.
Apart from the previous classification, in the context of Web Services, state tran-
sition systems are used in (Bordeaux et al, 2004) for representing dynamic behaviour
of services and defining some notions of compatibility and substitutability of services
thatcanbeeasilytranslatedtothecontextofcompatibilityofprotocols.Relationships
between theircompatibility relations and our definedrelationships deserve study.
8 Conclusions
In this paper we have explained a mechanism for discovering semantic relationships
among agent communication protocols. The mechanism is based on the idea that dif-
ferentprotocolscanbecomparedsemanticallybylookingtothesetoffluentsassociated
to the branches of protocols. That assumption favours a much more flexible compari-
sonofprotocolsthanthemoretraditionalonebasedoncomparingprotocolstructures.
Through thepaperwehaveshown first,oneontology that representsconceptsrelated
tocommunicationactsthatagentsusetocommunicatewitheachotherandwhichtake
part of the protocols. Secondly, we have concentrated on showing: how protocols are
modelled,inourcaseusingOWL-DLlanguage, andthefeaturesofthealgorithm that
analyses each protocol by decomposing it into different branches, and by generating
thesemanticsinformationassociatedtoeachbranch.Thirdly,wehavepresenteddiffer-
ent definitions that are managed by themechanism which permit theidentification of27
protocol relationships. Moreover,someproperties ofthoserelationships andproofs for
themhavebeenincluded.Finally,with anexampleweillustrated thefeasibility ofthe
proposed mechanism which has been implemented using Java as a programming lan-
guage andPellet asadescription logic reasoner. Asafuturework wearestudyingthe
interest of adapting the proposed mechanism to contexts where Information Systems
are represented through Web Services.
Acknowledgements Thework of Idoia Berges is supported bya grant of the Basque Gov-
ernment (Programa de Formaci´on de Investigadores del Departamento de Educaci´on, Uni-
versidades eInvestigacio´n). Thiswork isalso supported by the Basque Country Government
IT-427-07andtheSpanishMinistryofEducationandScienceTIN2007-68091-C02-01.
References
(2008) Web Ontology Language (OWL) Guide Version 1.0.
http://www.w3.org/2001/sw/WebOnt/guide-src/Guide.html
Austin JL (ed) (1962) How to do thingswith words. Oxford University Press
Baldoni M, Baroglio C, Martelli A, Patti V (2006) A priori conformance verification
for guaranteeing interoperability in open environments. In:ICSOC, pp 339–351
Bermu´dez J, Gon˜i A, Illarramendi A, Bagu¨´es MI (2007) Interoperation among
agent-based information systems through a communication acts ontology. Inf Syst
32(8):1121–1144
Bordeaux L,Salau¨n G,Berardi D,Mecella M(2004) Whenaretwoweb services com-
patible? In:TES, pp 15–28
ChopraAK,Singh MP(2006) Producingcompliant interactions: Conformance, cover-
age, and interoperability. In:DALT, pp 1–15
Desai N, Mallya AU, Chopra AK, Singh MP (2005) Interaction protocols as design
abstractions for business processes. IEEE Trans Softw Eng 31(12):1015–1027
d’InvernoM,KinnyD,LuckM(1998)Interactionprotocolsinagentis.In:InProceed-
ingsoftheThird InternationalConference onMulti-AgentSystems(ICMAS98), pp
261–268
Endriss U, Maudet N, Sadri F, Toni F (2003) Logic-based agent communication pro-
tocols. In: Workshop on Agent Communication Languages, pp91–107
FIPA (2005) FIPA communicative act library specification.
Http://www.fipa.org/specs/fipa00037/SC00037J.html
Fornara N, Colombetti M (2002) Operational specification of a commitment-based
agent communication language. In: AAMAS ’02: Proceedings of the first interna-
tional joint conference on Autonomousagents and multiagent systems, ACMPress,
New York,NY,USA,pp536–542
Fornara N, Colombetti M (2003) Defining interaction protocols using a commitment-
based agent communication language. In: AAMAS ’03: Proceedings of the second
internationaljointconferenceonAutonomousagentsandmultiagentsystems,ACM
Press, New York,NY,USA,pp520–527
Greenwood D, MLyell HS A Mallya (2007) The IEEE FIPA approach to integrat-
ing software agents and web services. In: International Conference on Autonomous
Agentsand Multiagent SystemsAAMAS,Hawaii USA,pp 14–18
Kagal L, Finin T (2007) Modeling conversation policies using permissions and obliga-
tions. Autonomous Agentsand Multi-Agent Systems14(2):187–20628
Mallya AU, Singh MP (2007) An algebra for commitment protocols. Autonomous
Agentsand Multi-Agent Systems14(2):143–163
Mazouzi H, Seghrouchni AEF, Haddad S (2002) Open protocol design for complex
interactions in multi-agent systems. In: AAMAS ’02: Proceedings of the first in-
ternational joint conference on Autonomous agents and multiagent systems, ACM
Press, New York,NY,USA,pp517–526
Montes-Rendo´n A, Bravo M, Vel´azquez-Hern´andez JC (2006) An ontology-based
methodology for communicating negotiation agents over internet. In: Proceedings
of the 2006 Joint Conference on Information Sciences, JCIS 2006, Kaohsiung, Tai-
wan
Ryu SH, Saint-Paul R, Benatallah B, Casati F (2007) A framework for manag-
ing the evolution of business protocols in web services. In: Conceptual Modelling
2007, Proceedings of the Fourth Asia-Pacific Conference on Conceptual Modelling
(APCCM2007), Ballarat, Victoria, Australia
ShanahanM(1999) Theeventcalculusexplained.LectureNotesinComputerScience
1600:409–430
Singh MP (1998) Agent Communication Languages: Rethinking the Principles. IEEE
Computer 31(12):40–47
Singh MP (2000) A social semantics for agent communication languages. In: Issues in
Agent Communication, Springer-Verlag, pp 31–45
Venkatraman M, Singh MP (1999) Verifying compliance with commitment protocols.
AutonomousAgents and Multi-Agent Systems 2(3):217–236
Wooldridge M (2000) SemanticIssuesin theVerification of Agent Comunication Lan-
guages. Journal of Autonomous Agentsand Multi-Agent Systems3(1):9–31
Yolum P, Singh M (2007) Enacting protocols by commitment concession. In: Interna-
tionalConferenceonAutonomousAgentsandMultiagentSystemsAAMAS,Hawaii
USA,pp116–123
Yolum P, Singh MP (2002) Flexible protocol specification and execution: Applying
eventcalculusplanningusingcommitments.In:Proceedingsofthe1stInternational
JointConferenceonAutonomousAgentsandMultiAgentSystems(AAMAS),ACM
Press, pp 527–53429
A Generation of fluents