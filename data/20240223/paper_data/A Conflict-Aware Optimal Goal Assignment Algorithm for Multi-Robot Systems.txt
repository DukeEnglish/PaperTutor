A Conflict-Aware Optimal Goal Assignment Algorithm for Multi-Robot Systems
AakashandIndranilSaha
DepartmentofComputerScienceandEngineering
IndianInstituteofTechnologyKanpur
{aakashp,isaha}@cse.iitk.ac.in
Abstract literature. The first approach is a decoupled one, where the
task assignment problem and the path planning problem
Thefundamentalgoalassignmentproblemforamulti-robot
aresolvedsequentially.Thesemethods(Turpinetal.2013;
application aims to assign a unique goal to each robot
Turpin, Michael, and Kumar 2013; Turpin et al. 2014)
while ensuring collision-free paths, minimizing the total
are scalable but generally considers only makespan as
movement cost. A plausible algorithmic solution to this
the objective function and do not provide any guarantee
NP-hardprobleminvolvesaniterativeprocessthatintegrates
ataskplannertocomputethegoalassignmentwhileignoring of optimality. The second approach integrates the task
thecollisionpossibilitiesamongtherobotsandamulti-agent plannerandthemotionplanner,and,throughtheiriterative
path-finding algorithm to find the collision-free trajectories interaction, find the optimal collision-free paths for the
for a given assignment. This procedure involves a method robots upon convergence. These methods (Ma and Koenig
for computing the next best assignment given the current 2016;Ho¨nigetal.2018),thoughguaranteeoptimality,suffer
best assignment. A naive way of computing the next best fromthelackofscalability.Amajoroutstandingquestionon
assignment,asdoneinthestate-of-the-artsolutions,becomes
multi-agent planning is whether there could be a scalable
a roadblock to achieving scalability in solving the overall
algorithm that can also guarantee the optimality of the
problem.Toobviatethisbottleneck,weproposeanefficient
collision-freepathsfortheagentsintermsofthetotalcost.
conflict-guidedmethodtocomputethenextbestassignment.
Additionally, we introduce two more optimizations to the In this paper, we present an optimal algorithm for
algorithm — first for avoiding the unconstrained path the AMAPF problem with minimization of the total cost
computations between robot-goal pairs wherever possible, as the objective, which is scalable to a large number
and the second to prevent duplicate constrained path of robots. Our algorithmic solution is inspired by the
computations for multiple robot-goal pairs. We extensively design of CBS-TA (Ho¨nig et al. 2018), which involves
evaluateouralgorithmforuptoahundredrobotsonseveral
an iterative process that integrates a task planner based
benchmark workspaces. The results demonstrate that the
on Hungarian algorithm (Kuhn 1955) to compute the goal
proposed algorithm achieves nearly an order of magnitude
assignmentwhileignoringthecollisionpossibilitiesamong
speedup over the state-of-the-art algorithm, showcasing its
the robots and the state-of-the-art multi-agent path-finding
efficacyinreal-worldscenarios.
algorithmCBS(Sharonetal.2015)tofindthecollision-free
trajectoriesforagivenassignment.Thisprocedureisbased
1 Introduction
on a method for computing the next best assignment given
A fundamental problem related to operating a multi-robot thecurrentbestassignment.However,CBS-TA’snaiveway
systemistheanonymousmulti-agentpathfinding(AMAPF) of computing the next best assignment using the standard
problem (Stern et al. 2019). In this problem, the initial algorithm (Murty 1968; Chegireddy and Hamacher 1987)
locations of a set of robots and a set of goal locations becomes the major bottleneck to achieving scalability in
are given, and the aim is to assign each robot to a goal solvingtheoverallproblem.
such that the assigned paths are collision-free and the In this paper, we target this prime roadblock to achieve
total cost or makespan of the trajectories of the robots to scalability in solving an AMAPF problem optimally.
their designated goal locations is minimized. Though this Towards this goal, we propose a conflict-guided method
problem is at the core of many multi-robot applications to compute the next best assignment. Our method keeps
suchaswarehousemanagement(Lietal.2021;Chenetal. track of the partial robot-goal assignments that led to an
2021; Das, Nath, and Saha 2021), disaster response (Tian increase in the cost while resolving robot-robot collisions
etal.2009),precisionagriculture(Gonzalez-de-Santosetal. duringthecollision-freemulti-agentpath-findingstage.We
2017),mailandgoodsdelivery(Grippaetal.2019),etc.,its use these cost-increasing partial robot-goal assignments to
computationalintractability (YuandLaValle 2013)poses a formulate constraints and use them to postpone computing
majorhindranceindevelopingascalablesolution. new assignments containing the same partial robot-goal
To deal with the computational hardness of the AMAPF assignments. This postponement is enforced until there is
problem, two main approaches have been studied in the a possibility of computing robot-goal assignments with
4202
beF
91
]AM.sc[
1v29231.2042:viXraa lower cost. Afterwards, the postponed assignments are 4 R4R2 G1 G2 G3 G4
reconsideredtofindcollision-freepaths. 3 R1 2 2 2 4
Whilepostponementofthecomputationoftheinefficient 2 G3 G1 R2 4 6 2 4
assignments has been our major algorithmic contribution, 1 G4 R1 R3 R3 2 2 4 6
we also introduce two other powerful optimizations to 0 G2
R4 5 7 3 5
the basic integrated task assignment and path planning 0 1 2 3 4
algorithm. First, in our algorithm, we incorporate the
mechanismforcomputinganassignmentwithoutcomputing (a)Workspace (b)FinalAssignment
the independent paths between all robot goal pairs, as
Figure1:Anexampleproblem
introduced in (Aakash and Saha 2022). The standard
assignment computation algorithm Hungarian method
requires the costs for all robot-goal pairs a priori.
2.2 ProblemDefinition
(Aakash and Saha 2022) provides an algorithm that
can compute an optimal assignment while computing In a typical multi-robot application, robots must complete
only a few independent paths between robot-goal pairs a set of tasks within a designated workspace. These tasks
in a demand-driven way. We adapt their mechanism areassociatedwithspecificlocationswithintheworkspace,
in computing the assignments in such a way that we referred to as goal locations. The robots must navigate to
compute the paths between the robot-goal pairs minimally their respective goal locations to complete their assigned
while computing an assignment, and the paths computed tasks. A collision-free robot-goal assignment is defined as
for one assignment computation can be reused in the the allocation of a unique goal to each robot, such that
subsequentassignmentcomputations.Second,weintroduce the resulting paths are devoid of collisions (robot-robot
a path memoization mechanism to prevent duplication in collisions or robot-obstacle collisions). The cost of such
constrainedpathcomputationsformultiplerobot-goalpairs. an assignment represents the sum of the costs incurred
We implement our algorithm in Python and evaluate by each robot to reach their respective goal locations. An
it through extensive experimentation on several optimalcollision-freerobot-goalassignment istheonethat
standard benchmark workspaces. As a baseline, we minimizesthecost.Wenowdefinetheproblemformally.
use CBS-TA (Ho¨nig et al. 2018), which is considered to
Problem 1. Consider a multi-robot application with a
be the state-of-the-art for solving the AMAPF problem
grid-based workspace WS, the set S of start locations of
optimally. We evaluate our algorithm for up to 100 robots.
the robots, and the set F of goal locations as inputs. Each
Experimental results demonstrate that our algorithm scales
robot can be assigned to at most one goal, and each goal
wellwiththenumberofrobotsandoutperformsCBS-TAby
can be served by at most one robot. Find a collision-free
anorderofmagnitude.Wealsoevaluatetheefficacyofthe
robot-goal assignment for the multi-robot application such
individual optimizations through an ablation study, which
thatthecostoftheassignmentisminimized.
confirmsthatallthreeoptimizationsintroducedinthispaper
contribute significantly to the overall performance of the
2.3 Example
algorithm.
Consider a multi-robot application in the 5×5 workspace
as illustrated in Figure 1(a). It consists of four robots
2 Problem
(R1,R2,R3,andR4)andfourgoals(G1,G2,G3,andG4).
The black-colored cells denote the obstacles. We aim to
2.1 Preliminaries
determine an assignment of robots to goals that optimizes
Notations. Let N represent the set of natural numbers and the total cost of movement of all the robots while
R represent the set of real numbers. For a natural number guaranteeingcollision-freepaths.Figure1(b)displaysacost
n∈N,let[n]denotetheset{1,2,3,...,n}. matrix associated with the multi-robot application, which
is an outcome of our approach. Here, the colored cells
Workspace. A workspace WS is a 2D rectangular space reflect the actual costs, while the white cells display the
whichisdividedbygridlinesintosquare-shapedcells.Each heuristic costs (computed using the Manhattan distance)
cell can be addressed using its coordinates. In general, a corresponding to the robot-goal pairs. The matrix cells in
workspace consists of a set O of cells that are occupied by green color depict the assignment that has an optimal total
obstacles.Mathematically,WS = ⟨dimension,O⟩,where costwhileensuringcollision-freepaths.Inthenextsection,
dimension is a tuple of the number of cells along the wepresentanefficientapproachtoachievethisaim.
coordinateaxes.
3 Algorithm
Motion Primitives. In a 2D workspace, we assume that a
robotcanmovein4directions(Up,Down,LeftandRight) In this section, we present the details of our algorithm
from its current location while respecting the workspace that efficiently computes optimal collision-free robot-goal
boundaries. It also has the option to stay in its current cell. assignment for multi-robot systems. It learns the sets
Each motion primitive incurs a cost of 1 unit, indicative of of conflicting robot-goal paths that inevitably lead to
thetimerequiredforitsexecution. an increase in the assignment cost. This enables theAlgorithm1: OptimalCollision-FreeGoalAssignmentforMulti-RobotSystems
Global: OPEN,MemPath,root gen
1 proceduresolve goal assignment(WS,S,F ) 31 procedurecreate root(θ)
2 root gen←0 32 root gen←root gen+1
3 fori=1to|S| do 33 Υ←newsearchnode
4 forj =1to|F|do 34 Υ.root←True
5 C(i)(j)=get Manhattan distance(S(i),F(j)) 35 Υ.root id←root gen
36 Υ.parent←None
6 ⟨C,θ⟩←get first assignment(C) 37 Υ.constraints←∅
7 if θisnotNonethen 38 Υ.M ←θ.M, Υ.path←θ.path
8 latest root cost←create root(θ) 39 Υ.cost←θ.cost, Υ.root cost←θ.cost
9 whileOPEN isnotempty do 4 40
1
i rn es te ur rt nΥ Υ.t co osO tPEN
10 Υ∗ ←extractbestnodefromOPEN
11 conflict←get first conflict(Υ∗.path) 42 procedurecreate child nodes(Υ∗,Constraints,WS,S,F)
1 12
3
if co rn etf ul ri nct Υis ∗N .pao tn he then 4 43
4
fore Υac ←hro nb eo wtr se∈ arC co hn ns otr da eintsdo
14 edge1=(conflict.robot 1,Υ∗.M(conflict.robot 1)) 45 Υ.root←False
15 edge2=(conflict.robot 2,Υ∗.M(conflict.robot 2)) 46 Υ.root id←Υ∗.root id
16 Acc conf(Υ∗.root id).add(edge1,edge2) 47 Υ.root cost←Υ∗.root cost
17 Constraints←create constraints(conflict) 48
Υ.parent=Υ∗
18 create child nodes(Υ∗,Constraints,WS,S,F) 49 Υ.constraints←Υ∗.constraints+
Constraints(r)
19 Υ next ←peepatnextbestnodewithinOPEN 50 Υ.M ←Υ∗.M, Υ.path←Υ∗.path
20 if Υ next.root=False then 51 g=Υ.M(r), c=Υ.constraints(r)
21 if Υ next.cost>Υ next.parent.costand 52 Υ.path(r)←get constrained path(r,g,c)
Υ next.conf reg=Falsethen
53
Υ.cost←Υ∗.cost−compute cost(Υ∗.path(r))+
22 cost inc =Υ next.cost−Υ next.root cost compute cost(Υ.path(r))
23 conf rec= 54 insert Υ to OPEN
⟨Acc conf(Υ .root id),cost ⟩
next inc
24 if conf recnotinConflict recthen 55 procedureget constrained path(r,g,c)
25 Conflict rec.add(conf rec) 56 if MemPath(r)(g)(c)doesnotexistthen
26 Υ next.conf reg←True 57 MemPath(r)(g)(c)←ASTAR(WS,S(r),F(g),c)
27 if Υ next.cost>latest root cost then 58 returnMemPath(r)(g)(c)
28 ⟨C,θ⟩←get next assignment(C,
Conflict rec)
29 if θisnotNonethen
30 latest root cost←create root(θ)
algorithmtopostponetheexpensivecomputationofseveral specificassignment.Anassignmentcanpotentiallycontain
assignmentsthatcontainthoselearnedconflicts. two or more robots whose paths conflict with each other.
Let us denote the location of a robot r at timestep τ by
i
3.1 AlgorithmDescription l ao ’c vτ r ei r. tA exc co on nfl fli ic ct t’be (it .w e.e ,e ∃n tt iw mo er τob :o lots cτr i =an ld ocr τj c )a on rb ae ne ’eit dh ge er
ri rj
We present our goal assignment algorithm formally conflict’ (i.e., ∃ time τ : locτ = locτ+1 and locτ+1 =
in two parts, namely, Algorithms 1 and 2. While locτ ). Each tree may containri a set ofr nj odes represri enting
Algorithm 1 captures our complete approach, Algorithm 2 rj
theassignment(specifictoitsroot)withadditionalvertexor
exclusivelyexhibitstheproceduresrelatedtoconflict-aware
edgeconstraintsthatresultfrommitigationofconflicts.We
computation of assignments. Our algorithm and notation
use a priority queue OPEN to store the nodes belonging
draw inspiration from the state-of-the-art CBS-TA (Ho¨nig
tothetreesoftheforest,prioritizingthembasedonthecost
et al. 2018). Like CBS-TA, our approach builds a search
duetotheassignmentandanyassociatedconstraints.
foresttolookforagoalassignmentthatiscollision-freeand
hasoptimalcost.Typically,asearchforestconsistsofmore Thefirstproceduresolve goal assignmentactsasthe
than one tree, each rooted at its respective root denoting a main module that invokes other procedures to solve theAlgorithm2:Conflict-AwareAssignment optimal collision-free goal assignment problem. It accepts
theworkspaceWS,thesetSofstartlocationsoftherobots,
Global: ASGN OPEN,ASGN POST andthesetF ofgoalslocationsasinputs.Asafirststep,it
1 procedureget first assignment(C) computes the heuristic cost (Manhattan distance) for each
2 θ←newasgnnode robot-goal pair and finds an initial robot-goal assignment
3 θ.O←∅, θ.I ←∅ (Algo 1: Line 3-6). This assignment has an optimal cost
4 ⟨C,M,path⟩←compute assignment(C,θ.O,θ.I) (based on the actual costs for the assigned robot-goal
5 θ.M ←M, θ.path←path pairs), but may consists of collisions among the robots.
6 θ.cost←compute cost(path) On the existence of an initial assignment, the algorithm
7 insert θ to ASGN OPEN creates a corresponding root node (of the search forest)
8 return⟨C,θ⟩
through the create root procedure (Algo 1: Line 8).
9 procedureget next assignment(C,Conflict rec) The create root procedure (Algo 1: Lines 31-41) also
10 θ∗ ←extractleastcostnodefromASGN OPEN initializestherootnode’sattributes,includingtherobot-goal
11 if θ∗doesnotexistthen assignment(denotedbyM inAlgo1:Line38).
12 returnNone Algorithm 1 performs a set of steps iteratively in the
13 R←derivesetofrobotsfromθ∗.M process to find an optimal collision-free goal assignment
14 sortConflict recindecreasingorderofcost inc (Algo 1: Lines 9-30). It extracts the best node from
// create custom order for looping
OPEN and checks the associated assigned paths for
15 for eachtuplet∈Conflict rec do conflict(Algo1:Lines10-11).Intheabsenceofconflict,the
16 foreachedge(r,g)∈t.Acc conf do algorithmreportsthecurrentsetofassignedpathsasoutput
17 if r∈/ ordered robotsthen
(Algo 1: Lines 12-13). However, in the event of a conflict,
18 ordered robots.add(r)
19 R.remove(r) the algorithm follows the well-known ‘Conflict-Based
Search’ (CBS) framework (Sharon et al. 2012, 2015) to
20 selectanyrobotr′∈R derive the constraints from the conflict and generate the
21 for eachremainingrobotr∈(R−r′)do childnodes(Algo1:Lines17-18).
22 ordered robots.add(r) Letusnowreviewourkeyalgorithmiccontributions.
23 for eachrobotr∈ordered robots do
24 if r∈/ θ∗.Ithen Conflict-AwareAssignmentComputation. Withafocus
25 θ←newasgnnode on finding an optimal collision-free goal assignment,
26
θ.O←θ∗.O∪{r,θ∗.M(r)} our approach, like CBS-TA, may require to compute a
27 θ.I ←θ∗.I∪{u,θ∗.M(u):ind u <ind r} sequence of next best assignments apart from the optimal
28 lb cfasgn ←θ∗.cost assignment.ItispossibletoenumeratetheK bestsolutions
29 for eachtuplet∈Conflict recdo in various domains, including goal assignment (Eppstein
30 if t.Acc conf ⊆θ.Ithen 2016). However, instead of inefficiently generating a set of
31 lb cfasgn ←lb cfasgn+t.cost inc K best assignments, we draw inspiration from the existing
32 exitloop approachof(Murty1968;ChegireddyandHamacher1987)
33 if lb cfasgn >θ∗.costthen and devise a novel method of computing the next best
assignmentondemand.
34 ASGN POST.add(⟨lb cfasgn,θ.O,θ.I⟩)
Unlike CBS-TA, which computes the next best
35 else assignment immediately on the expansion of a root
36 ⟨C,M,path⟩←
node (representing the current best assignment), our
compute assignment(C,θ.O,θ.I)
37 if M ̸=∅then approach computes the next best assignment only when
38 θ.M ←M, θ.path←path continuingthesearchwithintheforestwouldleadtoacost
39 θ.cost←compute cost(path) that exceeds the largest cost among all the roots (denoting
40 insert θ to ASGN OPEN the largest assignment cost in the forest). We propose a
novel conflict-aware assignment computation mechanism
41 best cost avail ←mincostfromASGN OPEN for multi-robot systems that efficiently computes the next
42 best cost post ←mincostfromASGN POST best assignment given the current best. It encompasses the
43 while best cost avail >best cost postdo followingthreesteps.
44 ∆←min(ASGN POST) 1. Conflictaccumulation:Alternatively,wedefinethepath
45 θ←newasgnnode
ofarobotrtoitsassignedgoalg asanedgedenotedby
46 θ.O←∆.O, θ.I ←∆.I
47 repeatlines36-40
(r,g).Whenthereisaconflictbetweentworobots(i.e.,
48 best cost avail ←mincostfromASGN OPEN between two paths or edges), Algorithm 1 cumulatively
49 best cost post ←mincostfromASGN POST accumulates the pair of conflicting edges in the related
50 θ∗ ←selectleastcostnodefromASGN OPEN tree’sbasketAcc conf (Algo1:Lines14-16).
51 return⟨C,θ∗⟩ 2. Conflict registration: After the creation of child nodes
in adherence to CBS, Algorithm 1 peeps at (and
not extract) the tentative next best node Υ within
next
OPEN (Algo 1: Line 19). If Υ is a non-root
nextnode with a cost greater than its parent’s cost, and thatt.Acc conf ⊆‘include’setofanassignmentnotyet
if its ‘conflict registered’ flag (conf reg) is not set, computed.Then,thelowerboundcostofthisassignment
the algorithm registers (learns) the set of accumulated canbecomputedas:
conflicting edges (Acc conf) with corresponding cost
lb ←θ∗.cost+t.cost .
increment(cost )intheconflictrecord(Conflict rec) cf asgn inc
inc
(Algo 1: Lines 20-26). The conf reg flag also assists
After the assignments are computed or postponed using
in determining the next best node by distinguishing
the custom order, we revoke the postponement and
and prioritizing the nodes having identical costs (see computethoseassignmentswhoselb arelessthan
cf asgn
Remark1).
the minimum cost among the computed assignments
3. Assignment computation: If the cost of the tentative storedinASGN OPEN (Algo2:Lines41-49).
next best node appears to exceed the largest cost Remark 1. In Algorithm 1, two instances require
among the roots, we proceed to compute the next best determining the best node from the set of available nodes
assignment (i.e., a new root) (Algo 1: Lines 27-30). in the priority queue OPEN (Algo 1: Lines 10 and 19).
Drawing inspiration from the established approach Thisselectionhingesontwocriteria,prioritizedasfollows:
of (Murty 1968; Chegireddy and Hamacher 1987), (a)cost,wherelowervaluesarefavored,and(b)the‘conflict
we propose a novel routine through Algorithm 2 that registered’ flag (conf reg), with a preference for “False”
uses conflict-guided approach for the computation of over “True”. The second criterion accelerates the process
next best assignment of robots to goals, given the of conflict registration, meaning that conflicts are learned
currentbestassignmentinmulti-robotapplication.Inthis morerapidly.
algorithm,weemploythefollowingtwopriorityqueues:
Remark 2. In Algorithm 1, Line 19, we only peep at the
(a)ASGN OPEN,whichstoresthenodesrepresenting
next best node within the priority queue OPEN without
thecomputedassignments,prioritizingthembasedonthe
extracting it. The reason behind this look-ahead approach
costofassignment,and(b)ASGN POST,whichstores
is as follows. There can be numerous nodes with the same
meta data about the assignments whose computations
cost.Ifconflictregistrationweretooccuronlywhenanode
are postponed, prioritizing them based on the lower
with a higher cost is selected for processing, the nodes
bound cost of the postponed assignments (discussed
with lower costs would need to be processed first. This
later).Weformulateaconflict-guidedapproachinwhich
woulddelaytheutilizationofvaluableconflictinformation.
we postpone the computation of an assignment when it
Therefore, looking ahead to the next best node allows
is guaranteed to include a set of conflicting edges that
proactiveconflictregistration,optimizingtheconflict-aware
willunavoidablyescalatetheassignment’scost.Andthe
assignmentcomputation.
postponement should happen with the largest inevitable
cost increase. To achieve this, Algorithm 2 sorts the Heuristic Distance-Based Assignment Computation.
tuples (of ⟨set of conflicting edges, cost increment⟩) in The goal assignment algorithm introduced in (Aakash
Conflict rec in descending order of cost increments and Saha 2022) can compute a robot-goal assignment
(Algo2:Line14). efficiently (without avoiding robot-robot collisions) by
The existing literature considers iteration over the set avoiding the computation of a majority of robot-goal
of robots in a sequential order to partition the solution paths. We adapt their solution for our problem by making
space of the assignments (Murty 1968; Chegireddy the following customizations to create a new procedure
and Hamacher 1987; Ho¨nig et al. 2018). In a major compute assignment (Algo 2: Lines 4 and 36). We
divergencefromthepreviousworks,wecreateacustom provide two additional inputs, namely, an ‘include’ set and
orderingofrobots,whichaidsinmaximizingthenumber an ‘omit’ set, to the aforesaid algorithm to further increase
of postponed assignments. We place the robots that itsefficiency.Sincetherobotsandgoalsthatareapartofthe
indulge in any conflict ahead of the non-conflicting ‘include’ set are compulsorily included in the assignment,
robotsinthecustomorder(Algo2:Lines15-22). we eliminate the rows and columns corresponding to them
from the cost matrix. Additionally, we assign an infinite
Using the new custom order, we perform the
cost to the robot-goal pairs present in the ‘omit’ set.
conventional steps of building the ‘omit’ and the
An invocation of the compute assignment procedure can
‘include’setsofedges,whichareusedwhiledetermining
leavethecostmatrixinastatewhereithasamixofheuristic
an assignment (Algo 2: Lines 23-27). However, before
andactualcosts.Wepreserveandforwardthemodifiedstate
going ahead with the assignment computation, we scan
of the cost matrix in the subsequent invocations to prevent
its ‘include’ set to check for the presence of one of
duplicatepathcomputationsfortherobot-goalpairs.
the learned sets of conflicting edges. If a learned set is
indeed a subset of the ‘include’ set, we postpone the Path Memoization. Several robots may retain their
computationoftheassignment,andsaveacorresponding assigned paths between two or more robot-goal
entry in the priority queue ASGN POST (Algo 2: assignments. This implies that the conflicts and the
Lines 28-34). The first element lb of the tuple corresponding constraints can remain consistent across
cf asgn
saved in ASGN POST denotes the lower bound cost many assignments. To leverage this consistency, we
of the collision-free assignment. Let θ∗ be the current introduce ‘Path Memoization’, which involves caching the
bestassignmentandtbethetupleinConflict recsuch paths computed under specific constraints for future reuse.N1 first conflict in the node’s associated paths. The grey
11 False
color of nodes ‘N1’ and ‘N2’ signify that their processing
R2G3 - R4G4
is complete. The tentative next best node for processing
Update R2G3Update R4G4
seems to be ‘N3’ (or ‘N4’) with a cost of 12. Thus,
4 R4R2 N2 N3
Figure2(b)displaysthatstateofthesearchtreefromwhich
3 11 False 12 False
R2G3 - R4G4 the next node cannot be chosen for processing without
2 G3 G1
incurring an increase in the cost of assignment. Having
Update R4G4Update R2G3
1 G4 R1 R3
N4 met the hurdle of cost increment, Algorithm 1 registers
0 G2 12 False Duplicate the set of accumulated conflicting paths (Acc conf) with
0 1 2 3 4 Node corresponding cost increment (cost ) (Figure 2(c)). The
inc
valueofcost representsthedisparitybetweenthecostof
(a)InitialAssignment (b)CBSonInitialAssignment inc
the tentative next best node and that of the corresponding
N1
11 False root. Subsequently, the conf reg flag of ‘N3’ is set to
R2G3 - R4G4 “True”(Figure2(d)).
Update R2G3Update R4G4 Sincetheprobablenextbestnode’scost(12)exceedsthe
N2 N3 current largest cost among root nodes (11), Algorithm 1
11 False 12 True invokes the get next assignment procedure (expanded
cost inc Acc_conf Acc_conf cost inc R2G3 - R4G4 in Algorithm 2) to compute the next best assignment. It
1 { R2G3, R4G4 } { R2G3, R4G4 } 1 Update R4G4Update R2G3 generates a custom ordering of robots (Figure 2(e): first
N4 table) by keeping the robots engaged in conflicts ahead
12 False Duplicate
of those with non-conflicting paths. Consequently, R2 and
Node
R4 appear before R1 and R3 in the order. Following the
(c)ConflictRegistration-I (d)ConflictRegistration-II established approach outlined in prior works (Murty 1968;
Chegireddy and Hamacher 1987; Ho¨nig et al. 2018), the
get next assignment procedure computes the ‘include’
(cid:53) (cid:3)(cid:11)(cid:82) (cid:53)(cid:3)(cid:38) (cid:53)(cid:69) (cid:21)(cid:82)(cid:88) (cid:21)(cid:87) (cid:15)(cid:86) (cid:3)(cid:87) (cid:53)(cid:82) (cid:23)(cid:80) (cid:15)(cid:3)(cid:3) (cid:53)(cid:50)(cid:44)(cid:81) (cid:20)(cid:85)(cid:70) (cid:94)(cid:15)(cid:71) (cid:3)(cid:79) (cid:3)(cid:53)(cid:72)(cid:88) (cid:96)(cid:85) (cid:22)(cid:71) (cid:3)(cid:72) (cid:12) (cid:36)(cid:70)(cid:70) (cid:49)(cid:66) (cid:82)(cid:70) (cid:3)(cid:82) (cid:17147)(cid:81)(cid:73) (cid:3)(cid:3) (cid:38)(cid:17306) (cid:82)(cid:80)(cid:3)(cid:44)(cid:81) (cid:83)(cid:70) (cid:88)(cid:79) (cid:87)(cid:88) (cid:72)(cid:71)(cid:72)(cid:34)(cid:36)(cid:86)(cid:74)(cid:81) (cid:20)(cid:20)(cid:66)(cid:70)(cid:82)(cid:86)(cid:87) 4 R4R2 set corresponding to each robot in the custom order except
(cid:53)(cid:53)(cid:82)(cid:69)(cid:23)(cid:82)(cid:87) (cid:94)(cid:44)(cid:3)(cid:81)(cid:53)(cid:70)(cid:21)(cid:79)(cid:42)(cid:88)(cid:71)(cid:22)(cid:72)(cid:3)(cid:96) (cid:36)(cid:70)(cid:70)(cid:49)(cid:66)(cid:82)(cid:70)(cid:3)(cid:82)(cid:17147)(cid:81)(cid:73)(cid:3)(cid:3)(cid:38)(cid:17306)(cid:82)(cid:80)(cid:3)(cid:44)(cid:81)(cid:83)(cid:70)(cid:88)(cid:79)(cid:87)(cid:88)(cid:72)(cid:71)(cid:72)(cid:34)(cid:36)(cid:86)(cid:74)(cid:81)(cid:20)(cid:22)(cid:66)(cid:70)(cid:82)(cid:86)(cid:87) 3 the last one. We see that the set of conflicting paths
(cid:53)(cid:53)(cid:20)(cid:21) (cid:94)(cid:3)(cid:53)(cid:21)(cid:42)(cid:22)(cid:94)(cid:15)(cid:3)(cid:3)(cid:96)(cid:53)(cid:23)(cid:42)(cid:23)(cid:3)(cid:96) (cid:60)(cid:49)(cid:72)(cid:82)(cid:86)(cid:3)(cid:3)(cid:17147)(cid:17147) (cid:3)(cid:3)(cid:38)(cid:51)(cid:82)(cid:82)(cid:86)(cid:80)(cid:87)(cid:83)(cid:83)(cid:82)(cid:88)(cid:81)(cid:87)(cid:72)(cid:72) (cid:20)(cid:351)(cid:20) 2 G3 G1 {R2G3, R4G4} forms a subset of robot R1’s ‘include’
(cid:53)(cid:23) (cid:94)(cid:3)(cid:53)(cid:21)(cid:42)(cid:22)(cid:3)(cid:96) (cid:49)(cid:82)(cid:3)(cid:17147)(cid:3)(cid:38)(cid:82)(cid:80)(cid:83)(cid:88)(cid:87)(cid:72) (cid:20)(cid:22) 1 G4 R1 R3 set {R2G3, R4G4}. Thus, the computation of assignment
(cid:53)(cid:20) (cid:94)(cid:3)(cid:53)(cid:21)(cid:42)(cid:22)(cid:15)(cid:3)(cid:53)(cid:23)(cid:42)(cid:23)(cid:3)(cid:96) (cid:60)(cid:72)(cid:86)(cid:3)(cid:17147)(cid:3)(cid:51)(cid:82)(cid:86)(cid:87)(cid:83)(cid:82)(cid:81)(cid:72) (cid:351)
0 G2 corresponding to the ‘include’ and ‘omit’ sets of R1 is
(cid:79)(cid:69) (cid:70)(cid:73)(cid:66)(cid:68)(cid:86)(cid:74)(cid:81) (cid:44)(cid:81)(cid:70)(cid:79)(cid:88)(cid:71)(cid:72) (cid:50)(cid:80)(cid:76)(cid:87) 0 1 2 3 4 postponed (Figure 2(e): second table). The meta-data of
(cid:20)(cid:21) (cid:94)(cid:3)(cid:53)(cid:21)(cid:42)(cid:22)(cid:15)(cid:3)(cid:53)(cid:23)(cid:42)(cid:23)(cid:3)(cid:96) (cid:94)(cid:3)(cid:53)(cid:20)(cid:42)(cid:20)(cid:3)(cid:96)
(cid:79)(cid:69) (cid:70)(cid:73)(cid:66)(cid:68)(cid:86)(cid:74)((cid:81)e)As(cid:44)(cid:81)s(cid:70)i(cid:79)g(cid:88)(cid:71)n(cid:72)mentPo(cid:50)s(cid:80)tp(cid:76)(cid:87)onement (f)FinalAssignment the postponed assignment are saved for possible future
(cid:20)(cid:21) (cid:94)(cid:3)(cid:53)(cid:21)(cid:42)(cid:22)(cid:15)(cid:3)(cid:53)(cid:23)(cid:42)(cid:23)(cid:3)(cid:96) (cid:94)(cid:3)(cid:53)(cid:20)(cid:42)(cid:20)(cid:3)(cid:96) reinstatement (Figure 2(e): third table). The assignment
computedagainstrobotR2in(Figure2(e):secondtable)has
acostof11andithappenstobethesecondbestassignment
Figure2:ApplyingAlgorithm1onProbleminFigure1(a)
(Figure2(f)).Notably,itisfreefromcollisions,andthus,the
desiredsolution.
NotethatinFigure2(b),thepathsR2G3andR4G4need
Thus, in cases where CBS requires the computation of a an update twice for the same respective set of constraints.
robot-goal path under previously encountered constraints, With path memoization, Algorithm 1 computes both the
we utilize the memoized path instead of recomputing it paths only once, and reuses them during their second
(Algo1:Lines55-58). update. Additionally, utilizing the customized heuristic
distance-based assignment computation (Aakash and Saha
3.2 Example 2022), our approach effectively circumvents the need to
InFigure2,weillustratetheexecutionofAlgorithm1onthe compute four actual costs. The white cells in Figure 1(b)
multi-robotgoalassignmentproblemintroducedinFigure1. reflectthisoptimization.
Specifically, Figure 2(a) showcases the initial robot-goal
3.3 TheoreticalProperties
assignmentthathasanoptimaltotalcostof11.Thearrows
visually map out the respective paths. At timestep 3, a Correctness. Letusreviewthefollowinglemmas.
conflict arises between the paths of robots R2 and R4
Lemma1. Inamulti-robotapplication,ifanassignmentof
withincell(1,2).Algorithm1employsCBStoresolvethis
robotstogoalscontainsasetofconflictingrobot-goalpairs
conflict,generatingasearchtreeasdepictedinFigure2(b).
(oredges)thatescalatestheassignmentcost,thenanyother
The search tree originates from the root node ‘N1’ which
assignmentcontainingthesamesetofconflictingrobot-goal
represents the initial assignment devoid of constraints.
pairswillexperienceatleastanequalescalationinitscost.
Each node within this tree encapsulates three pieces of
information: (a) the assignment’s cost, potentially with Proof. For a particular robot-goal assignment in a
collisions, under specific constraints, (b) value of ‘conflict multi-robot application, consider that there exists a set
registered’ flag (conf reg) which aids in distinguishing of conflicting robot-goal pairs that effectively increases the
and prioritizing nodes having identical costs, and (c) the cost of the assignment during the resolution of conflicts.It implies that there must be some robot ‘r’ whose path optimal to the respective partitions, get computed and
hasconflictwithfewofitsfellowrobot(s)‘J’,anditspath the rest assignment computations get postponed, the GNA
cost increases while attempting to resolve the conflict. An procedure does an additional step. In this step, if a
increaseinthepathcostofrobot‘r’meansthattheredidnot postponed assignment’s lower bound cost becomes lesser
exist any alternative path for ‘r’ that could have prevented than the minimum cost of the computed but unprocessed
the cost increment. Now, in a different assignment, assume assignments,theGNAprocedurerevokesthepostponement
that ‘r’ and its fellow conflicting robots ‘J’ have same and computes the assignment (Algo 2: Lines 41-49). This
assigned goals. In other words, their paths poses the same ensuresthatanyeligibleassignmentisnotmissed,andthus,
conflict, and again, there would not be any alternative path the GNA procedure provides the next best assignment in
for ‘r’ that could prevent the cost increase. Note that ‘r’ termsofcost.
can have additional conflicts due to other robots whose
assignments got altered. Thus, attempting to resolve these Following are the theorems on the correctness of
conflictswouldresultinacostincreasebyatleastthesame Algorithm1.
valueasinthepriorassignment. Theorem1. Algorithm1iscomplete.
Lemma 2. Given the current best assignment (in terms of
Proof. To impose constraints and mitigate collisions,
cost) of robots to goals in a multi-robot application, and a
Algorithm 1 employs CBS which has been shown to be
conflict record comprising of sets of conflicting robot-goal
complete (Sharon et al. 2015). Each root node undergoes a
pairs (or edges) with corresponding cost increments,
CBS search. Incrementally imposing additional constraints
Algorithm 2’s get next assignment procedure computes
gradually diminishes the number of alternative paths with
thenextbestassignment.
optimal costs, eventually leading to an inevitable increase
Proof. From the given current best assignment of robots in the path’s (or node’s) cost. During the CBS search, if
the cost of the tentative next best node appears to exceed
to goals, it is straightforward to derive the set of robots.
the maximum cost among the root nodes, Algorithm 1
Using the given conflict record and the derived set of
proceedstocomputethenextbestassignment.Thisprocess
robots,Algorithm2’sget next assignment(or,GNAfor
can continue until all possible assignments have been
short) procedure creates a custom order of robots, such
enumerated. Thus, the search is exhaustive in both goal
that the robots indulging in any conflict are kept ahead
assignmentandpathplanning.
of the non-conflicting ones. For a set of robots and a
set of goals, an assignment solution space consists of all
Theorem2. Algorithm1providesanoptimalcollision-free
the possible assignments. Together with the current best
solution to the multi-robot goal assignment problem
assignment, the custom order of robots is used for the
(Problem1),i.e.,thepathofeachrobotisfreefromcollision
disjointpartitioningoftheassignmentsolutionspace,rather
andthesumofindividualcostsofallrobotsisminimized.
than using a naive order (like, r ,r ,r ,...,r ) as done
1 2 3 n
in the existing literature (Murty 1968; Chegireddy and Proof. In order to resolve collisions among the robots
Hamacher 1987; Ho¨nig et al. 2018). It has been shown of a multi-robot application, Algorithm 1 applies CBS
that, irrespective of the chosen order, such a partitioning search,whichisshowntobecompleteandoptimal(Sharon
covers the complete solution space minus the current best et al. 2015), on each root node (i.e., assignment). The
assignment(Murty1968). cost of a collision-free solution is always either equal
Two sets of robot-goal edges, namely the ‘include’ set to or greater than the respective root node’s cost (proof:
and the ‘omit’ set are used to determine the partitions. Lemma 1, (Sharon et al. 2015)). During the CBS search in
Whiledeterminingthepartition,anassignmentadheringto a particular tree, if the cost of the tentative next best node
the ‘include’ and ‘omit’ sets is computed that is locally appearstoexceedthemaximumcostamongtherootnodes,
optimal to the corresponding partition. The edges listed in Algorithm 1 proceeds to compute the next best assignment
the‘include’setaresupposedtobepartoftheassignment, by invoking the Algorithm 2’s get next assignment
whereas those in the ‘omit’ set must be excluded. The procedure. From the proof of Lemma 2, it is evident that
populationofthe‘include’settakesplaceincrementally,and the assignments are computed by get next assignment
is thus, influenced by the ordering of robots. The custom procedure in increasing cost order. And Algorithm 1 uses
orderensuresthatthe‘include’setrapidlyaccumulatesthe the best cost-first expansion order of processing the nodes
edgesconsistingofconflictingrobots. fromthepriorityqueueOPEN.
The GNA procedure postpones the computation of
an assignment if its ‘include’ set contains a known Time complexity. Problem 1 has been known to be
set of conflicting edges that would inevitably escalate NP-hard (Yu and LaValle 2013). The worst-case scenario
the assignment’s cost during the resolution of conflicts. is the one in which for a problem instance, all possible
According to Lemma 1, such postponement of assignment assignmentsgetenumerated.Algorithm1doesnotclaiman
computation is valid. A lower bound cost of the deferred improvement over the baseline in terms of the worst-case
assignment is derived by adding the certain cost increase timecomplexity.Nonetheless,theaveragecaseperformance
(duetoconflicts)tothecostofthecurrentbestassignment. of Algorithm 1 is significantly better than the baseline,
After the partitioning of the assignment solution space which is evident from the experimental results shared in
is complete, during which some assignments, locally Section4.2.900 h1m0p0 h0m1p0 h0m0p1 h1m1p1
11080000
h1m0p0 h0m1p0 h0m0p1 h1m1p1
100 100
10 10
1 1
00 1 10 100 900 0 1 10 100 900 0 1 10 100 900 0 1 10 100 900 00 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800
(a)Random(200×200)
900 h1m0p0 h0m1p0 h0m0p1 h1m1p1
11080000
h1m0p0 h0m1p0 h0m0p1 h1m1p1
100 100
10 10
1 1
00 1 10 100 900 0 1 10 100 900 0 1 10 100 900 0 1 10 100 900 00 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800
(b)Warehouse(123×321)
900 h1m0p0 h0m1p0 h0m0p1 h1m1p1
11080000
h1m0p0 h0m1p0 h0m0p1 h1m1p1
100 100
10 10
1 1
00 1 10 100 900 0 1 10 100 900 0 1 10 100 900 0 1 10 100 900 00 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800
(c)Paris(256×256)
900 h1m0p0 h0m1p0 h0m0p1 h1m1p1
11080000
h1m0p0 h0m1p0 h0m0p1 h1m1p1
100 100
10 10
1 1
00 1 10 100 900 0 1 10 100 900 0 1 10 100 900 0 1 10 100 900 00 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800 0 1 10 100 100 10 800
(d)Den(257×256)
Figure3:ComputationTimeComparisonwithBaselineforVariousWorkspaces
(X-axis:Runtime(s),Y-axis:Runtime(s)) (Leftmostfourplots:R=50,Rightmostfourplots:R=100)
4 Evaluation theimplementationissubmittedassupplementarymaterial.
In this section, we present the results obtained from our
Benchmarks and Evaluation Metrics. We evaluate
experimentalevaluationofAlgorithm1.
Algorithm 1 on benchmark workspaces (Sturtevant 2012;
Stern et al. 2019) as well as a randomly generated
4.1 ExperimentalSetup
workspace.Weuseruntimetobetheevaluationmetric.
To assess Algorithm 1, we consider the state-of-the-art We run all the experiments in a desktop machine with
CBS-TA (Ho¨nig et al. 2018) as the baseline. Our approach Intel® CoreTM i7-8700 CPU@3.20GHz processor, 32GB
consists of three pivotal components: (a) Heuristic RAM, and Ubuntu 20.04 OS. We run each experiment for
distance-based assignment computation, denoted by 50timestoreporttheresults.
‘h’, computes the assignments efficiently by trying to
avoid the exhaustive computation of all robot-goal paths 4.2 ExperimentalResults
(unconstrained). (b) Path memoization, denoted by ‘m’,
Throughout our experiments, we take 900s and 1800s as
caches the paths computed under certain constraints
thetimeoutsforthemulti-robotsystemshaving50and100
for future reuse, and (c) Assignment computation
robots,respectively.
postponement, denoted by ‘p’, uses the encountered
conflicts to postpone assignment computations, We use the Algorithm 1 vs. Baseline. In Figure 3, we present the
notations h, m, and p in the forthcoming plots. Here are runtime scatter plots for the comparison between different
a few examples of what they represent: h0m0p0: denotes approaches. The X-axis represents the runtime (s) of the
the baseline in which none of the three enhancements baseline(h0m0p0),whiletheY-axisdisplaystheruntime(s)
are present, h0m0p1: denotes the partially enhanced of the labeled approach. The number of robots is denoted
version consisting of only the postponement of assignment by R. The first four scatter plots in each row are for
computation,andh1m1p1:denotesourapproachconsisting R = 50 whereas the last four are for R = 100. The
of all the three enhancements. We implement the baseline red horizontal and vertical lines indicate the timeout. The
and our proposed algorithm in Python. The source code of crossover point of the runtimes is depicted by the red900 1800 variationsthatimplementonlyasingleenhancement.
1000
100 Ablation Study. In Figure 4, we use comparative violin
100
plots to perform an ablation study of the three key
10 10 enhancements that we incorporate into our approach. We
1 1 present the comparative violin plots for two scenarios
within each workspace: one with 50 robots (left side
0 h0m1p1h1m0p1h1m1p0h1m1p1 0 h0m1p1h1m0p1h1m1p0h1m1p1 plot) and another with 100 robots (right side plot).
(a)Random(200×200) The X-axis represents the following approaches: h0m1p1,
h1m0p1, h1m1p0, and h1m1p1 (see Section 4.1 for their
900 1800
1000 interpretation). The Y-axis represents the runtime (s) of
100 the four approaches. The red horizontal line marks the
100
timeout. The white dot within the embedded box plot in
10
10 a violin indicates the median. The density of the data
1 points in reflected by the width of the violin. Across all
1
cases, the median and the width of the violins collectively
0
0 show that our approach (h1m1p1), without removal of any
h0m1p1h1m0p1h1m1p0h1m1p1 h0m1p1h1m0p1h1m1p0h1m1p1
enhancement,hasthemostoptimizedperformance.
(b)Warehouse(123×321)
900 1800 Scalability Analysis. In Figure 5, we vary three
1000
parameters, namely, the number of robots R, the obstacle
100
100 densityOD,whichrepresentsthepercentageofworkspace
10 10 cellsthatareoccupiedbyobstacles,andtheworkspacesize
tocomparetheruntimeofourapproach(h1m1p1)withthat
1 1 ofbaseline(h0m0p0).
0 0
h0m1p1h1m0p1h1m1p0h1m1p1 h0m1p1h1m0p1h1m1p0h1m1p1 5 Conclusion
(c)Paris(256×256)
We have presented a centralized algorithm to solve the
900 1800
1000 multi-robot goal assignment problem while optimizing the
100 totalcostofmovementofalltherobots.Thepathsassigned
100
to the robots by our algorithm are free from collisions. We
10 10 haveconsideredtheestablishedCBS-TAasthebaselinefor
the evaluation of our algorithm. Our experimental results,
1 1
in particular, the scatter plots, reflect that our approach
0 0 outperforms the baseline by an order of magnitude for
h0m1p1h1m0p1h1m1p0h1m1p1 h0m1p1h1m0p1h1m1p0h1m1p1
almostallthecases.
(d)Den(257×256)
Ouralgorithmcanalsobeappliedtooptimizemakespan
Figure4:AblationStudyforVariousWorkspaces whilesolvingthecollision-freemulti-robotgoalassignment
(X-axis:Approaches,Y-axis:Runtime(s)) problem. To achieve this, the assignment computation
(Left:R=50,Right:R=100) module, currently focusing on optimizing total cost, needs
to be replaced by the assignment computation module
thatoptimizesmakespan(Fulkerson,Glicksberg,andGross
200 10 30
h1m1p1 h1m1p1 h1m1p1 1953;Gross1959).
150 h0m0p0 h0m0p0 h0m0p0
20
100 5 References
10
50 Aakash; and Saha, I. 2022. It Costs to Get Costs! A
0 20 40 60 80 100 010 15 20 25 050 100 150 200 Heuristic-Based Scalable Goal Assignment Algorithm for
Number of Robots Obstacle Density Workspace size Multi-RobotSystems. InICAPS,2–10.AAAIPress.
(a)VaryingR (b)VaryingOD (c)VaryingWSsize
Chegireddy,C.R.;andHamacher,H.W.1987. Algorithms
Figure5:ScalabilityComparisonbetweenBaseline for Finding k-Best Perfect Matchings. Discrete applied
(h0m0p0)andOurApproach(h1m1p1)
mathematics,18(2):155–165.
(a)OD =20%,WS :200×200 Chen, Z.; Alonso-Mora, J.; Bai, X.; Harabor, D. D.; and
(b)R=50,WS :100×100 Stuckey, P. J. 2021. Integrated Task Assignment and Path
(c)R=50,OD :20% PlanningforCapacitatedMulti-AgentPickupandDelivery.
IEEERoboticsandAutomationLetters,6(3):5816–5823.
Das, S. N.; Nath, S.; and Saha, I. 2021. OMCoRP: An
diagonalline.Weobservethatacrossallcases,ourapproach OnlineMechanismforCompetitiveRobotPrioritization. In
(h1m1p1) outperforms the baseline (h0m0p0) and the other ICAPS,112–121.
)sdnoces
ni(
emitnuR
)sdnoces
ni(
emitnuR
)sdnoces
ni(
emitnuREppstein, D. 2016. Encyclopedia of Algorithms, Chapter Turpin, M.; Mohta, K.; Michael, N.; and Kumar, V. 2013.
k-BestEnumeration. Springer,680:1003–1006. GoalAssignmentandTrajectoryPlanningforLargeTeams
ofAerialRobots. InRSS.Berlin,Germany.
Fulkerson,D.R.;Glicksberg,I.L.;andGross,O.A.1953.
A Production-Line Assignment Problem. Santa Monica, Turpin, M.; Mohta, K.; Michael, N.; and Kumar, V. 2014.
California:TheRandCorporation. Goalassignmentandtrajectoryplanningforlargeteamsof
interchangeablerobots. Auton.Robots,37(4):401–415.
Gonzalez-de-Santos,P.;Ribeiro,A.;Fernandez-Quintanilla,
C.; Lopez-Granados, F.; Brandstoetter, M.; Tomic, S.; Yu,J.;andLaValle,S.2013. StructureandIntractabilityof
Pedrazzi, S.; Peruzzi, A.; Pajares, G.; Kaplanis, G.; OptimalMulti-RobotPathPlanningonGraphs.Proceedings
Perez-Ruiz, M.; Valero, C.; del Cerro, J.; Vieri, M.; of the AAAI Conference on Artificial Intelligence, 27(1):
Rabatel, G.; and Debilde, B. 2017. Fleets of robots for 1443–1449.
environmentally-safe pest control in agriculture. Precision
Agriculture,18:574–614.
Grippa,P.;Behrens,D.A.;Wall,F.;andBettstetter,C.2019.
Drone delivery systems: job assignment and dimensioning.
Auton.Robots,43(2):261–274.
Gross, O. 1959. The Bottleneck Assignment Problem.
Technical Report P-1620, The Rand Corporation, Santa
Monica,California.
Ho¨nig,W.;Kiesel,S.;Tinka,A.;Durham,J.;andAyanian,
N. 2018. Conflict-Based Search with Optimal Task
Assignment. InAAMAS,757–765.
Kuhn, H. W. 1955. The Hungarian Method for the
Assignment Problem. Naval research logistics quarterly,
2(1-2):83–97.
Li,J.;Tinka,A.;Kiesel,S.;Durham,J.W.;Kumar,T.K.S.;
andKoenig,S.2021. LifelongMulti-AgentPathFindingin
Large-ScaleWarehouses. InAAAI,11272–11281.
Ma, H.; and Koenig, S. 2016. Optimal Target Assignment
and Path Finding for Teams of Agents. In AAMAS,
1144–1152.
Murty, K. G. 1968. An Algorithm for Ranking all the
Assignments in Order of Increasing Cost. Operations
Research,16(3):682–687.
Sharon, G.; Stern, R.; Felner, A.; and Sturtevant, N. R.
2012. Conflict-BasedSearchForOptimalMulti-AgentPath
Finding. InAAAI,563–569.AAAIPress.
Sharon, G.; Stern, R.; Felner, A.; and Sturtevant, N. R.
2015. Conflict-Based Search for Optimal Multi-Agent
Pathfinding. ArtificialIntelligence,219:40–66.
Stern,R.;Sturtevant,N.R.;Felner,A.;Koenig,S.;Ma,H.;
Walker,T.T.;Li,J.;Atzmon,D.;Cohen,L.;Kumar,T.K.S.;
Boyarski,E.;andBartak,R.2019.Multi-AgentPathfinding:
Definitions,Variants,andBenchmarks. SoCS,151–158.
Sturtevant, N. 2012. Benchmarks for Grid-Based
Pathfinding. Transactions on Computational Intelligence
andAIinGames,4(2):144–148.
Tian, Y.-T.; Yang, M.; Qi, X.-Y.; and Yang, Y.-M.
2009. Multi-robot task allocation for fire-disaster
response based on reinforcement learning. In 2009
International Conference on Machine Learning and
Cybernetics,volume4,2312–2317.
Turpin, M.; Michael, N.; and Kumar, V. 2013. Concurrent
assignment and planning of trajectories for large teams of
interchangeablerobots. InICRA,842–848.