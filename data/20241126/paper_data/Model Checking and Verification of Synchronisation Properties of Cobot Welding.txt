Model Checking and Verification of
Synchronisation Properties of Cobot Welding
YvonneMurray HenrikNordlie
PioneerRoboticsAS RoboticsGroup,FacultyofScience&Technology
Dept.ofMechatronics,UniversityofAgder NorwegianUniversityofLifeSciences(NMBU)
Norway Norway
ym@pioneer-robotics.no
DavidA.Anisi PedroRibeiro AnaCavalcanti
Dept.ofMechatronics,UniversityofAgder Dept.ofComputerScience Dept.ofComputerScience
RoboticsGroup,FacultyofScience&Technology UniversityofYork UniversityofYork
NorwegianUniversityofLifeSciences(NMBU) UK UK
Norway
Thispaperdescribesuseofmodelcheckingtoverifysynchronisationpropertiesofanindustrialweld-
ingsystemconsistingofacobotarmandanexternalturntable.Therobotsmustmovesynchronously,
butsometimesgetoutofsynchronisation,givingrisetounsatisfactoryweldqualitiesinproblemar-
eas,suchasaroundcorners. Thesemistakesarecostly,sincetimeislostbothintheroboticwelding
andinmanualrepairsneededtoimprovetheweld. Verificationofthesynchronisationpropertieshas
shownthattheyarefulfilledaslongasassumptionsofcorrectnessmadeaboutpartsoutsidethescope
ofthemodelhold,indicatinglimitationsinthehardware. Theseresultshaveindicatedthesourceof
theproblem,andmotivatedare-calibrationofthereal-lifesystem. Thishasdrasticallyimprovedthe
weldingresults,andisademonstrationofhowformalmethodscanbeusefulinanindustrialsetting.
1 Introduction
Roboticweldingiscommonlyusedinindustrialworkshopstoincreaseefficiencyandrepeatability,and
reduce dangerous and ergonomically straining work for human welders [12]. To address the needs of
smallandmedium-sizedenterprises(SMEs),whichproducealargevarietyofproductsinsmallquanti-
ties, the welding system must be easy and fast to re-program, and highly flexible. To this end, Pioneer
RoboticshavedevelopedtheIntelliWelderM06[17],aflexibleandlight-weightweldingsystemconsist-
ing of a Universal Robots (UR) UR10e cobot [8] equipped with a welding torch and a Carpano FIVE
MOTturntableservingasanexternalaxis(EXAX).Fig.1showsthecomponentsoftheIntelliWelder.
ThemainchallengeintheoperationoftheIntelliWelderM06hasbeentogetahighquality,continuous
weld in difficult areas, such as around corners. To get the best results, it is important that the welding
robot and the turntable move continuously in a synchronous fashion. By using synchronous welding, it
ispossibletoachieveacontinuousweldofhighquality,ensuringtheweldisnotjaggedandinterrupted.
When the synchronisation does not work properly, the welding gun does not move forward in an even
motion, and can move too fast or too slow. Moving too fast does not give the metal and filler enough
time to heat up and weld together, while moving too slow results in build-up of filler material. Both of
theseproblemscanbeseeninthewelddepictedinFig.2.
This experience report describes how we have addressed some challenges faced when the UR robot
andtheEXAXmovesynchronouslywhilewelding. Relevantpartsofthesystemhavebeenmodelledin
MattLuckcuckandMengweiXu(Eds.):
©Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti
SixthInternationalWorkshoponFormalMethods
Thisworkislicensedunderthe
forAutonomousSystems(FMAS2024)
CreativeCommonsAttributionLicense.
EPTCS411,2024,pp.91–108,doi:10.4204/EPTCS.411.692 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
Figure1: TheIntelliWeldersystemwiththedifferentcomponentsmarkedbynumber[16].
Figure 2: Typical welding issue where there is buildup of filler material (A) and coverage is not sufficient (B),
creatinganirregularandweakenedweld.
RoboChart[14],adomain-specificlanguageformodellingandverificationofroboticsystems. Usingour
RoboChartmodel,keysynchronisationpropertieshavebeenverifiedusingtherefinementmodelchecker
FDR [25]. Details omitted here are in [16]; the work demonstrates how formal verification can be used
inindustry,andhowtheresultscanbeusedtolocalisetheerrorsource,leadingtosystemimprovements.
Previousresearchonmulti-robotweldinginclude[20],whichfocusesonnominaltrajectoryplanningand
self-coordination,and[27],whichstudiestrajectorysmoothinginadual-robotcollaborativeweldingsys-
tem. Neither of these lines of work use formal methods or model checking. Closer to our research, the
workin[19]combinesgraphicandformalmethodstoanalysecollaborativebehavioursuchasdeadlock
andequivalenceproperties. Noneoftheseworks,however,considertheissueofcorrecttimesynchroni-
sationduringmulti-robotexecutionlikewedoinourcasestudy.
Therestofthispaperisorganisedasfollows. InSection2, wemotivateouruseofformalmethodsand
model checking. In Section 3, we detail the system architecture and requirements, before the model is
presented in Section 4. In Section 5, we present the verification results and their practical implications.
Finally,inSection6,weconclude,describeongoingwork,andsuggestfurtherwork.Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 93
2 Formal Verification and Model Checking
To find and mitigate faults and undesired behaviour in robotic systems, they are traditionally subject to
testing, including simulation before deployment. For real-world, complex robotic systems, however, it
isimpossibletotesteverypossiblescenarioandinputsequence. Moreover,evenifafaultisdiscovered,
error source localisation remains a challenge. In this setting, formal verification methods are a useful
supplement. Model checking [1, 7] is a formal method to verify that given properties are fulfilled,
regardless of inputs. If a property does not hold, model checking provides a counterexample that can
pinpointthecauseoferror. Adoptingsuchmethodsisvaluableinthedesignofreal,industrialsystems.
RoboTool [14] is a suite of plugins for the Eclipse IDE supporting use of the RoboStar framework [5].
Our previous work on verification of an industrial control system [15] using RoboStar has shown its
proficiency and strengths. In RoboStar, a key artefact is a RoboChart [13] model that reflects the real
system design. Once this model is created, assertions for the selected properties can be written and
verifiedusingtheCSPprocessalgebraanditsmodelchecker,FDR[10].
AsourusecaseconsidersanalreadyexistingIntelliWeldersystem,weneedtoaltertheidealisedwork-
flowofRoboStar[5]byeffectively"reverseengineering"theRoboChartmodelfromtheexistingsystem.
3 IntelliWelder and Synchronous Welding
In this section, we describe our case study: its architecture (Section 3.1), software (Section 3.2), and
requirements(Section3.3),identifyingtheproblemweareaddressingwithmodelchecking.
3.1 SystemArchitecture
AnillustrationoftheIntelliWelder’sarchitecturecanbeseeninFig.3. Torealisesynchronouswelding,
DelfoiofflinerobotprogrammingsoftwarefromVisualComponents[26]isusedforcreatingwaypoints
andweldsina3DlayoutconsistingoftheUR10e[22],theCarpanoFIVEturntable,andtheworkpiece
tobewelded. WeldsarecreatedsimplybyselectinganedgeontheworkpieceCADmodel. Delfoithen
creates waypoints for both the UR robot and the Carpano turntable, so that each waypoint for the robot
hasacorrespondingwaypointfortheturntable,creatingnominallysynchronisedmovements.
Figure 3: System architecture of the IntelliWelder. The blue dotted line indicates the scope of the RoboChart
model:partoftheIndustrialPC(IPC),theReal-TimeDataExchange(RTDE)fortheURrobot,andtheURScript.
The waypoint paths generated in Delfoi are transferred to the Industrial PC (IPC). The waypoints are
then processed to convert them into trajectories based on the desired forward welding speed and other94 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
welding parameters. The waypoints for the external axis remain unchanged and are converted into a
trajectory, while the waypoints for the UR robot are sampled at a higher resolution before being turned
into its trajectory. Consequently, the UR robot has more waypoints to process than the Carpano FIVE.
Oncethetrajectoriesaregenerated,theIPCsendsthemasmovementrequestsforthesystemtoexecute.
The Carpano FIVE is controlled by a Programmable Logic Controller (PLC) that receives movement
commands from the IPC. These commands can be based on position and velocity, or just velocity. The
PLCthenregulatesmovementusingaPID.TheReal-TimeDataExchange(RTDE)synchronisesexternal
applications with the UR robot [23]. It relays messages from the IPC to the UR robot via a TCP/IP
connection. TheURrobotcontrollerexecutesURScriptapplicationsandmanagesmovementviaaPID.
3.2 ExistingURScriptcode
In the current implementation, every time a movement request for the UR robot arrives, the URScript
code runs on the UR controller. Required variables are read from the registers, updated by the RTDE,
andthecodechecksifthetargettimeforthenextwaypointhasalreadypassed(thatis,therobotisbehind
schedule). Ifso,thecodelogsawarningandcontinuestothenexttarget.
Next, the URScript decides which movement type is preferable to reach the next waypoint, based on
variables like blend radius, offset, joint velocities, and whether the next movement involves a sharp
turn. The script selects between MoveJ, MoveL and MoveP, which are standard UR robot movements
described in the user manual [24]. However, if none of the standard movement types are suitable, a
custom-madefunctioncalledMoveL_with_tisusedforthemovement. ThecustomURScriptfunction
MoveL_with_t uses the standard MoveL command with the next target pose and next target time as
arguments. Inthatway,theURrobotcancalculatethenecessaryvelocitytoreachthenexttargetwithin
the target time, using maximum acceleration. The reason for this being a fallback solution, only used
whenthestandardmovementsarenotfeasible,isthatitdoesnotincludeablendradius.
Withablendradius,weensurethatwhentheURrobotiswithinagivendistanceofthewaypoint,itstarts
movingtowardsthenextwaypointinsteadofcompletelyfinishingthemovetothecurrentwaypoint. So
instead of coming to a brief stop at the waypoint, it keeps moving towards the next, giving a smoother
transition. Lackofablendradiusresultsinajaggedmovementthatisnotidealforwelding.
Thenextsectiondescribestherequirementsthatthedesignjustpresentedisexpectedtosatisfy.
3.3 Requirements
Wepresentherebothsystemrequirements(inSection3.3.1),andrequirementsspecificallyforthecom-
ponentsthatwemodelasdescribedinFigure3(inSection3.3.2).
3.3.1 System-WideRequirements
There are several requirements for the IntelliWelder system as a whole, discussed in detail in [16]. The
mostimportantoftheserequirementsarethefollowingtwo:
1. The welding torch must always stay in an area defined by a maximum deviation from the weld
frame. Thisincludesbothpositionandorientation.Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 95
2. Theweldingtorchmustalwaysmoveforwardintheweldframewithaspeedthatiswithinagiven
maximumdeviationofthedesiredforwardweldspeed.
TheserequirementsneedtoberefinedintospecificrequirementsforDelfoi,theIPCplanner,thecalcula-
tionofargumentsfortherobotcommands, andtheexecutionofmovements. Additionally, theyexpand
toincluderequirementsrelatedtoinformationcommunicationandcodeexecutiontime.
3.3.2 ModelRequirements
Withthesystemwiderequirementsinmind,thefollowingrequirementsforthemodelledcomponent(see
Figure3)canbeobtained,asdescribedindetailin[16]:
R1Thecomponentshoulddetecteventsthatimplythatthesystemisoutofsync.
R2 For each movement request received from the IPC, the corresponding robot should receive a move-
mentcommandunlessthesystemisoutofsync.
The requirements R1 and R2 above are the properties we verify using model checking. If some of the
assertionsfail,itcanhelptopinpointexistingmistakesinthesoftware. Ifallassertionspass,itindicates
thatsomeoftheassumptionsmadeonthecomponent’scontextandthehardwareareinvalid.
To check the hardware, two different cases are evaluated: one where it is impossible for the robot to
receive a waypoint that is already in the past (nominal case), and one where that is possible (realistic
case). If the model checking results vary between the two, for example, if the assertions pass in the
nominal case (which assumes the hardware is able to keep to the planned trajectory) but fail in the
morerealisticcase,itisanindicationthatassumptionsaboutvelocities,accelerations,andperfectmove
execution,madeonthereal-lifesystem,areinaccurate. Werecallthatthesystemdoespresentaproblem.
So,iftheproblemisnotpresentwhenthehardwareexecutestheplannedtrajectory,thenwecanconclude
thatourassumptionsaboutthehardwarearenotsatisfied,andso,inaccurate.
Inthenextsection,wepresenttheRoboChartmodelweusetocarryoutourverification.
4 Modelling in RoboChart
OurRoboChartmodelreflectsthesystemarchitecturealreadydescribed,andtheexistingcodeandspec-
ifications. Any possible communication delays are assumed to be handled separately and are hence
negligibleforourpurposeshere. Thecomponentsmodelledreceivemovementrequestsasinputs. Thus,
trajectoryplanningisoutsideofthemodel’sscopeandthefeasibilityofplannedtrajectoriesisassumed.
As previously noted, the number of waypoints differs for the UR robot and the Carpano FIVE, so both
areexpectedtoreceiveandexecutecommandsconcurrentlyandindependently. Intermsofcontrolflow,
themodel’sscopeextendsuntilthepointwherethesemovementcommandsareinitiatedfortheCarpano
FIVE and the UR robot. From that point, they handle the execution of movements. We expect and
assumethattheactualexecutionofmovementcommandsbytheURrobotandCarpanoFIVEiscorrect
and,therefore,thatisalsobeyondthemodel’sscope.
Thedefinitionofthemodel’sscopereflectsthefactthatourgoalistocheckthatouruseoftheCarpano
FIVEandURrobotcommandsisappropriate. Therefore,intheRoboChartmodel,thesecommandsare
capturedasservicesoftheroboticplatform,whichwedonotfurtherspecify.96 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
The component modelled is responsible for selecting the most appropriate movement type for each re-
quest. It also detects if the system is out of sync, meaning the target time for a movement request has
already passed, resulting in a negative time budget. In the model, this is indicated by the occurrence of
anout-of-syncevent,andisconsideredacriticalfailure.
Next, we justify the abstractions and simplifications made in the RoboChart model (Section 4.1), and
thenpresenttheRoboChartmodelitself(Section4.2).
4.1 AbstractionsandSimplifications
Itiswell-knownthatmodelcheckingeventuallyencountersstate-explosionproblems. Tokeepthecom-
plexityandverificationtimeatbay,thefollowingabstractionsandsimplificationshavebeenmade.
Reduction of number of joints: The Carpano FIVE turntable has two joints, one for tilting and one
for turning. The IntelliWelder, however, only uses the turning axis during the synchronous welding.
Thus, this is the only axis that is considered in the model. The UR robot has six rotational joints, but it
is modelled with only two. Although this selection can be made arbitrarily, selecting one from the first
three joints (to represent position) and the other from the last three joints (to represent orientation) is
advocated. By modelling two axes, the model still captures potential problems related to multiple joint
values. Extending the model to include six axes affects the computational complexity of the model, as
it would lead to additional parameters of operations (explained in the next section). These operations,
however,arenotfurtherspecifiedastheyrepresentservicesthatareoutofthescopeofourverification.
So,additionalparametersarenotrelevantfortheverification,butjustthefactthattheyareavailable.
Limited value ranges: To decrease the computation time and complexity, the value ranges of the
variablesoftypereal,recordingdistance,arelimited. Tocoverbothnegative,positive,andzero-values,
theintegerrange[-1..1]hasbeenchosen. Similarly,theintvariablesrecordingdiscretetimearelimited
tothetworanges[0..2]and[-1..1]. Withthefirstrange,withonlypositivevalues,theassumptionisthat
theURrobotandEXAXareneversolatethatthenextwaypointisalreadyinthepast. Whenanegative
value -1 is included, we can check whether the goal time for the next waypoint has passed. Lastly, the
variablesrecordingthecurrentwaypointfortheURrobotandtheturntable,ofdatatypenat,arelimited
totheranges[0..3]and[0..1],respectively. So,themaximumnumberofwaypointsfortheURrobotare
4andfortheturntable2,capturingthatthenumberofwaypointscanvaryintherealsystem.
Omittedvariables: SomevariablesdefinedintheURScriptarenotusedinthemodeltominimizethe
number of variables. For instance, current and target positions are not included if they are only used to
calculateadistance. Instead,thedistanceisinputdirectly. Adoptingasimilarapproach,othervariables
areomittedorgivenabooleanratherthananumericaltypetoreducethestatespace.
4.2 RoboChartModel
In writing a RoboChart model, a key decision is the definition of events and operations that capture
services of the robotic platform. The previous section describes our assumptions, some of which are
reflected in these definitions. These services are not further specified and establish the interface of the
model. Propertiesaredescribedintermsofinteractionwiththemodelledcomponentviatheseservices.Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 97
Fig. 4 shows the robotic platform of our model (on the right), with three input events (start_system,
next_UR_move and next_EXAX_move) and the five operations that can be called (four operations
in ur_ops and one in exax_ops). The events, declared in the events interface, are used to initiate the
system and send new move requests as previous moves are completed. The operations are defined in
twoseparateinterfaces:ur_opsandexax_ops,correspondingtothemovecommandsthatareexecuted
by the UR robot and the Carpano FIVE. Although the model declares one robotic platform, it captures
servicesofboththerobotandtheturntableusedbythesoftware.
Figure4:Roboticplatformwithitsdefinedevents,providedoperationsandcustomrecordtypestorepresentmove
commands.
Module A RoboChart model is defined by a module block, including the robotic platform and, in
our case, one controller block, as shown in Fig. 5. Our module is called main, and the behaviour of
our controller is defined by five parallel state machines, acting over the events and operations of the
roboticplatformasdeclaredinthreerequiredinterfacesandreflectedinconnectionsbetweentherobotic
platformandthecontroller(arrowsbetweentheblocksannotatedwithasync).
ARoboChartcontrollerdefineshowtheeventsoftheroboticplatformconnecttoitsstatemachines. In
ourexample,start_systemisusedbythemachinecalledSystem. Theothertwoeventsareusedbythe
machinestate_check. Acontrolleralsodefineshowitsstatemachinesareconnectedtoeachother, via
their events, to exchange information and synchronise their behaviour. In Fig. 5, the Controller block
includes five blocks, each a reference to one of its state machines, as indicated by the keyword ref. In
whatfollows,wepresentthedefinitionofthesemachines.
TheSystemstatemachine ItsdefinitionisshowninFig.6. IneachstateofSystem,asharedvariable
sys_state is updated to record the current state of the system. This variable is used in the state_check
machinepresentedlatertodecidewhetherornotamovementrequestshouldbeforwardedtotheEXAX
ortotheURstatemachine,thatistotheturntableortotheURrobot.
The initial junction, a black circle with an i, indicates wait_for_start as the initial state of System,
where it waits for the event start_system. When start_system happens, System moves to the working
state, where it stays until either the UR robot or the EXAX finishes all of their waypoints, as indicated98 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
Figure5: MainmoduleincludingtheControllerwithallstatemachinesandtheroboticplatform.
by eventsUR_done and EXAX_done, or an out_of_sync event occurs. An out_of_sync event, from
anyofthestatesworking,UR_finishedorEXAX_finished,resultsinatransitiontothefinalstate: white
circlewithanF.ThismeansthattheSystemstatemachinecannotprogressfurther.
IfbothUR_doneandEXAX_doneoccur, regardlessofinwhichorder, Systemgoesthrougheitherthe
stateUR_finished(iftheURrobotfinishesfirst)orEXAX_finished(iftheEXAXfinishesfirst),before
goingbacktowait_for_start. Thisistheendofaweldingoperation.
The EXAX state machine Its definition, shown in Fig. 7, captures the behaviour of the turntable.
EXAX starts in the wait_for_move state, waiting for a move command. The variable curr_waypoint
is initialised to 0, and with the constant n_waypoints defined as 1, as in Fig. 7, the turntable goes
throughtwowaypoints. WhenEXAXreceivesamoveevent,itstorestherequesteddistanceandtimeto
move in a variable exax_move. In the junction (dark circle), it is checked if the time of the movement
request (exax_move.time) is strictly negative. If it is, an out_of_sync event is triggered and EXAX
terminates. Otherwise, EXAX moves to a state by_position, where the operation go_to_pos is called
using as arguments the values in exax_move. If curr_waypoint is greater or equal to n_waypoints,
curr_waypoint is reset and the done event is triggered. This is then relayed, by the controller, to theY.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 99
Figure6: Systemstatemachine.
SystemstatemachineviaitseventEXAX_done. (SystemthentransitionstoitsstateEXAX_finished).
The UR state machine It is defined in Fig. 8 to model the behaviour of the UR robot, and is similar
to EXAX (Fig. 7). The same method of counting and incrementing waypoints is used, and the done
and out_of_sync events are used in the same way. The UR robot, however, chooses the most suitable
movementtype,sochoose_cmdismorecomplexthantheby_positionstateofEXAX.
Upon entering the choose_cmd state, the boolean variable choosing is set to true. This ensures that
a move command must be chosen before leaving the state, since the only transition out of the state
choose_cmdhasaguardthatrequiresthevalueofchoosingtobefalse.
Whichmovecommandischosendependsonwhetherornotthemoverequestincludesblending,alarge
offset from the ideal path (set to 0.8mm in our use case), or a sharp corner. The first junction checks
whether the move request includes a blend radius or not, that is, whether ur_move.blending is true or
false, where the variable ur_move records the data associated with the move request as defined in the
transitionoutofwait_for_move. Ifitdoesincludeablendradius,thenextjunctioncheckswhetherthe
moverequestincludesalargeoffset(ur_move.large_offset).
Iftheoffsetissmallerthanthethreshold,moveJischosen:URtransitionstothemoveJstate,wherethe
operation of the same name is called and the variable choosing is set to false in the exit action. With100 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
Figure7: EXAXstatemachine
that choose_cmd is exited. If the offset is large, the next junction checks whether the move request
containsasharpcornerornot(ur_move.sharp_corner). Ifitdoesnot,movePissuitable,butifitdoes,
it is necessary to use moveL_with_t. In each case, like for moveJ, the entry action of a state calls the
right operation and the exit action updates choosing. If the move command does not include blending,
thesystementersthebig_dist_checkstateaftertheveryfirstjunction. Intheentryactionofthatstate,
thecheck_big_distfunctionchecksiftheabsolutevalueofeitherofthejointdistancesislargerthana
given value (in the example, 1), since the distance determines if moveL is sufficient. If the distance is
short,amoveL_with_tcommandisissuedinthestateofthesamename.
Theout_of_sync Relaystatemachine Itissimpleandomittedhere;itrelaystheout_of_syncevent
from the EXAX and UR to System. This is necessary just because RoboChart prohibits connecting two
differenteventstothesameinputofanothermachine. Fulldetailscanbefoundin[16].
The state_check state machine It is defined in Fig. 9 and has a single state checker with two self-
transitions. They are triggered by events that accept and record a move command in local variables
ur_move or exax_move depending on whether the UR or the EXAX received a move request (whether
aninputeventur_move_inorexax_move_inhappens).
The guards of the transitions ensure that these inputs are accepted only if the system is in a state where
the move command should be forwarded to the UR or EXAX machines. There are only two states
wheretheyshouldmove:statesworkingorEXAX_finished, fortheeventur_move_in, andworkingor
UR_finished, for exax_move_in. In the actions of the transitions, if a move request for the UR robot
arrives, it is forwarded to the UR state machine. Similarly, a move request for EXAX is forwarded to
the EXAX state machine. With the guards in the transitions, the state_check machine ensures that no
moveoperationscanbeexecutedbeforethesystemhasstarted,andthatoncearobothasreachedallits
waypoints,nofurthermoveoperationscanbeexecuteduntilthesystemisresetandrestarted.Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 101
Figure8: URstatemachine.
5 Model Checking
Inthissection,wedescribethemodelcheckinganditsresults:thedefinedpropertiesandassertions(Sec-
tion5.1),theresultsfromFDR(Section5.2),andtheirimplicationsforthereal-lifesystem(Section5.3).
5.1 VerificationofSelectedProperties
BasedontherequirementsfromSection3.3,assertionscanbeformulatedinnaturallanguage,andlater
definedintock-CSP,whichisadialectoftheprocessalgebraCSPwheretheeventtockmarksthepassage
ofdiscretetime. Tothisend,thefollowingpropertiesaretobevalidatedthroughmodelchecking[16]:
• Every time an EXAX_move or UR_move input event is triggered by the robotic platform, the
corresponding movement operation for EXAX or UR, respectively, is called. This is captured in
assertion A1andA2forEXAX,andinassertion A3andA4forUR.
• TheEXAXstatemachineandtheURstatemachinedonotterminate. Thisiscapturedinassertion
A5andinassertion A6,respectively.
• Ifnoout_of_synceventoccursintheSystemstatemachine,thestatemachinedoesnotterminate.
Thisiscapturedinassertion A7.102 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
Figure9: StatemachineresponsibleforrelayingthemovecommandsoftheURandEXAXonlyifSystemisina
statewherethosestatemachinesshouldreceivecommands.
Alltheassertionsdescribedabovearedetailednext.
AssertionA1 WepresentinListing1theRoboToolscriptdefiningassertion A1. Withthat,RoboTool
can use FDR to check whether the assertion holds or not. FDR usestock-CSP processes that define the
semantics of the state machines presented in the previous section. Thesetock-CSP processes are auto-
maticallycalculatedbyRoboTool. ThescriptsarewritteninamixtureofnaturallanguageandCSP.
AsdefinedinListing1,assertion A1requiresthatEXAX refines SpecA1 in the traces model,
online8. Thismeansthatassertion A1requiresthetracesoftheprocessEXAXforthemachineofthe
samenametobealsotracesoftheprocessSpecA1definedinlines1-7.
1 timed csp SpecA1 csp-begin
2 Timed (OneStep) {
3 SpecA1 = let
4 Def = (CHAOS(Events) [| {|EXAX::move.in|} |>
5 ADeadline({|EXAX::go_to_posCall|}, 0)); Def
6 within timed_priority(Def) }
7 csp-end
8 timed assertion A1: EXAX refines SpecA1 in the traces model.
Listing1: DefinitionofSpecA1andassertion A1.
SpecA1 is defined directly in CSP, as indicated in lines 1 and 7. Moreover, it is defined within a Timed
section(line2). So,itisatock-CSPprocess. Itisgivenbytheequationinline3.Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 103
The definition of SpecA1 uses a let-within construct. In the let clause, a process Def (lines 4-5) is
defined. In the within clause, it is used to define SpecA1 using a timed_priority function. This is
just a technicality of FDR: timed_priority enforces the understanding oftock as a special event that
marksthepassageoftime. So,thebehaviourofSpecA1isreallythatofDef.
ThebehaviourofDefisinitiallythatofCHAOS(Events),aprocessthatallowsanyeventtooccur. Itcan,
however,beinterrupted(operator[| ... |>])bytheCSPeventEXAX::move.in,whichrepresentsthe
inputmove. Uponinterruption,thebehaviourofDefisgivebyADeadline. ThisisaparameterisedCSP
process defined in the RoboTool tock-CSP mechanisation [2] that takes a set of events and a deadline,
given as a number of tock events, as arguments. It requires that one of the events in the provided set,
in this case only EXAX::go_to_posCall, the CSP process representing a a call to go_to_pos, occurs
within the deadline, which here is set to 0. Thus, the call to the go_to_pos operation is required to
happenimmediatelywhentheEXAX::move_ineventoccurs.
Assertion A2 For assertion A1 to be meaningful, it is necessary to ensure that the EXAX state
machineistimelock-free,duetothetrivialcasewheretheprocessrefusestheeventtock. Thisischecked
withassertion A2. Listing2showsthedefinitionofA2,whereEXAX2online3isdefinedasaversion
ofEXAXinwhosetracestheeventsEXAX::go_to_posCallareignored(usingthehiddenoperator:\ ).
Thisisdonebecausethemachinecantimelockinthecalltothatoperation,thatis,refusethetockevent.
Thisisbecausethatcall,beinginanentryaction,isurgent,anddeadlinescreatepotentialtimelocks. In
tock-CSP,whenadeadlineisreached,tockisrefused. FortheEXAX::D__process(line3),twoarguments
(0,1)areneededduetotechnicalitiesoftheCSPmodelofRoboChart. ThefirstargumentisanID-value,
andthesecondisthevalueofn_waypoints,whichisnotfixedinthemodelofamachine.
1 timed csp EXAX2 csp-begin
2 Timed(OneStep) {
3 EXAX2 = EXAX::D__(0, 1) \ {| EXAX::go_to_posCall |}
4 }
5 csp-end
6 assertion A2: EXAX2 is timelock-free.
Listing2: DefinitionofEXAX2andassertion A2.
Assertion A3 The definition of assertion A3 and SpecA3 can be seen in Listing 3. This is the UR
equivalent to assertion A1 and SpecA1. This assertion ensures that for each move event, one of the
fourmoveoperationcallsmustbemadebeforeanytimeisallowedtopass.
1 timed csp SpecA3 csp-begin
2 Timed(OneStep) {
3 SpecA3 = let
4 Def = (CHAOS(Events) [| {|UR::move.in|} |> ADeadline(
5 {|UR::moveJCall,UR::movePCall,UR::moveLCall, UR::moveL_with_tCall|},0));
6 Def
7 within timed_priority(Def) }
8 csp-end
9 timed assertion A3: UR refines SpecA3 in the traces model.
Listing3: DefinitionofSpecA3andassertion A3104 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
Assertion A4 Also for the UR STM it is important to ensure timelock-freedom, and this is done in
assertion A4,whichistheURequivalenttoassertion A2andomittedhere.
Assertions A5 and A6 They are defined in Listing 4; they require that the EXAX and UR state ma-
chines,respectively,donotterminate. Theseassertionsareexpectedtopassgiventhatnoout_of_sync
occurs.
1 assertion A5: EXAX does not terminate.
2 assertion A6: UR does not terminate.
Listing4: Definitionofassertion A5andassertion A6.
Assertion A7 Listing 5 shows the definition of SysTerminates, as well as the definition of a pro-
cess Stop, and assertion A7. The process SysTerminates (line 3) is based on another process
(SysConstrainedfromline2)whichisaversionofthesystemwhereout_of_synceventsareskipped.
So, the SysTerminates process on line 3 only takes into account the termination event of the System
state machine. This is done by hiding all events except System::terminate using the |\ operator. If
System terminates despite the out_of_sync event being ignored, the assertion should fail, and this is
captured by comparing SysTerminates to the process Stop (line 6-8). Stop is equivalent to the CSP
processSTOP, whichisadeadlock. ThismeansthattheStopprocesscanneverperformanyeventsbe-
fore terminating, and so by demanding that SysTerminates refines Stop in the traces model,
itcanbeensuredthatthisprocessneverperformsSystem::terminate,andthusneverterminates. The
assertionisexpectedtoalwayspasssincetheout_of_synceventisbeingignored. Still,itshowsthatin
thecaseswhereitdoesnotoccur,theSystemstatemachinedoesnotterminate.
1 timed csp Systerminates associated to System csp-begin
2 SysConstrained = (System::D__(0) [| {| System::out_of_sync |} |] SKIP)
3 SysTerminates = (SysConstrained ; System::terminate -> SKIP) |\ {| System::
terminate |}
4 csp-end
5
6 csp Stop csp-begin
7 Stop = STOP
8 csp-end
9
10 assertion A7: SysTerminates refines Stop in the traces model.
Listing5: DefinitionofSysTerminates,Stopandassertion A7.
5.2 ResultsfromCheckingtheAssertions
As previously mentioned, the assertions have been run with two different value ranges for the time
variable, core_int. The range [0..2] implies that it is not possible to receive negative time budgets for
the movements, meaning that the movements are always performed in accordance with nominal plans.
Therange[-1..1]impliesthatnegativetimebudgetscanoccur, signifyingeitheraninfeasibleplanfrom
DelfoiorincorrectexecutionofmovementsbyeithertheURrobotortheturntable. Theassertionshave
beencheckedonacomputerwithanAMDDualEPYC7501(2*32cores)processorand2TiBofRAM.Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 105
ElapsedTime Complexity
Assertion Result
Compilation Verification Total States Transitions
A1 ✓ 10.79s 0.34s 11.13s 228 713
A2 ✓ 11.10s 0.32s 11.42s 228 713
A3 ✓ 14.42s 0.51s 14.93s 5,060 17,001
A4 ✓ 14.15s 0.57s 15.72s 5,060 17,001
A5 ✓ 0.12s 0.39s 0.51s 228 713
A6 ✓ 0.12s 0.60s 0.72s 5,060 17,001
A7 ✓ 0.64s 0.55s 1.19s 32 197
Table1: Resultsofmodel-checkingallassertionsinFDRwithcore_int = [0..2].
ElapsedTime Complexity
Assertion Result
Compilation Verification Total States Transitions
A1 X 11.16s 0.26s 11.42s 11 87
A2 X 10.94s 0.28s 11.22s 99 388
A3 X 15.23s 0.26s 15.49s 75 1,235
A4 X 14.19s 0.35s 14.54s 931 4,412
A5 X 0.10s 0.40s 0.50s 153 554
A6 X 0.12s 0.48s 0.60s 1,497 6,329
A7 ✓ 0.70s 0.58s 1.28s 32 197
Table2: Resultsofmodel-checkingallassertionsinFDRwithcore_int = [-1..1].
Nominal case with only positive time budgets, [0..2] As summarized in Table 1, all assertions pass.
This outcome is desirable for verifying the synchronisation properties. Since A1 and A3 pass, it can be
concluded that a movement operation is always called for each movement request received. Relating
backtotherequirementsinSection3.3,itindicatesthatR2issatisfied.
Realistic case with possibility of negative time budget, [-1..1] As summarised in Table 2, the only
assertionthatpassesisA7. Fig.10showsanexampleofatracerelatedtothefailedassertionA5. Itshows
an out_of_sync event, which should lead to termination due to EXAX_move having a negative value
for the time variable. The counterexample, given at the bottom in Fig. 10, shows that the system does
notterminate. Sinceout_of_synceventsarepossible,itshowsthatR1fromSection3.3issatisfied.
Figure10: TraceshowingacounterexampletoassertionA5-EXAX does not terminate.106 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
5.3 ImplicationsandReal-LifeSystemImprovements
Thefactthatallassertionsinthenominalcase(core_int = [0..2])pass,andallassertionsapartfromone
in the realistic case (core_int = [-1..1]) fail, indicates that the robots are unable to follow the nominal
plans. This could be, for instance, due to hardware limitations, like insufficient maximum speed or
acceleration, or inaccuracy in their trajectory following. To minimise errors, a full re-calibration of the
real-lifesystemhasbeendone. SincetheprogrammingisofflineinDelfoi,itiscrucialthatthephysical
system is calibrated precisely so the digital CAD model is correctly positioned and orientated. The
resultingweldafterthecalibration,asseeninFig.11,showsasignificantimprovementinquality.
Figure11: Acorneroftheworkpieceshowingsignificantlyimprovedweldingqualityaftersystemre-calibration.
6 Conclusion and Further Work
Applying model checking to an already existing industrial robotic system with known weaknesses has
provedtobebothchallenginganduseful. Themainchallengeliesinensuringthatthemodelcatchesthe
essential characteristics of the real-life system. Abstractions and assumptions need to be made to keep
the computational complexity at a reasonable level. However, it is crucial that they are not so limiting
thatthemodelfailstocapturethebehaviourandpossibleerrors. Keepinganeyeonthisso-called“reality
gap”betweenthemodelandtherealsystemisvital.
Eventhoughimprovementshavebeenmadeonthereal-lifesystembasedonthefindingsfromthemodel
checking, there is still room for improvement. An interesting path for further work is to verify the
assumptionsmadeonthehardware,toachieveaco-verificationsimilartothatin[15]. Itisalsobeneficial
to verify the offline programming in Delfoi, and set requirements for the generation of waypoints. This
willensurethefeasibilityoftheplannedtrajectories.
FurtherworkwillusethemodelfurtheralongtheRoboStarworkflowin[5]. Thenextstepistoautomat-
ically generate a simulation model RoboSim [3]. The RoboStar team is also working on model-based
testing, so we can generate forbidden traces from RoboChart models. They are specifications of tests
thatcanthenberunagainstthereal-lifesoftware. Thisisaninterestingwaytoaddresstherealitygap.
Acknowledgements
David Anisi has received partial funding from the Norwegian Research Council (RCN) RoboFarmer,
project number 336712. Ana Cavalcanti and Pedro Ribeiro are funded by the Royal Academy of
Engineering (Grant No CiET1718/45), and the UKRI (UK Research and Innovation Council), Grants
NoEP/R025479/1andEP/V026801/1.Y.Murray,H.Nordlie,D.A.Anisi,P.Ribeiro&A.Cavalcanti 107
References
[1] ChristelBaier&Joost-PieterKatoen(2008): Principlesofmodelchecking. MITPress.
[2] J.Baxter,P.Ribeiro&A.L.C.Cavalcanti(2022): Soundreasoningintock-CSP. ActaInformatica59,pp.
125–162,doi:10.1007/s00236-020-00394-3.
[3] A. L. C. Cavalcanti, A. C. A. Sampaio, A. Miyazawa, P. Ribeiro, M. Conserva Filho, A. Didier, W. Li
& J. Timmis (2019): Verified simulation for robotics. Science of Computer Programming 174, pp. 1–37,
doi:10.1016/j.scico.2019.01.004. Availableatpapers/CSMRCD19.pdf.
[4] AnaCavalcanti, WillBarnett, JamesBaxter, GustavoCarvalho, MadielConservaFilho, AlvaroMiyazawa,
Pedro Ribeiro & Augusto Sampaio (2021): RoboStar Technology: A Roboticist’s Toolbox for Combined
Proof,Simulation,andTesting. SpringerInternationalPublishing,doi:10.1007/978-3-030-66494-7_9.
[5] AnaCavalcanti, WillBarnett, JamesBaxter, GustavoCarvalho, MadielConservaFilho, AlvaroMiyazawa,
Pedro Ribeiro & Augusto Sampaio (2021): RoboStar Technology: A Roboticist’s Toolbox for Combined
Proof, Simulation, and Testing. In: Software Engineering for Robotics, Springer, doi:10.1007/978-3-030-
66494-7_9. Availableathttps://link.springer.com/10.1007/978-3-030-66494-7_9.
[6] HeeSun Choi, Cindy Crump, Christian Duriez, Asher Elmquist, Gregory Hager, David Han, Frank Hearl,
JessicaHodgins,AbhinandanJain,FrederickLeveetal.(2021):Ontheuseofsimulationinrobotics:Oppor-
tunities,challenges,andsuggestionsformovingforward. ProceedingsoftheNationalAcademyofSciences
118,doi:10.1073/pnas.1907856118.
[7] Edmund M. Clarke (1997): Model checking. In: Foundations of Software Technology and Theoreti-
cal Computer Science, 1346, Springer Berlin Heidelberg, doi:10.1007/BFb0058022. Available at http:
//link.springer.com/10.1007/BFb0058022.
[8] JEdwardColgate,WitayaWannasuphoprasit&MichaelAPeshkin(1996):Cobots:Robotsforcollaboration
with human operators. In: ASME international mechanical engineering congress and exposition, 15281,
AmericanSocietyofMechanicalEngineers,doi:10.1115/IMECE1996-0367.
[9] EclipseFoundation(visitedAugust5,2024): Eclipsewebsite. Availableathttp://www.eclipse.org/.
[10] Thomas Gibson-Robinson, Philip Armstrong, Alexandre Boulgakov & Andrew W. Roscoe (2014): FDR3
—AModernRefinementCheckerforCSP. In: ToolsandAlgorithmsfortheConstructionandAnalysisof
Systems,SpringerBerlinHeidelberg,doi:10.1007/978-3-642-54862-8_13.
[11] C. A. R. Hoare (1978): Communicating sequential processes. Communications of the ACM 21,
doi:10.1145/359576.359585. Availableathttps://dl.acm.org/doi/10.1145/359576.359585.
[12] PKah,MShrestha,EHiltunen&JMartikainen(2015):Roboticarcweldingsensorsandprogramminginin-
dustrialapplications.Internationaljournalofmechanicalandmaterialsengineering10,doi:10.1186/s40712-
015-0042-y.
[13] A. Miyazawa, P. Ribeiro, W. Li, A. L. C. Cavalcanti, J. Timmis & J. C. P. Woodcock (2019): RoboChart:
modellingandverificationofthefunctionalbehaviourofroboticapplications.Software&SystemsModeling
18(5),pp.3097–3149,doi:10.1007/s10270-018-00710-z.
[14] AlvaroMiyazawa,PedroRibeiro,WeiLi,AnaCavalcanti,JonTimmis&JimWoodcock(2019):RoboChart:
modelling and verification of the functional behaviour of robotic applications. Software & Systems
Modeling 18, doi:10.1007/s10270-018-00710-z. Available at http://link.springer.com/10.1007/
s10270-018-00710-z.
[15] Yvonne Murray, Martin Sirevåg, Pedro Ribeiro, David A. Anisi & Morten Mossige (2022): Safety assur-
anceofanindustrialroboticcontrolsystemusinghardware/softwareco-verification. ScienceofComputer
Programming 216, doi:10.1016/j.scico.2021.102766. Available at https://linkinghub.elsevier.com/
retrieve/pii/S0167642321001593.
[16] Henrik Nordlie (2024): Formal verification of synchronization properties of a multi-robot welding system.
Master’sthesis,NorwegianUniversityofLifeSciences,Ås,Norway.108 ModelCheckingandVerificationofSynchronisationPropertiesofCobotWelding
[17] PioneerRoboticsAS(visitedAugust15,2024): IntelliWelder-UR+certifiedproduct. Availableathttps:
//www.pioneer-robotics.no/cobot/intelliwelder/.
[18] JNorbertoPires,AltinoLoureiro&GunnarBölmsjo(2006): Weldingrobots: technology,systemissuesand
application. SpringerScience&BusinessMedia,doi:10.1007/1-84628-191-1.
[19] Gang Ren, Qingsong Hua, Pan Deng, Chao Yang & Jianwei Zhang (2017): A Multi-Perspective Method
for Analysis of Cooperative Behaviors Among Industrial Devices of Smart Factory. IEEE Access 5,
doi:10.1109/ACCESS.2017.2708127.
[20] GüntherStarke,DanielHahn,DianaG.PedrozaYanez&LuzM.UgaldeLeal(2016): Self-organizationand
self-coordinationinweldingautomationwithcollaboratingteamsofindustrialrobots. Machines(Basel)4,
doi:10.3390/machines4040023.
[21] THG Automation (visited August 19, 2024): In Sync: The Benefits of Coordinated Motion. Available at
https://thgautomation.com/2024/06/27/in-sync-the-benefits-of-coordinated-motion/.
[22] UniversalRobots(visitedAugust5,2024): UniversalRobots-UR10eWebsite. Availableathttps://www.
universal-robots.com/products/ur10-robot/.
[23] Universal Robots (visited August 8, 2024): Real-Time Data Exchange Guide. Avail-
able at https://www.universal-robots.com/articles/ur/interface-communication/
real-time-data-exchange-rtde-guide/.
[24] Universal Robots (visited July 23, 2024): Universal Robots e-Series User Manual. Avail-
able at https://www.universal-robots.com/download/manuals-e-seriesur20ur30/user/ur10e/
59/user-manual-ur10e-e-series-sw-59-english-international-en/.
[25] UniversityofOxford(visitedAugust15,2024): FDR4-TheCSPRefinementChecker. https://cocotec.
io/fdr/. Availableathttps://cocotec.io/fdr/.
[26] Visual Components (visited August 15, 2024): Robot Offline Programming. Available at https://www.
visualcomponents.com/products/robot-offline-programming/.
[27] Jiahao Xiong, Zhongtao Fu, Miao Li, Zhicheng Gao, Xiaozhi Zhang & Xubing Chen (2021): Trajectory-
Smooth Optimization and Simulation of Dual-Robot Collaborative Welding. In: Intelligent Robotics and
Applications,13014,Springer,doi:10.1007/978-3-030-89098-8_66.