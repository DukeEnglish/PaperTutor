Computing Threshold Circuits with Bimolecular Void Reactions in Step
∗
Chemical Reaction Networks
Rachel Anderson1, Bin Fu1, Aiden Massie1, Gourab Mukhopadhyay1, Adrian Salinas1, Robert
Schweller1, Evan Tomai2, and Tim Wylie1
1University of Texas Rio Grande Valley
1University of Texas Dallas
Abstract
Step Chemical Reaction Networks (step CRNs) are an augmentation of the Chemical Reaction Net-
work (CRN) model where additional species may be introduced to the system in a sequence of “steps.”
WestudystepCRNsystemsusingaweaksubsetofreactionrules,void rules,inwhichmolecularspecies
can only be deleted. We demonstrate that step CRNs with only void rules of size (2,0) can simulate
threshold formulas (TFs) under linear resources. These limited systems can also simulate threshold
circuits (TCs) by modifying the volume of the system to be exponential. We then prove a matching
exponential lower bound on the required volume for simulating threshold circuits in a step CRN with
(2,0)-size rules under a restricted gate-wise simulation, thus showing our construction is optimal for
simulating circuits in this way.
1. Introduction
Chemical Reaction Networks (CRNs) are a well-established model of chemistry. In this model, chemical
interactions are modeled as molecular species that react to create products according to a set of reaction
rules. CRNs have been extensively studied since their standard formulation in the 1960s [6, 7]. Several
equivalent models were also introduced around the same time with Vector Addition Systems (VASs) [20]
and Petri-nets [24]. Further, Population Protocols [3] are a restricted form of the model focused on
bimolecular reactions.
Step CRNs. These models all assume a discrete starting number of species or elements and reaction rules
thatdictatehowtheycaninteract. Thus, anychangeinspeciesnumbersisonlythroughtheseinteractions.
Motivated by standard laboratory procedures where additional chemical species may be added to an initial
container of species after a set of reactions has passed, we utilize an extension to the CRN model known
as the Step Chemical Reaction Network model (step CRN) first introduced in [2]. The step CRN model
adds a sequence of discrete steps where additional species can be added to the existing CRN configuration
after waiting for all possible reaction rules to occur in the system.
Bimolecular Void Rules. In this paper, we use the terms reaction and rule interchangeably to denote
a reaction rule. We focus on step CRN systems that include only bimolecular void rules ((2,0) rules)
which are CRN rules that have two reactants and no products, and thus can only delete existing species.
Void rules of size (2,0) and (3,0) were first studied within the standard CRN model in the context of the
reachabilityproblem[1]. WhilestandardCRNrulesarepowerfulthankstotheirabilitytoreplace,deleteor
createnewspecies,(2,0)ruleshaveextremelylimitedpowertocomputeevensimplefunctionsinastandard
CRN [2]. In contrast, we show (2,0) void rules become capable of computing Threshold Formulas (TF)
∗This research was supported in part by National Science Foundation Grant CCF-2329918.
1
4202
yaM
2
]CD.sc[
1v04900.5042:viXraFunction Computation
Rules Species Steps Volume Simulation Family Ref
(2,0) O(G) O(D) O(G) Gate-Wise TF Formulas Theorem 1
(2,0) O(G) O(D) O(GF D) Gate-Wise TC Circuits Theorem 2
out
(2,0) - - 2Ω(D) Gate-Wise TC Circuits Theorem 3
Table 1: Results in the paper related to computing circuits with (2,0) void rules in step CRN systems. D
is the circuit’s depth, G is the number of gates in a circuit, and F is the maximum fan-out of a gate in
out
the circuit.
and Threshold Circuits (TC) in the step CRN model. Threshold circuits are a computationally universal
class of Boolean circuits that have practical application in deep learning, and consist of any Boolean circuit
made of AND, OR, NOT, and MAJORITY gates.
Computation in Chemical Reaction Networks. Computation within Chemical Reaction Networks is a well-
studied topic. Within stochastic Chemical Reaction Networks with some possibility for error, the systems
are Turing-complete [27]. In contrast, error-free stochastic CRNs are capable of computing semilinear
functions [5, 12]. Further, molecules themselves have long been studied as a method of information storage
and Boolean logic computation. In particular, CRNs and similar models have been extensively studied
in these areas [8, 9, 11, 13, 15, 19, 21, 25, 26]. Logic gates such as AND [11, 14, 22, 26, 28, 30], OR
[11, 14, 26, 28], NOT [11], XOR [11, 30], NAND [11, 13, 15, 29], NOR [11], Parity [16, 17, 18] and Majority
[4, 10, 23] have also been explored.
Our Contributions. Table 1 gives an overview of our results, and the paper is formatted to introduce
the general techniques and then expand into the necessary details to prove these results. Section 3.2 shows
how a step CRN, using (2,0) void rules, computes individual logic gates. We then show how these gates
can be combined to build a general construction of threshold formulas in Section 3.4. Theorem 1 shows
howastepCRNwithonly(2, 0)rulesiscapableofcomputingthresholdformulaswithO(G)species, O(D)
steps, and O(G) volume, where G is the number of gates in a circuit and D is the depth of a circuit.
In Section 4, we modify this construction to compute threshold circuits with O(G) species, O(D) steps,
and O(GF D) volume, where F is the maximum fan-out of the circuit. Finally, in Section 5 we show
out out
that the volume lower bound for simulating a circuit using gate-wise simulation in a step CRN with (2,0)
rules is 2Ω(D). This lower bound is of note in that it shows the exponential volume utilized by the positive
result is needed for this style of computation, and it shows a provable change in power from the polynomial
volume achievable with (3,0) void rules [2].
2. Preliminaries
2.1. Chemical Reaction Networks
Basics. Let Λ = {λ ,λ ,...,λ } denote some ordered alphabet of species. A configuration over Λ is a
1 2 |Λ|
length-|Λ| vector of non-negative integers that denotes the number of copies of each present species. A
rule or reaction has two multisets, the first containing one or more reactant (species), used for creating
resulting product (species) contained in the second multiset. Each rule is represented as an ordered pair
of configuration vectors R = (R ,R ). R contains the minimum counts of each reactant species necessary
r p r
for reaction R to occur, where reactant species are either consumed by the rule in some count or leveraged
as catalysts (not consumed); in some cases a combination of the two. The product vector R has the
p
count of each species produced by the application of rule R, effectively replacing vector R . The species
r
corresponding to the non-zero elements of R and R are termed reactants and products of R, respectively.
r p
2Species
a e
a b c d e f g c e f
d g
Rules
Final Configuration
S₀ S S₂
a + c + e →∅ 1
b + d + e →∅ a c a c → a c d → f g
c + f + g → f d d d e e d g e
. . . e . . . e . . .
d + f + g → g
Step 1 Step 2 Step 3
Figure 1: An example step CRN system. The test tubes show the species added at each step and the
system with those elements added. The CRN species and void rule-set are shown on the left.
The application vector of R is R = R − R , which shows the net change in species counts after
a p r
applying rule R once. For a configuration C and rule R, we say R is applicable to C if C[i] ≥ R [i] for
r
all 1 ≤ i ≤ |Λ|, and we define the application of R to C as the configuration C′ = C +R . For a set of
a
rules Γ, a configuration C, and rule R ∈ Γ applicable to C that produces C′ = C +R , we say C →1 C′,
a Γ
a relation denoting that C can transition to C′ by way of a single rule application from Γ. We further use
the notation C ⇝ C′ to signify the transitive closure of →1 and say C′ is reachable from C under Γ, i.e.,
Γ Γ
C′ can be reached by applying a sequence of applicable rules from Γ to initial configuration C. Here, we
(cid:80)|Λ| (cid:80)|Λ|
use the following notation to depict a rule R = (R ,R ): R [i]s → R [i]s .
r p i=1 r i i=1 p i
Using this notation, a rule turning two copies of species H and one copy of species O into one copy of
species W would be written as 2H +O → W.
Definition 1 (Discrete Chemical Reaction Network). A discrete chemical reaction network (CRN) is an
ordered pair (Λ,Γ) where Λ is an ordered alphabet of species, and Γ is a set of rules over Λ.
We denote the set of reachable configurations for a CRN (Λ,Γ) from initial configuration I as
REACH . A configuration is called terminal with respect to a CRN (Λ,Γ) if no rule R ∈ Γ can
I,Λ,Γ
be applied to it. We define the subset of reachable configurations that are terminal as TERM . For an
I,Λ,Γ
initial configuration I, a CRN (Λ,Γ) is said to be bounded if a terminal configuration is guaranteed to be
reached within some finite number of rule applications starting from configuration I.
2.2. Void Rules
Definition 2 (Void and Autogenesis rules). A rule R = (R ,R ) is a void rule if R = R −R has no
r p a p r
positive entries and at least one negative entry. A rule is an autogenesis rule if R has no negative values
a
and at least one positive value. If the reactants and products of a rule are each multisets, a void rule is a
rule whose product multiset is a strict submultiset of the reactants, and an autogenesis rule one where the
reactants are a strict submultiset of the products. There are two classes of void rules, catalytic and true
void. In catalytic void rules, one or more reactants remain after the rule is applied. In true void rules,
such as (2,0) and (3,0) rules, there are no products remaining.
(cid:80)
Definition 3. The size/volume of a configuration vector C is volume(C) = C[i].
Definition 4 (size-(i,j) rules). A rule R = (R ,R ) is said to be a size-(i,j) rule if (i,j) = (volume(R ),
r p r
volume(R )). A reaction is bimolecular if i = 2.
p
2.3. Step Chemical Reaction Networks
A step CRN is an augmentation of a basic CRN in which additional copies of some system species
are added after each of a sequence of steps. Formally, a step CRN of k steps is a ordered pair
3((Λ,Γ),(s ,s ,s ,...s )), where the first element of the pair is a normal CRN (Λ,Γ), and the sec-
0 1 2 k−1
ond is a sequence of length-|Λ| vectors of non-negative integers denoting how many copies of each species
type to add after each step.
Given a step CRN, we define the set of reachable configurations after each sequential step. To start off,
let REACH be the set of reachable configurations of (Λ,Γ) with initial configuration s , which we refer to
1 0
as the set of configurations reachable after step 1. Let TERM be the subset of configurations in REACH
1 1
that are terminal. Note that after just a single step we have a normal CRN, i.e., 1-step CRNs are just
normal CRNs with initial configuration s . For the second step, we consider any configuration in TERM
0 1
combined with s as a possible starting configuration and define REACH to be the union of all reachable
1 2
configurationsfromeachpossiblestartingconfigurationattainedbyaddings toaconfigurationinTERM .
1 1
We then define TERM as the subset of configurations in REACH that are terminal. Similarly, define
2 2
REACH to be the union of all reachable sets attained by using initial configuration c at step s plus
i i−1 i−1
any element of TERM , and let TERM denote the subset of these configurations that are terminal.
i−1 i
The set of reachable configurations for a k-step CRN is the set REACH , and the set of terminal
k
configurations is TERM . A classical CRN can be represented as a step CRN with k = 1 steps and an
k
initial configuration of I = s .
0
2.4. Computing Functions in Step CRNs
Here,wedefinewhatitmeansforastepCRNtocomputeafunctionf(x ,...,x ) = (y ,...,y )thatmaps
1 n 1 m
n-bit strings to m-bit strings. For each input bit, we denote two separate species types, one representing
bit 0, and the other bit 1. An input configuration to represent a desired n-bit input string is constructed
by selecting to add copies of either the 0 species or the 1 species for each bit in the target bit-string.
Similarly, each output bit has two species representatives (for 0 and 1), and we say the step CRN computes
function f if for any given n-bit input x ,...,x , the system obtained by adding the species for the string
1 n
x ,...,x to the initial configuration of this system in step 1 results in a final configuration whose output
1 n
species encode the string f(x ,...,x ). Note that for a fixed function f, the species s added at each step
1 n i
are fixed to disallow outside computation. We now provide a more detailed formalization of this concept.
Input-Strict Step CRN Computing. Given a Boolean function f(x ,...,x ) = (y ,...,y ) that maps a
1 n 1 m
string of n bits to a string of m bits, we define the computation of f with a step CRN. An input-strict
step CRN computer is a tuple C = (S,X,Y) where S = ((Λ,Γ),(s ,s ,...,s )) is a step CRN, and
s 0 1 k−1
X = ((xF,xT),...,(xF,xT)) and Y = ((yF,yT),...,(yF,yT)) are sequences of ordered-pairs with each
1 1 n n 1 1 m m
xF,xT,yF,yT ∈ Λ. Given an n-input bit string b = b ,...,b , configuration X(b) is defined as the
i i j j 1 n
configuration over Λ obtained by including one copy of xF only if b = 0 and one copy of xT only if b = 1
i i i i
for each bit b . We consider this representation of the input to be strict, as opposed to allowing multiple
i
copies of each input bit species. The corresponding step CRN (Λ,Γ,(s +X(b),...,s )) is obtained by
0 k−1
adding X(b) to s in the first step, which conceptually represents the system programmed with input b.
0
An input-strict step CRN computer computes function f if, for all n-bit strings b and for all terminal
configurations of (Λ,Γ,(s +X(b),...,s )), the terminal configuration contains at least 1 copy of yF and
0 k−1 j
0 copies of yT if the jth bit of f(b) is 0, and at least 1 copy of yT and 0 copies of yF if the jth bit of f(b)
j j j
is 1, for all j from 1 to m.
We use the term strict to denote requiring exactly one copy of each bit species. While previous work
has focused on strict computation [2], the focus here is a relaxation of this requirement in which multiple
copies of each input species are permitted.
Multiple Input Relaxation. In this paper, we focus on a relaxation to strict computing that allows for
multiple copies of each input bit species, i.e., we modify the strict definition by allowing some number
greater or equal to 1 of each xF or xT species in the initial configuration (but still requiring 0 copies of the
i i
alternate choice species). A system that computes a function under this relaxation is said to be multiple
input relaxed.
41 1 xT 1 1
1 5
2 0
xF 2 0
2
7
3 0
xF
3 3 0
6
4 1 xT 4 1
4
(a) (b)
Figure 2: (a) The input bits of a threshold formula and their representation as species. (b) An indexed
threshold formula with the input species shown in Figure 2a.
Gate-Wise Simulation. In this paper, we utilize a method of simulation we term gate-wise simulation,
where the output of each gate is represented by a unique species and the gates are computed in the order
of their depth level. In other words, multiple gates cannot use the exact same species to represent their
output and a gate can only be computed once all gates in the previous depth levels have been computed.
We use this method when simulating formulas and circuits with a step CRN in Sections 3 and 4. A formal
definition of gate-wise simulation is provided in Section 5.
2.5. Boolean and Threshold Circuits
A Boolean circuit on n variables x ,x ,...,x is a directed, acyclic multi-graph. The vertices of the graph
1 2 n
are referred to as gates. The in-degree and out-degree of a gate are called the fan-in and fan-out of the
gate, respectively. The fan-in 0 gates (source gates) are labeled from x ,x ,...,x , or from the constants
1 2 n
0 or 1. Each non-source gate is labeled with a function name, such as AND, OR, or NOT. Fan-out 0
gates may or may not be labeled as output gates. Given an assignment of Boolean values to variables
x ,x ,...,x , each gate in the circuit can be assigned a value by first assigning all source vertices the value
1 2 n
matching the labeled constant or labeled variable value, and subsequently assigning each gate the value
computed by its labeled function on the values of its children. Given a fixed ordering on the output gates,
the sequence of bits assigned to the output gates denotes the value computed by the circuit on the given
input.
The depth of a circuit is the longest path from a source vertex to an output vertex. A circuit is a called
a formula if all non-source vertices have fan-out 1, and there is exactly 1 output gate. Here, we focus on
circuits that consist of AND, OR, NOT, and MAJORITY gates with arbitrary fan-in. We refer to circuits
that use these gates as Threshold Circuits (TC).
Notation. When discussing a Boolean circuit, the following variables are used to denote the properties of
the circuit: G denotes the number of gates in the circuit, D the circuit’s depth, and F the maximum
out
fan-out of any gate in the circuit.
3. Computation of Threshold Formulas with (2, 0) Rules
Section 3.1 and Section 3.2 introduce how a step CRN using only (2,0) rules represents bits and logic
gates of a Threshold Formula (TFs), respectively. An example construction of a formula is provided in
Section 3.3. Section 3.4 then shows the general construction of building TFs, and we prove how the system
computes TFs with O(G) species, O(D) steps, and O(G) volume in Theorem 1.
5Rules:
xT + yF >∅ xF + yT >∅
1 1 >4 2 4
1 1 xF + yT >∅ xT + yF >∅
1 4 3 3 >4
xT + yF >∅ xF + yT >∅
2 1 AND 0 4 2 2 >4 3 4
To add:
3 0 yT yF yF yF
4 1 >4 2 >4 3 >4
(a) (b)
Step: 0 1 Step: 0 1
Add:
yT yF yF yF
Add:
yT yF yF yF
4 1 >4 2 >4 3 >4 4 1 >4 2 >4 3 >4
xF xT xT xT
Config: 3 1 xF xT xT Config: 3 1 xT xT xT
3 1 2 1 2 3
xT xT
2 2
(c) (d)
Figure 3: (a) A threshold formula consisting of a single three-input AND gate. (b) Reaction rules and
added species for the step CRN that compute the formula in 3a. (c) The step CRN computing the formula
in Figure 3a. The black lines connecting species represents a reaction applied to them. (d) The step CRN
computing the circuit in Figure 3a, but with three true inputs.
3.1. Bit Representation
Here, we show how the bits of a TF are represented in our model. We first demonstrate a system for
indexing the TF’s wires before introducing the species used to represent bits.
Indexing. Every wire of the TF has a unique numerical index. The input and output bits that traverse
these wires also use the wire’s index. If a wire fans out, the fanned-out wires share the same index as the
original. This indexing ensures that the bit species only use the rules that compute their respective gates.
Note that gates may also be denoted with an index, where its index is that of its output wire.
Bits. Every input bit of a binary gate is represented by the species xb, where n ∈ N and b ∈ {T,F}. n
n
represents the bit’s index and b represents its truth value. An example of these species is shown in Figure
2a. Every output bit of a binary gate is represented by the species yb or yb , where j represents the input
n j→i
bit’s (xb) index and i represents the output bit’s (yb) index.
3.2. Logic Gate Computation
We now show how the logic gates of a TF are computed. Let fin be the set of all the indexes of the inputs
i
fanning into a gate at index i.
AND Gate. To compute an AND gate such as the one shown in Figure 3a, a single true output species
yT and |fin| copies of the false output species yF are added in. In one step, the true input and false
i i j→i
output species delete each other. Additionally, if at least one false input species exists, it deletes the lone
true output species along with itself, guaranteeing a false output as shown in the example steps in Figure
3c. The only output species remaining after the step are those whose truth value matches the intended
output.
6Gate Type Step Relevant Rules Description
An input species with a certain
yT xT +yF → ∅
AND Add i j j→i truth value deletes the
∀j ∈ fin : yF xF +yT → ∅
i j→i j i complement output species.
An input species with a certain
yF xT +yF → ∅
OR Add i j i truth value deletes the
∀j ∈ fin : yT xF +yT → ∅
i j→i j j→i complement output species.
The input and output species that
yT xT +yT → ∅
NOT Add i j i share the same truth value delete
yF xF +yF → ∅
i j i each other.
Table 2: (2, 0) rules and steps for computing AND, OR, and NOT gates.
Steps Relevant Rules Description
∀j ∈ fin :
|fin|·aT i ∀j ∈ fin, convert xb input
1 Add i i xT +aF → ∅ i j
|fin|·aF j i species into ab species.
i i xF +aT → ∅ i
j i
Adding ⌊|fin|/2⌋ amounts of bT and
i i
⌊|fin|/2⌋·bT aT +bF → ∅ bF species will delete all of the
2 Add i i i i i
⌊|fin|/2⌋·bF aF +bT → ∅ minority species, leaving some amount
i i i i
of the majority species remaining.
yT aT +yF → ∅ Convert ab into the proper output
3 Add i i i i
yF aF +yT → ∅ species (yb).
i i i i
Table 3: (2, 0) rules and steps for computing majority gates.
AND Gate Example. ConsideranANDgatewithindex4andafan-inofthree; thefirsttwoinputsaretrue
and the last is false. For computing this gate with our model, the system’s initial configuration consists
of xT, xT, and xF. We then add yT, representing a true output and yF , yF , and yF , representing
1 2 3 4 1→4 2→4 3→4
false outputs. The rules xT +yF → ∅, xT +yF → ∅, and xF +xT → ∅ are then applied to the system,
1 1→4 2 2→4 3 1
removing all reactant species in these rules. The remaining species is yF , indicating a false output.
3→4
ORGate. TocomputeanORgate,asinglefalseoutputspeciesyF and|fin|copiesofthetrueoutputspecies
i i
yT are added in. In one step, the false input and true output species delete each other. Additionally, if
j→i
at least one true input species exists, it deletes the lone false output species along with itself, guaranteeing
a true output. The only output species remaining after the step are those whose truth value matches the
intended output.
NOT Gate. To compute a NOT gate, a single copy of the true and false output species are added in. In a
single step, the input and output species that share the same truth value b delete each other, leaving the
complement of the input species as the remaining output species.
Majority Gate. To compute a majority gate, all input species are first converted into a new species ab
i
(Step 1). These species retain the same index and truth value of their original inputs. If the number
of bits inputted into a majority gate is even, then an extra false input species should be added in. The
species bb is then added (Step 2). This species performs the majority operation across all ab species. Any
i i
species that represents the minority inputs are deleted. The remaining species are then converted into the
matching output species (Step 3).
7Initial Configuration: yT, yF, yF, yT
1 2 3 4
Step Relevant Rules
yT +xF → ∅
1 1
xT, xT, xT, xT yF +xT → ∅
1 Add 1 2 3 4 2 2
xF, xF, xF, xF yF +xT → ∅
1 2 3 4 3 3
yT +xF → ∅
4 4
xT +yF → ∅
1 1→5
yT, yF , yF xF +yT → ∅
2 Add 5 1→5 2→5 2 5
yT, yF , yF xF +yT → ∅
6 3→6 4→6 3 6
xT +yF → ∅
4 4→6
xT, xT yF +xT → ∅
3 Add xF5 , x6 F y2 F→5 +x5 T → ∅ Step Relevant Rules
5 6 3→6 6
yT +xF → ∅
yF +xT → ∅ i i
4 Add yT , yT , yF 5→7 5 xT yF +xT → ∅
5→7 6→7 7 yF +xT → ∅ Add i i i
6→7 6 xF yT +xF → ∅
i j→i i
5 Add xT 7, xF 7 y 7F +xT 7 → ∅ y jF →i+xT i → ∅
(a) (b)
Table 4: (a) (2, 0) rules and steps for computing the formula in Figure 2b. (b) (2, 0) rules and step for
converting outputs to inputs per depth level. Add species for that represent true and false inputs. Delete
the species that are the complement of the output. Only the correct input species remains.
3.3. Formula Computation Example
We demonstrate a simple example of computing a threshold formula under our constructions. The formula
is the same as in Figure 2b. It has four inputs: x , x , x , and x . At the first depth level, x and x fan
1 2 3 4 1 2
into an AND gate, as does x and x . Both gate outputs are then fanned into an OR gate, whose output
3 4
represents the final value of the formula.
The initial configuration consists of bit species that correlate to the input values for the formula. Step
1 converts the species into input species for the first depth level. Step 2 then performs all gate operations
at the first depth level. Step 3 converts the output species of the gates into input species for the next and
finaldepthlevel. Step4computestheonlygateatthislevel. Finally, Step5covertsthatgate’soutputinto
an input species that represents the final output of the formula. A more detailed explanation of computing
the formula is in Table 4a.
3.4. Threshold Formula Computation
We now introduce another step with rules that convert the output species of one depth level into input
species for the next level, enabling the complete computation of a TF. We then prove the computational
complexity of computing TFs within our system.
Depth Traversal. To enable the traversal of every gates’ bits at a specific depth level to the next level,
every output species is converted into an input species in one step. The same truth value and index is
retained between the output and input species. Table 4b shows how to compute depth level traversal for
an output bit with index i.
Theorem 1. Threshold formulas (TF) can be computed with multiple-input relaxation by a step CRN with
only (2,0) rules with upper bounds of O(G) species, O(D) steps, and O(G) volume.
Proof. Each gate of a TF is represented by a constant number of species, resulting in O(G) unique species.
All gates at a given depth level are computed simultaneously in constant steps. Computing a TF therefore
8Step: 0 1 2
Add:
yF yF yF
2 2 2
yT yT yT
2 2 2
xT yF
Configuration: 1 xT xT xT 2
xT
1 1 1
yF
1 1 2 0 1 2
xT yF
1 2
(a) (b)
Figure 4: (a) A NOT gate with a fan-out of three. (b) Computing the NOT gate in Figure 4a in (2, 0)
rules.
requires O(D) steps.
It is possible not all species that are no longer needed after computing a specific gate are deleted. For
example, computing an AND gate with three false inputs leaves two of those species in the configuration.
While this does not cause computation errors, the volume will increase. Therefore, it is possible for only a
fraction of the O(G) species added throughout the simulation to be deleted, resulting in O(G) volume.
4. Computation of TCs with Exponential Volume
In this section, we slightly alter the approach presented in Section 3 to enable computation of Threshold
Circuits (TC). We show in Section 4.1 how modifying our volume to be exponentially-sized allows the
system to account for unbounded fan-out outside of the first depth level, enabling the computation of TCs.
Theorem 2 shows our system computes TCs with O(G) species, O(D) steps, and O(GF D) volume.
out
4.1. Threshold Circuit Computation
Here, we demonstrate how to account for unbounded fan-out when computing TCs, and show the compu-
tational complexity of computing TCs with our system.
Bits and Gates. Section 3.1 shows how input bits, output bits, and indexing are represented. Individual
gatesanddepthtraversalarecomputedusingthesamemethodsshowninSections3.2and3.4,respectively.
Unbounded Fan-Out. To allow the output of a gate at index i to fan-out k > 1, such as in the NOT gate
shown in Figure 4a, the count of the species added for all the gates whose output eventually fans into gate
i should be multiplied by k. The gate computes all input species concurrently with each other, and result
in the gate’s output species being equivalent in quantity to the fan-out. Figure 4b shows an example of
this process for a NOT gate with a fan-out of three.
Unbounded Fan-Out Example. Consider an AND gate with a fan-in and fan-out of two. Let the two
input bits be true and false. To compute the gate with the correct amount of fan-out, our system’s initial
configuration consists of two copies of each input species (xT, xT, xF, and xF). We then apply the relevant
1 1 2 2
rules to the configuration. Afterwards, we are left with two copies of yF .
2→1
Theorem 2. Threshold circuits (TC) can be computed with multiple-input relaxation by a step CRN with
only (2, 0) rules with upper bounds of O(G) species, O(D) steps, and O(GF D) volume.
out
5. Exponential Volume Lower Bound for Gate-Wise Simulation
In this section, we derive an exponential lower bound for the volume of a step CRN with (2,0) rules that
simulates boolean circuits of depth D. Our lower bound almost matches the upper bound.
9To prove the lower bound, we design a circuit that is able to be simulated by any step CRN using
only (2,0) rules as follows. The circuit has D stages such that each stage of the circuit has O(1) layers.
We establish a recursive inequality for the CRN volume over three consecutive stages which implies an
exponential lower bound for species in the input stage. We show a proof that the lower bound of volume
in a step CRN that uses gate-wise simulation to simulate a boolean circuit with only (2,0) rules is 2Ω(D).
Definition 5. A step CRN uses gate-wise simulation to simulate a circuit V(·) if each gate g is assigned
c copies of species 1 , which represents output 1, and c copies of 0 , which represents output 0. When
1,g g 0,g g
gate g computes an output, it will be either c copies of species 1 for the case 1, or c copies of species
1,g g 0,g
0 for the case 0. We define C(g) = c +c to be the number of species used for gate g. There is a
g 1,g 0,g
special case that g is one of the input bits (source gates with fan-in 0) that satisfies c = 0 or c = 0,
1,g 0,g
as each input bit is either 0 or 1. Let a step CRN have k steps 0,1,··· ,k−1 as defined in Section 2.4. It
also satisfies the conditions:
• Every gate g enters its complete state at exactly one step i, which is denoted by complete(g) = i.
After step i, the system releases c copies of species a and removes all copies of species (1−a)
a,g g g
to represent gate g having the output a. After step complete(g), the system does not generate any
additional copy of 1 or 0 (it may keep some existing copies of a ). The output of gate g determines
g g g
the simulation according to the logic of circuit.
• For two different gates g and g , if there is a directed path from g to g (g ’s output may affect g ’s
1 2 1 2 1 2
output) in the circuit V(·), then complete(g ) < complete(g ).
1 2
If a circuit V(·) computes a function f(x ,··· ,x ) = y ,··· ,y ({0,1}n → {0,1}m) and V(·) is
1 n 1 m
simulated using gate-wise simulation in a step CRN, define 1 to represent the case y to be 1 and 0
f(·),i i f(·),i
to represent the case y to be 0.
i
By Definition 5, when gate g outputs 1, all the c copies of 0 are removed and it has c copies of 1
0,g g 1,g g
to enter the next layer of a circuit. The step CRN given in Section 4 uses gate-wise simulation to simulate
threshold circuits. Our lower bound result in this section shows that the exponential volume is required.
Lemma 1. Assume that a step CRN with (2,0) rules simulates a circuit V(·). Let b ∈ {1 ,0 } be the
g g
output species. If one copy of a species is removed or added, it results in at most one difference in the
number of copies of species b.
Proof. We prove via induction over the total start volume. If the start volume is zero, it is trivial. Adding
one copy of species u results in no additional changes since there is only one copy of a species and every
rule requires two copies. This is why it affects at most one copy of a species in the output side.
Consider the case that the start volume is one. We only have one copy of a species v. If one copy of u
is added, there are two possible cases: 1) u and v do not react (no rule u+v → ∅ exists), and 2) u and v
react (u+v → ∅). In case 1), the output of the CRN increases by at most one copy. In case 2), the output
of the CRN removes at most one copy.
Assume it is true when the start volume is at most n. Consider the start volume to be n+1. Let
species u lose one copy. Let u+v → ∅ be applied (otherwise, it is trivial). We transform the problem into
adding one copy of v into a step CRN with volume n−1. This case is proved by inductive hypothesis.
The case of adding one copy of u is similar.
Lemma 2. Let f(x ,··· ,x ) = y ,··· ,y be a function {0,1}n → {0,1}m such that each variable x and
1 n 1 m i
y has a value in {0,1}. If a step CRN with (2,0) rules computes f(·), and changing variable x to 1−x
j j j
will change y ,··· ,y to 1−y ,··· ,1−y , respectively, then C(x ) ≥
(cid:80)t
C(y ).
i1 it i1 it j k=1 i k
Proof. AssumethatthereisastepCRNtosimulatef(·). AssumeC(x ) <
(cid:80)t
C(y ). ForeachBoolean
j k=1 i k
variable x, we also use x to represent the gate that outputs the value of x.
10When one copy is removed from (or added to) the input side, it may add or decrease at most one copy
on the output side by Lemma 1. If the output side needs to change its value from a ∈ {0,1} to 1−a, then
it must remove all the copies that represent the current a and add the new copies that represent the value
1−a. Assume that the current x has value a ∈ {0,1}. Consider the transitions of two phases:
j
• Phase 1: Remove c copies of x . After x is removed, it affects at most c copies of species
a,xj j j a,xj
y ,··· ,y by Lemma 1.
i1 it
• Phase 2: Add c copies of x with value 1−a over the input side. After adding c copies of
1−a,xj j 1−a,xj
x (with flipped value), it affects at most c copies of species y ,··· ,y by Lemma 1.
j 1−a,xj i1 yt
Theoutputsidedestroystheoldcopiesofthespeciesfory ,··· ,y ,andaddsnewcopiesfory ,··· ,y .
i1 it i1 it
However, the 2 phases affect at most C(x ) = c +c <
(cid:80)t
C(y ) copies on the output side.
j a,xj 1−a,xj k=1 i k
Thus, a contradiction.
Definition 6. A list of Boolean circuits {H (·)} is uniform if there is a Turing machine M(·) such that
n
each H (·) can be generated by M(1n) in a polynomial p(n) steps.
n
Theorem 3. There exist uniform Boolean circuits {V (x ,x ,x )}+∞ with each V (x ,x ,x ) : {0,1}3 →
D 1 2 3 D=1 D 1 2 3
{0,1}3 s.t. each V (x ,x ,x ) has depth O(D), size O(D), 3 output bits, and requires C(g) = 2Ω(D) for at
D 1 2 3
least one input gate g in a step CRN using gate-wise simulation to simulate V (·) with (2,0) rules.
D
Proof. We construct a circuit that has O(D) layers. It is built in D stages. Each stage has a circuit of
depth O(1) to compute function s(x ,x ,x ) = y y y . The function s(·) has the properties:
1 2 3 1 2 3
s(1,1,1) = 111, (1)
s(0,1,1) = 000, (2)
s(1,0,1) = 011, (3)
s(1,1,0) = 101, (4)
s(0,0,0) = 110. (5)
Define function s(1)(x ,x ,x ) = s(x ,x ,x ) and s(k+1)(x ,x ,x ) = s(s(k)(x ,x ,x )) for all integers
1 2 3 1 2 3 1 2 3 1 2 3
k > 1. The circuit V(x ,x ,x ) = s(D)(x ,x ,x ). We can also represent the circuit V(x ,x ,x ) =
1 2 3 1 2 3 1 2 3
s(D)(x ,x ,x ) = s ◦s ◦···◦s (x ,x ,x ), where s (·) represent the function s(·) at stage i. The
1 2 3 D−1 D−2 0 1 2 3 i
circuit V(x ,x ,x ), which computes s(D)(x ,x ,x ) links the D circuits V (x ,x ,x ) that compute the
1 2 3 1 2 3 s 1 2 3
function s(x ,x ,x ). The three output bits for s (·) at stage k become three input bits of s (·) at stage
1 2 3 k k−1
k−1.
Let the output of the circuit be stage 0. The input stage has the largest stage index. Consider the
general case. Let C (u) be the number of copies of species u in stage k. If u is computed by a gate g, we
k
let C (u) = C(g). Let v be the variable v at stage k. As we have three output bits y ,y ,y in the
k i,k i 1,0 2,0 3,0
last layer (layer D), each bit y must have a copy of species to represent its 0,1-value (see Definition 5).
i,0
Thus,
C (y ) ≥ 1, C (y ) ≥ 1, C (y ) ≥ 1. (6)
D 1,0 D 2,0 D 3,0
When x x x is changed from 111 to 011 (by flipping x ), the output y y y is changed from 111 to
1 2 3 1 1 2 3
000. By Equations (1) and (2) and Lemma 2, we have
C (x ) ≥ C (y )+C (y )+C (y ). (7)
k 1,k k 1,k k 2,k k 3,k
When x x x is changed from 111 to 101 (by flipping x ), the output y y y is changed from 111 to
1 2 3 2 1 2 3
011. By Equations (1) and (3) and Lemma 2, we have Equation 8 below. When x x x is changed from
1 2 3
11111 to 110 (by flipping x ), the output y y y is changed from 111 to 101. By Equations (1) and (4) and
3 1 2 3
Lemma 2, we have Equation 9 below.
C (x ) ≥ C (y ). (8)
k 2,k k 1,k
C (x ) ≥ C (y ), (9)
k 3,k k 2,k
When y is equal to x as the output of s (·) becomes the input of s (·). We have
i,k i,k−1 k k−1
C (y ) ≥ C (x ) for i = 1,2,3. (10)
k i,k k−1 i,k−1
In each stage, the input to the function s(·) can reach all cases 000,011,101, 110,111 by adjusting the 3
input bits of the circuit. When the input is 111, the function s(·) gives the same output 111 at all phases.
Through a simple repetition of the above inequalities, we derive a 2Ω(D) volume lower bound.
C (x ) ≥ C (x )+C (x )+C (x )(by (7),(10)) (11)
k 1,k k−1 1,k−1 k−1 2,k−1 k−1 3,k−1
≥ C (x )+C (y ) (by inequality (8)) (12)
k−1 1,k−1 k−1 1,k−1
≥ C (x )+C (x ). (by inequality (10)) (13)
k−1 1,k−1 k−2 1,k−2
Leta ,a ,··· betheFibonacciseries witha = a = 1andrecursiona = a +a forallk > 1. By
0 1 0 1 k k−1 k−2
inequalities (6), (7), and the fact that every input bit affects the output bit in s(·), we have C (x ) ≥ 1
0 1,0
and C (x ) ≥ 1. This is because when the three input bits are 111, we need bit x to make the output
1 1,1 1
bits 111. By inequality (13), we have C (x ) ≥ a for all k ≥ 0.
k 1,k k
6. Conclusions and Open Problems
In this paper we show how bimolecular void rules, a subset of reaction rules with low power compared to
traditional CRNs, become capable of computing threshold formulas and circuits in the step CRN model
under gate-wise simulation. We also prove that simulating circuits under this technique requires an expo-
nential lower bound volume that matches the upper bound of our construction methods.
These results naturally lead to some promising future research directions. One approach is construct-
ing another method for simulating threshold circuits under only (2,0) rules. A more general simulation
technique could have the benefit of computing circuits without the exponential-sized volume gate-wise
simulation requires. Furthermore, our step CRN definition requires the system to reach a terminal config-
uration before moving to the next step. Relaxing this definition so that a system may reach a step without
entering a terminal configuration can make the model more valuable to general CRNs, where reachability
to a terminal configuration is not guaranteed.
References
[1] Robert M. Alaniz, Bin Fu, Timothy Gomez, Elise Grizzell, Andrew Rodriguez, Robert Schweller, and
Tim Wylie. Reachability in restricted chemical reaction networks, 2022. arXiv:2211.12603. arXiv:
2211.12603.
[2] Rachel Anderson, Alberto Avila, Bin Fu, Timothy Gomez, Elise Grizzell, Aiden Massie, Gourab
Mukhopadhyay, AdrianSalinas, RobertSchweller, EvanTomai, andTimWylie. Computingthreshold
circuits with void reactions in step chemical reaction networks, 2024. arXiv:2402.08220. arXiv:
2402.08220.
[3] Dana Angluin, James Aspnes, Zo¨e Diamadi, Michael J. Fischer, and Ren´e Peralta. Computation in
networks of passively mobile finite-state sensors. Distribed Computing, 18(4):235–253, mar 2006.
12[4] Dana Angluin, James Aspnes, and David Eisenstat. A simple population protocol for fast robust
approximate majority. Distributed Computing, 21:87–102, 2008.
[5] Dana Angluin, James Aspnes, David Eisenstat, and Eric Ruppert. The computational power of
population protocols. Distributed Computing, 2007.
[6] Rutherford Aris. Prolegomena to the rational analysis of systems of chemical reactions. Rational
Mechanics and Analysis, 19(2):81–99, jan 1965.
[7] Rutherford Aris. Prolegomena to the rational analysis of systems of chemical reactions ii. some
addenda. Rational Mechanics and Analysis, 27(5):356–364, jan 1968.
[8] Adam Arkin and John Ross. Computational functions in biochemical reaction networks. Biophysical
journal, 67(2):560–578, 1994.
[9] Z Beiki, Z Zare Dorabi, and Ali Jahanian. Real parallel and constant delay logic circuit design
methodology based on the dna model-of-computation. Microprocessors and Microsystems, 61:217–
226, 2018.
[10] LucaCardelliandAttilaCsik´asz-Nagy.Thecellcycleswitchcomputesapproximatemajority.Scientific
reports, 2(1):656, 2012.
[11] Luca Cardelli, Marta Kwiatkowska, and Max Whitby. Chemical reaction network designs for asyn-
chronous logic circuits. Natural computing, 17:109–130, 2018.
[12] Ho-Lin Chen, David Doty, and David Soloveichik. Deterministic function computation with chemical
reaction networks. Natural computing, 13(4):517–534, 2014.
[13] Matthew Cook, David Soloveichik, Erik Winfree, and Jehoshua Bruck. Algorithmic Bioprocesses,
chapter Programmability of Chemical Reaction Networks, pages 543–584. Springer, 2009.
[14] Neil Dalchau, Harish Chandran, Nikhil Gopalkrishnan, Andrew Phillips, and John Reif. Probabilistic
analysis of localized dna hybridization circuits. ACS synthetic biology, 4(8):898–913, 2015.
[15] Samuel J Ellis, Titus H Klinge, and James I Lathrop. Robust chemical circuits. Biosystems,
186:103983, 2019.
[16] Abeer Eshra and Ayman El-Sayed. An odd parity checker prototype using dnazyme finite state
machine. IEEE/ACM Transactions on Computational Biology and Bioinformatics, 11(2):316–324,
2013.
[17] Daoqing Fan, Yongchao Fan, Erkang Wang, and Shaojun Dong. A simple, label-free, electrochem-
ical dna parity generator/checker for error detection during data transmission based on “aptamer-
nanoclaw”-modulated protein steric hindrance. Chemical Science, 9(34):6981–6987, 2018. doi:
10.1039/C8SC02482K.
[18] DaoqingFan,JunWang,JiawenHan,ErkangWang,andShaojunDong.Engineeringdnalogicsystems
with non-canonical dna-nanostructures: Basic principles, recent developments and bio-applications.
Science China Chemistry, 65(2):284–297, 2022.
[19] Hua Jiang, Marc D Riedel, and Keshab K Parhi. Digital logic with molecular reactions. In Intl. Conf.
on Computer-Aided Design (ICCAD), ICCAD’13, pages 721–727, 2013.
[20] Richard M. Karp and Raymond E. Miller. Parallel program schemata. Journal of Computer and
System Sciences, 3(2):147–195, 1969.
13[21] Yu-Chou Lin and Jie-Hong R Jiang. Mining biochemical circuits from enzyme databases via boolean
reasoning. In 39th Intl. Conf. on Computer-Aided Design, pages 1–9, 2020.
[22] David C Magri. A fluorescent and logic gate driven by electrons and protons. New Journal of
Chemistry, 33(3):457–461, 2009.
[23] Shay Mailloux, Nataliia Guz, Andrey Zakharchenko, Sergiy Minko, and Evgeny Katz. Majority and
minority gates realized in enzyme-biocatalyzed systems integrated with logic networks and interfaced
with bioelectronic systems. The Journal of Physical Chemistry B, 118(24):6775–6784, Jun 2014.
doi:10.1021/jp504057u.
[24] Carl Adam Petri. Kommunikation mit Automaten. PhD thesis, Rheinisch-Westf¨alischen Institutes fu¨r
Instrumentelle Mathematik an der Universit¨at Bonn, 1962.
[25] Lulu Qian and Erik Winfree. Scaling up digital circuit computation with dna strand displacement
cascades. science, 332(6034):1196–1201, 2011.
[26] Lulu Qian and Erik Winfree. A simple dna gate motif for synthesizing large-scale circuits. Journal of
The Royal Society Interface, 8(62):1281–1297, Feb 2011.
[27] David Soloveichik, Matthew Cook, Erik Winfree, and Jehoshua Bruck. Computation with finite
stochastic chemical reaction networks. natural computing, 7(4):615–633, 2008.
[28] Chris Thachuk, Erik Winfree, and David Soloveichik. Leakless dna strand displacement systems.
In 21st International Conference on DNA Computing and Molecular Programming, DNA’15, pages
133–153. Springer, 2015.
[29] Erik Winfree. Chemical reaction networks and stochastic local search. In 25th Intl. Conf. on DNA
Computing and Molecular Programming, DNA’19, pages 1–20, 2019.
[30] Wei Xiao, Xinjian Zhang, Zheng Zhang, Congzhou Chen, and Xiaolong Shi. Molecular full adder
based on dna strand displacement. IEEE Access, 8:189796–189801, 2020.
14