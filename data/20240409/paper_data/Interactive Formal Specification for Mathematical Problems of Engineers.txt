Interactive Formal Specification
for Mathematical Problems
of Engineers
WaltherNeuper
JohannesKeplerUniversity
Linz,Austria
walther.neuper@jku.at
Thepaperpresentsthesecondpartofaprecisedescriptionoftheprototypethathasbeendeveloped
inthecourseoftheISACprojectoverthelasttwodecades. Thispartdescribesthe“specify-phase”,
whilethefirstpartdescribingthe“solve-phase”isalreadypublished.
Inthespecify-phaseastudentinteractivelyconstructsaformalspecification.TheISACprototype
implementsformalspecificationsasestablishedintheoreticalcomputerscience,however,theinput
language for the construction avoids requiring users to have knowledge of logic; this makes the
systemusefulforvariousengineeringfaculties(andalsoforhighschool).
ThepaperdiscussesnotonlyISAC’sdesignofthespecify-phaseindetail,butalsogivesabrief
introductiontoimplementationwiththeaimofadvertisingthere-useofformalframeworks(inclusive
respectivefront-ends)withtheirgenerictoolsforlanguagedefinitionandtheirrichpoolofsoftware
componentsforformalmathematics.
1 Introduction
Since its beginnings more than two decades ago the ISAC project strives for a generally usable system
formathematicseducation,whichmightcoveramajorpartofeducationalscenarios,posingandsolving
problemswhichcanbestbetackledbymathematicalmethods. Thispaperpresentsthesecondpartofa
concisedescriptionoftheprototypethathasbeendevelopedinthecourseoftheproject,thedescription
oftheso-calledspecify-phase,whilethefirstpartdescribingthesolve-phaseisalreadypublished[15].
The specify-phase first addresses the “what to solve”, while the solve-phase addresses the “how to
solve” later in the process of problem solving — an important conceptual separation in the education
of engineers. In terms of computer mathematics the fist phase concerns a transition from facts in the
physical world (captured by text or figures) to abstract notions of mathematics (mainly captured by
formulas). And in terms of educational science and psychology this first phase concerns a transition
fromintuitiveandassociativehumanthinkingtohandlingofabstractformalentitiesaccordingtoformal
logic.
Asuccessfultransitionresultsina“formalspecification”(tobeexactlydefinedin§2.2Pt.2onp.123),
sothesubsequentsolve-phaseresidesexclusivelyintheabstractareaofcomputatermathematics,where
Lucas-Interpretation [15] is able to automatically generate “next step guidance” [5] and reliable checks
oflogicalcorrectness—thispaper, however, addressestheprecedingphase, morechallenginginterms
ofcomputermathematicsandintermsofpsychology.
The latter point will be touched on in this paper only by relating it here to recent advances in Ar-
tifical Intelligence, where ChatCPT for instance, achieved great public attention, even among computer
mathematicians [3]. A software, which given a textual description of mathematical problems is able to
J.Narboux,W.NeuperandP.Quaresma(Eds.):Workshopon ©W.Neuper
TheoremprovingcomponentsforEducationalsoftware2023(ThEdu’23) Thisworkislicensedunderthe
EPTCS400,2024,pp.120–138,doi:10.4204/EPTCS.400.8 CreativeCommonsAttributionLicense.W.Neuper 121
convincingly reason about relevant facts, to react to supplementary remarks and even come up with a
solution for the problem and is able to justify the solution — doesn’t it outperform software of formal
mathematics,inparticular,mightitoutperformtheISACprototype? Inspiteofthisseriousquestion,the
present step of development in the ISAC project continues to build the prototype solely upon the proof
assistant Isabelle [19]. Presently without systematic experiments and detailed examination, the ISAC
project is aware, that integrations of AI technologies and formal mathematics are a vivid research topic
(see, for instance, [2, 9]). And the description of our conservative approach contains hints at a “dialog
guide”anda“usermodel”,whichwillbenecessarytoadaptthepoweroftheISACprotoype(andsystem,
sooner or later) to the needs of the user, the student – and in such future development the ISAC project
willcomebacktoAI.
The present description, of how the ISAC prototype handles the specify-phase, is partly a position
paper in that it omits the justification for user requirements (already published in [16, 18, 17]) and not
even evaluates them (which shall be more informative in a broader educational setting in the future).
And partly the description reports technical details how design and implementation attempts to realise
theserequirements; asecondaryobjectiveofthedescriptionistomotivatethereuseofgenerictoolsfor
languagedefinitioninproofassistantsandtheirrichpoolofsoftwarecomponentsforformalmathematics
andalsotheirfront-ends—andnottore-inventthewheelagainandagainineducationalmathsoftware
development.
The paper has another special feature, the lack of related work — because there seems none to be
tothebestknowledgeoftheauthor. TheThEduworkshopserieswerefoundedtopromoteactivitiesfor
thecreationofsoftwaregenerallyusefulformathematicseducation. Therehavebeennotablesuccesses
withgeometrysoftwareandsoftwaretoteachmechanicalreasoninginacademia,butsoftwaretosupport
learninginthemostgeneraleducationsettings,mathsproblemsolving,stilldoesnotexist.
Thereisanactualreasonforwritingthispapernow: ItbecameapparentthattheJava-basedfront-end
of the ISAC prototype cannot catch up with recent development of front-ends in mathematics software:
proofassistantsmakesemanticinformationtransparenttotheuser, theymakeformulasadooropenfor
agreatportionofmathematicsknowledgejustbymouse-click. Sothisleadtotheharddecisiontodrop
the Java-based front-end, i.e. about thirty valuable student projects 1 and to start shifting ISAC’s code
in between Isabelle’s proof machinery and Isabelle’s upcoming new front-end Isabelle/VSCode. The
first step in this shift is additionally motivated by a lucky technical coincidence: Isabelle’s formulas
(terms,inrespectivediction)arelinear sequencesof(veryspecific)characters–andsoareformulason
the Braille display2. Thus ISAC engages in the “A-I-MAWEN” project aiming at an Accessible 3 and
Inclusive4 MathematicsWorkingEnvironmenttakingadvantagefromVSCode’saccessibilityfeatures;
andIsabelleenjoyscollaborationonitsupcomingnewnewfront-end[11,23].
The paper is organised as follows. After the introduction first come user requirements, as clarified
in the ISAC project. The requirements are partitioned in general ones in §2.1 and ones addressing the
specify-phasein§2.2.
Afteradefinitionof“formalspecification”thedesignofinteractioninthespecify-phaseisdescribed
byuseofarunningexamplegivenin§3.1. §3.2describesthetransitionfromtextandfiguresintoformal
mathematics, §3.3 turns to the most essential features, freedom in input and freedom to pursuevariants
1https://isac.miraheze.org/wiki/Credits
2https://en.wikipedia.org/wiki/Refreshable_braille_display
3https://en.wikipedia.org/wiki/Accessibility
4https://en.wikipedia.org/wiki/Inclusion_(education)122 FormalSpecificationforEngineers
in problem solving. §3.4 shows, what kinds of feedback can be given in the specify-phase. And §3.5
addresses problem-refinement, a particularly sketchy part in the ISAC prototype. The final section §3.6
concernsthetransitionfromthespecify-phasetothesolve-phase.
Since the paper also wants to advertise the generic tools of proof assistants for defining new input
languages, in particular the tools of Isabelle, the section on implementation is detailed as follows. §4.1
shows how elegantly ISAC’s input language for the specify-phase can be implemented in Isabelle/Isar,
§4.2 goes into detail with handling semantics of the input. Analogously to the solve-phase also the
specify-phase is organised in steps introduced in §4.3. A specific detail is refinement of equations dis-
cussedin§4.4. §4.5addressesefficiencyconsiderationsandfinallyin§4.6preconditionsaredescribed,
whichrequireevaluationbyrewriting. §5givesabriefsummaryandconcludesthepaper.
2 User Requirements
ISACaimsataneducationalsoftwareandsodesignanddevelopmentstartedwithanalysingtherequire-
ments, which a student places on the system when using it according to the introduction. The require-
mentscaptureandrequirementsanalysisintheISACproject5arealreadypublishedin[16,18,17]. Here
therequirements6. arekeptasshortaspossible,arerestrictedtothespecify-phaseandservetointroduce
the system features from the users point of view; the descriptions of respective implementation details
in§3justifytherequirementsmoreorlessexplicitlybybackwardreferences. However,firstcomesome
generalconsiderations.
2.1 FoundationalaxiomsaboutUserRequirements
ISAC’s decision to build software on top of reasoning technology – for maths education at high school
and academic engineering courses, this decision is novel and opens up novel educational settings. The
efficiency of these setting shall be researched thoroughly. As soon as tracing data7 from the interac-
tion with such tools become available, interesting discussions in educational research of mathematics
educationcanbeexpected.
Until then the following requirements are considered as abstract and so far from concrete usability
testing that these requirements are stated as axioms, axioms advocating software models to learn by
interaction,nottolearnbyateachersexplanationprimarily:
• Acompletemodelofmathematicsshallcompriseallsoftwaretoolsrequiredtosolveaproblem
athand, suchthatastudentneednotswitchbetweendifferentsoftwareapplications: theproblem
statement,thetextbookwithbackgroundtheoryandexplanation,theformulary,probablyanother
textbook with a boilerplate for solving the problem at hand, and last not least an electronic note-
bookforinteractiveconstructionofasolutionfortheproblem.
• A transparent model of mathematics shall be open for all kinds of inquiry of the underlying
mathsknowledge: Whatdataisrequiredtoprobablydescribeagivenproblem? Whatisrequired
as input, what is expected as output? What are the types of the respective data types? What are
the constraints (preconditions) on the input? What pattern does the problem at hand match, what
are similar problems? And at the transition to the solve-phase there are further questions to be
answeredbythesystem: Whichmethodscouldbeappropriateforfindingasolution? Etc.
5https://isac.miraheze.org/wiki/History
6ThislistwillgointotheISACdocumentationandsupersedestheolddocumentation[20]
7Therearegoodexperienceswithlogginguser-interactioninISAC[10]W.Neuper 123
• An interactive model of mathematics shall support step-wise construction of a solution to a
givenproblem. Eachstepischeckedforcorrectnessandjustifiedaccordingtotheaboveaxiomof
“transparency”. Sointeractionfollowstheprincipleof“correctbyconstruction”.
ISAC’sbasicdesignisnotembossedtomimicahumanlecturerorteacher,ratherthestudentshalllearn
independently from a software model, which clearly represents an essence of mathematics. In fact,
if mathematics is the “science to mechanise thinking” (Bruno Buchberger 8), then this science is most
appropriateonetobemodelledoncomputers,essentialscanbebeststudiedthereandprovertechnologies
providethemostpowerfultools[14]fordevelopingtools,whichgivejustificationsandexplanations.
ExperienceswithISAC indicatethatthehintof“mechanisesthinking”ishelpfulforstudentsatany
age, helpful to chase the omnipresent suspicion that mathematics is magic. Just watch a power user of
aproofassistant,howsheorheplaysaroundwithtextsnippetsinordertofindsolutions(afteracoarse
ideaofasubjectmatteroraproofhasbecomeclear).
2.2 UserRequirementsfocusingSpecify-Phase
Now, what follows are the requirements which serve to pass the specify-phase successfully, to come
fromhumanimaginationofaproblem(triggeredbyaninformaltextorafigureorwhatever)toaformal
representation,appropriatetobetackledwithinsoftware.
1. As an educational software ISAC must be intuitive such that a newbie can easily learn to use the
systembyinteractingwithtrialanderror.
2. Thesystemensures“correctnessbyconstruction”whengivenaformalspecification(definition):
Two lists of terms are given, input in and output out. And given are two predicates: The pre-
condition Pre(in) constrains the elements of the input to reasonable values. The postcondition
Post(in,out)relatesinputandoutput(andthuscharacterisesthekindofproblem).
Thisdefinitionisaccordingto[8]andrestrictsthekindofproblemsacceptedbythesystem.
3. Ifastudentgetsstuck,thesystemcanproposeanextstep,i.e. asingleelementofthespecifica-
tion,whichisstillmissing(equivalenttoLucas-Interpretation[15]).
4. ISAC tries to raise students awareness of different operational power in different number ranges
(e.g. in the complex numbers each polynomial has roots, in the real numbers it may have none).
ThusitrestrictsIsabelle’scontextstoparticulartheories,forinstancetoInt.thy,toReal.thy
ortoComplex.thy.
5. No need for formal logic: The formal specification of a problem must be comprehensible for
students in an academic course in engineering disciplines (and also at high school) without any
instruction in formal logic. So a Specification is given by Given (the input according to Pt.2),
Where(theprecondition)andFind (theoutput, i.e. thesolutionoftheproblem)andRelate(tobe
describedinthenextpoint).
6. Relatecapturesessentialpartsofthepostconditionsuchthatthedescriptionavoidslogicalopera-
tors(like∃,∀,∧,∨etc)accordingtorequirementUR.5. ThisisacrucialdesigndecisionofISAC
whichwillbeillustratedbytherunningexample.
7. In general, mathematical problems can be solved in many ways. Thus a Specification must be
open for variants which are handled within one and the same process of solving the problem.
Therunningexample(§3.3below)illustratesthreevariants.
8https://en.wikipedia.org/wiki/Bruno_Buchberger124 FormalSpecificationforEngineers
8. The transition from an informal problem description, given by text and by figures, to the formal
specification must not be overstrained by issues of formal notation. The problem is well-known
fromeducationaluseofalgebrasystems[7]. ThusISAC willgivethefollowingtemplatesforthe
respectivetypes(examplesaregiveninFig.1below):
• [__=__,__=__]forlistsofequalities,forexampleConstants[a=1,b=2]
• [__,__]forlistsofelementswithout=,forexampleAdditionalValues[a,b,c]
• "__"fortheories(asstrings),forexampleTheory_Ref ”Diff_App”
• "__/__"forstringlists,forexampleProblem_Ref ”univariate_calculus/optimisation”
• __forarbitraryinput(notinvolvingtheabovecases),forexampleMaximumA.
9. WithintheSpecificationtheModelservestwopurposes: fortheProblem_Ref itshowsthefields
from Given to Relate according to Pt.5 and for Method_Ref it shows the guard of the program
guiding the Solution; for details see [15]. A toggle switches between the two purposes (in the
examplesbelowindicatedby⊗and⊙,theformerforactivationandthelatterforidle).
10. The specify-phase can be skipped on predefined settings. This requirement is more important
than it seems: ISAC may be not only be used for solving new problems, but also for exercising
knownproblems,forinstancedifferentiation. InthatcaseSpecificationwillbefoldedinsuchthat
thesolve-phasewillbestartedimmediatelybySolution.
11. ASpecificationcanbecompletedautomatically(bypushingabuttonorthelike),incaseastudent
wants to enter the solve-phase right now (and in case the course designer allows to do so by the
predefinedsettings).
12. In equation solving the system can assist in finding an appropriate type of equation. That
means, in this special case the system is capable of problem refinement (which is under ongoing
research on more general problem types). The user requests this assistance by easy-going means
(bypushingabuttonorthelike).
13. Thereisthefollowingfeedbackonaspecification’selements,indicatedattheappropriateloca-
tionoftherespectiveelementonscreen:
• Correct: Thereisprobablynospecificindication.
• Syntax: Thisfeedbackcanbenecessary,iftheuserswitchestheModelsuddenlyfromProb-
lem_Ref toMethod_Ref orviceversa,seeUR.9
• Incomplete: Inputisincomplete,inparticularelementsoftypelist.
• Superfluous: Aninputcanbesyntacticallycorrect,buthavenoevidentrelationtotheprob-
lemathand.
TheseuserrequirementsevolvedalongsidetwodecadesofdevelopmentintheISAC project,whichwas
close to educational practice all the time due to the involved persons; and the requirements have been
checkedinseveralfieldtests[16,18,17].
The requirements raise a lot of questions with respect to detailed software design. Some of the
questionswillbeclarifiedalongsidepresentingtherunningexamplein§3below.
3 Design of the Specify-Phase
In the specify-phase a student interactively constructs a formal specification (definition in §2.2 Pt.2 on
p.123),whichthenenablesLucas-Interpretation[15]toautomaticallygenerateuserguidance. Thecon-
cept of formal specification involves logic, which is not taught at many engineering faculties (and notW.Neuper 125
at all at high school), however. Thus, according to §2.2 requirement no.2 on p.123, respective logic is
hiddenfromtheuser;forexplainingthatapproachweusearunningexample.
3.1 ARunningExample
The running example is re-used from [11]: There it was used to illustrate what has been achieved in
the old prototype and what is planned for developing a “mathematical working environment”, whereas
in this paper the example is used to explain the design and implementation of the part of the prototype
supportingthespecify-phase.
The efficiency of an electrical coil depends on the mass
ofthekernel. Givenisakernelwithcross-sectionalarea,
determinedbytworectanglesofthesameshapeasshown
inthefigure.
Givenaradiusr=7,determinethelengthuandwidthv
of the rectangles such that the cross-sectional area A
(andthusthemassofthekernel)isamaximum.
Inancienttimesthiskindofexamplebelongedtoawell-establishedclassofexamplesattheendofthe
mathematicscurriculumatGermanspeakingGymnasiums,“Extremwertaufgaben”. Nowadaysitcanbe
foundintextbooksforelectricalengineering.
3.2 FormalisationofProblemsandAuthoring
In order to meet UR.3 it is necessary to prepare data for each example, where automated generation of
userguidanceisdesired[13]. ClassesofexamplesarecollectedtoProblems;thisconformswithteaching
experience: certainclassesfocusoncertainproblempatterns,whichareexplainedandexercisedbymore
orlessdifferentexamples.
Most of the lecturers and teachers want to expose their personal collection of exercises to their
students;solecturersshouldbeenabledtoimplementtheseindependentlyinthesystem,withoutfurther
expertise – so authoring for lecturers needs to be supported eventually for type Formalise.T below.
However, the implementation of problem patterns Model_Pattern.T involves specific knowledge in
computer mathematics – so maths authoring needs to be supported in addition, eventually. “Maths
authors”mightbelecturersofspecificacademiccourses,bookauthorsandothers.
Accordingtothisdistinctiontherearethefollowingtwodata-types9:
01 type Formalise.T = model * refs;
01 type Model_Pattern.T =
02 (m_field * (* field "Given", "Find", "Relate" *)
03 (descriptor * (* for term *)
04 term)) (* identifier for instantiating term *)
05 list;
06 (*does NOT contain preconditions "Where"; these have no descriptor*)
9WeadaptML[12]syntaxforreadabilitypurposes:insteadof"typeTinstructureFormalise"wewrite"Formalise.T"."(*"
and"*)"enclosecomments,whichareoutsideMLsyntax.Thenumbersontheleftmarginservereferencinganddonotbelong
totheMLcode.126 FormalSpecificationforEngineers
The type Formalise.T consists of a (preparatory form of) model and refs; the latter are ex-
plained below in §3.6. Model_Pattern.T is designed according to UR.5. Each term is accompa-
nied by a descriptor, which informs the user about what is requested from him to input. Pairs of
(descriptor * term) are assigned to m_fields according to UR.5. The special values for the run-
ning example are as follows, where the descriptors are Constants, Maximum, AdditionalValues,
Extremum,SideConditions,FunctionVariable,DomainandErrorBound:
01 val demo_example = ("The efficiency of an electrical coil depends on the mass
of the kernel. Given is a kernel with cross-sectional area
determined by two rectangles of same shape as shown in the
figure. Given a radius r = 7, determine the length u and
width v of the rectangles such that the cross-sectional
area A (and thus the mass of the kernel) is a maximum.
+ Figure",
02 ([
03 (*Problem model:*)
04 "Constants [r = (7::real)]", "Maximum A", "AdditionalValues [u, v]",
05 "Extremum (A = 2 * u * v - u \<up> 2)",
06 "SideConditions [((u::real) / 2) \<up> 2 + (v / 2) \<up> 2 = r \<up> 2]",
07 "SideConditions [(u::real) / 2 = r * sin \<alpha>, v / 2 = r * cos \<alpha>]",
08 (*MethodC model:*)
09 "FunctionVariable u", "FunctionVariable v",
10 "FunctionVariable \<alpha>",
11 "Domain {0 <..< r}",
12 "Domain {0 <..< \<pi> / 2}",
13 "ErrorBound (\<epsilon> = (0::real))"]: TermC.as_string list,
14 ("Diff_App", ["univariate_calculus", "Optimisation"],
15 ["Optimisation", "by_univariate_calculus"]): References.T)): Formalise.T
The text in line 01 exceeds the line limit, it has already been shown with the problem statement of
the running example in §3.1. The reader may be surprised by the multiple entries for the descriptors
SideConditions, FunctionVariable and Domain; this is due to variants introduced in §3.3 below
—thisrepresentationofvariantsisconsideredintermediate,itwaseasytoimplementandwillbeupto
further refinement. The lines 14 and 15 represent the refs introduced above in Formalise.T and ex-
plainedin§3.6below. Theattentivereaderwillalsonoticethattheitemsoftheexample’smodelarenot
assignedtoanm_field(line02onp.125),ratherthedescriptoristhemeanstorelateitemsbetween
different data structures, in this case between Formalise.model and the problem below defining the
runningexample:
01 problem pbl_opti_univ : "univariate_calculus/Optimisation" =
02 \<open>eval_rls\<close> (*for evaluation of 0 < r*)
03 Method_Ref: "Optimisation/by_univariate_calculus"
04 Given: "Constants fixes"
05 Where: "0 < fixes"
06 Find: "Maximum maxx" "AdditionalValues vals"
07 Relate: "Extremum extr" "SideConditions sideconds"
The above problem assigns the elements of the model (in ISAC we call an element of a model an item
in order not to confuse with elements of lists or sets) to a respective m_field. As already mentioned,
the assignment is done via descriptors accompanied with place-holders (fixes, maxx, etc; see line
03 in type Model_Pattern.T on p.125) – these are instantiated on the fly with values of the concrete
exampleselectedbytheuser.W.Neuper 127
It is the task of a mathematics author to decide the structure of the model such that it covers an
appropriate collection of examples, where a respective Model_Pattern.T of a problem is instantiated
for several examples by values of a Formalise.T. For instantiation of the model for a problem an
environmentisrequired,forinstanceforthedemo_exampletheenvironment
[ (”fixes”, [r=7]), (”maxx”, A), (”vals”, [u,v]),
(”extr”, (A=2∗u∗v−u↑2)), (”sideconds”, [(u/2)↑2+(v/2)↑2=r↑2])
]
isrequired.
Anotherreasonforthislateassignmentisthatoneandthesameitemmaybelongtom_fieldRelate
for a problem but to Given for a method, see §3.6. Finally it may be remarked that the identifier
"univariate_calculus/Optimisation"canbefoundinamoreconvenientformatalreadyonp.126
online14).
3.3 FreedomofInputandVariantsinProblemSolving
The model described above is presented 10 to students as shown in the screen-shot below. There the
Figure1: ThetemplateforstartingaSpecification.
descriptors(Constants,etc)arefollowedbytemplatesgivinghintsontheinputformataccordingto
UR.8 in order to help students to cope with the troublesome transition to exact formal representation.
The Model is embedded into the Specification which also contains References explained in §3.6
below. TheabovetemplateiscompletedinFig.2onp.128andthereadermayrefertotheRelateinthe
Modelwhenreadingthenextparagraph.
RepresentationinfieldRelateissimplified suchthatastudentneedsnotencounterformallogic
according to UR.6. Fig.2 shows that for the demo_example Extremum and SideConditions actually
aretheessentialpartsofthepostcondition,whichcharacterisesaproblembyrelatingGivenandFind:
(A=2∗u∗v−u↑2) ∧ ((u/2)↑2+(v/2)↑2=r↑2) ∧
∀A′u′v′ . (A′=2∗u′∗v′−u′↑2) ∧ ((u′/2)↑2+(v′/2)↑2=r↑2) ⇒A′<A
10§4.1willshowhoweasilytheformatpresentedinthescreen-shotcanbedefinedinIsabelle/Isar.128 FormalSpecificationforEngineers
Students at engineering faculties usually are not educated in formal logic (computer science is an ex-
ception). A formula containing ∧ or ⇒ would distract them from actual problem solving. Thus ISAC
decidedtoextracttheessentialpartsofthepostcondition:
Extremum(A=2∗u∗v−u↑2),SideConditions(u/2)↑2+(v/2)↑2=r↑2
These parts also are sufficient to automatically generate user-guidance according to UR.3 (by enabling
Lucas-Interpretation[13]tofindanextstep).
Input should not only be easygoing with respect to format and with bypassing formal logic. Ac-
cording to UR.7 the system should cope flexibly with semantics, it should also adapt to fresh ideas of
a student and support various variants in solving a particular problem. Let us look at Fig.2 with the
completedSpecificationandaskanimportantquestion: Whatcouldastudenthaveinmindwhenen-
Figure2: ThecompleteSpecification.
counteringtheproblemstatementonp.125? Lookingatthefigureonp.125,heorshemightfocusonthe
widthuandthelengthv,andapplyPythagorastheorem(u/2)↑2+(v/2)↑2=r↑2. Butstudentsmight
focusaswellontheangleα andformalisetheSideConditionsasu/2=r∗sinα, v/2=r∗cosα.
And what if a student has an eye for simple solutions and takes as SideConditions either u =
cosα,v=sinα oru↑2+v↑2=4∗r↑2? Thelatterissemanticallyequivalent(equivalentinthisspecific
example) to the variant shown in Fig.2. So, during the whole specify-phase, each formula input by a
studentmustbecheckedforequivalencewiththeformulaspreparedintheFormalise.T.Suchchecking
isdoneviarewritingtoanormalform. Thismightbequitetedious,forinstancewithequationsinvolving
fractionslikeinshowingequivalenceoftheequationsu↑2+v↑2=4∗r↑2 ≡ (u)↑2+(v)↑2=r↑2)
2 2
Anopendesignquestion,a“pattern-matching-language”? Nowwearereadytoaddressthedesign
decisionrelatedtotheformatgivenonp.126,whichhasbeenidentifiedaspreliminaryandsimplisticfor
thepurposeofsimpleimplementation. Muchinformationisredundantthere,apparently,andontheother
hand interesting structural properties are hardly visible. For instance, the student’s decision whether to
taketheFunctionVariable uortheFunctionVariable vfordifferentiation(see§3.6),thisdecision
isfairlyindependentfromtheproblem’smodel–theModeljustmustnorefertoα.
The need for a separated language for Specification becomes definitely clear when considering
the precondition and the postcondition (the latter introduced above on p.128). The precondition must
evaluatetotrueforaSpecificationtobevalid,andthepostconditionmustbetrueforaSolutionto
beacceptedbythesystem.W.Neuper 129
InordertoevaluatepreconditionWhere0<rtotrue,weneedtocreatetheenvironment[(r,7)]from
Constants. With the demo_example this is straight forward, but if we had Constants [s = 1, t =
2]wealreadyneedtoemploysometrickerywithindexing. Andwhataboutthepostcondition?
extr ∧ sideconds ∧
∀ maxx′ funvar′. extr′ ∧ sideconds′ ⇒maxx′<maxx
Howcouldsucha“pattern-matching”descriptionbeinstantiatedtothepostconditiononp.128? Instanti-
atedreliably,suchthatIsabellecouldevaluateittotruewiththevaluesfoundbySolution? Howwould
thevariantwiththeα workout,whichhastwoSideConditions?
Answeringtheopenquestionabovemaygoinparalleltoimplementationofalargerbodyofexam-
plesandrespectiveproblems. Fieldtests[18,16,17]intheISAC projectwerebasedonlimitedcontent
andthusdidnotgainmuchexperiencewithavarietyofproblemswithvariantsandrespectiveflexibility
ofthesystem;onehastowaitforimplementationofmorevariousexamplesandproblems.
3.4 InteractivityandFeedback
TheprevioussectiondescribeshowISACmakesaSpecificationflexibleandopenforvariousvariants
insolvingaparticularproblem. Flexibilityinproblemsolvingmustbeaccompaniedbyflexibleinterac-
tivityandappropriatefeedback. FeedbackforinputtoaModelispredefinedbyUR.13andmodelledby
arespectivedatatypeasfollows(valuesareoftypeterm list)
01 datatype I_Model.feedback =
02 Correct of (descriptor * values) (* wrt. syntax and semantics *)
03 | Incomplete of (descriptor * values) (* for list types *)
04 | Superfluous of (descriptor * values) (* not found in Formalise.model *)
05 | Syntax of TermC.as_string (* in case of switching model *)
Theabovecodepluscommentsappearfairlyself-explaining. descriptorhasbeenintroducedalready.
In case of empty input, we shall have Incomplete (_, []) and display templates for input-format
according to UR.8. Syntax errors are handled very elegantly in Isabelle/PIDE (see §4.1); in case of
switching from the Model of the Problem_Ref to the Model of the Method_Ref (see §3.6 below) it
mightbeusefultokeepacopyofaninputwithsyntaxerrors. ItemscanbeSuperfluouseitherbecause
theyaresyntacticallycorrectbutnotrelatedtheModelunderconstruction,ortheybelongtoavariant,
whichhasnotyetbeendecidedfor. Forinstance,iftheModelisasinFig.2onp.128andthestudentadds
SideConditions [v=sinα], this item will be marked as Superfluous unless interactive completion
toSideConditions[v=sinα,v=cosα]anddeletionofacompetingitemlikeSideConditions[u↑
2+v↑2=4∗r↑2].
If a student gets stuck during input to a Model, then UR.3 allows him or her to request help. In the
specify-phase such help is given best by presenting a (partial – predefined setting!) missing item. But
outputofaModelwithitemdoesnotconformtoIsabelle’sdocumentmodel: ThecontentofanIsabelle
theory is considered a document which has to be checked by the system — Isabelle is in principle a
reactivesystem. Therearefewexceptionstothedocumentmodel,forinstance,whenSledgehammer[4]
findsintermediateproof-stepsonrequestandmetis11 displaystherespectiveproofsteps.
ISAC,incontrary,isdesignedasatutoringsystem,wherepartnersconstructaSpecificationand
a Solution in cooperation, where the user can propose a step while the system checks it and where
the student can request help such that the system can propose a step as well. Since here psychology of
11https://isabelle.in.tum.de/library/HOL/HOL/Metis.html130 FormalSpecificationforEngineers
learningisinvolved,a“userguide”componentshallbeinvolvedinthefuture,anda“usermodel”shall
providepersonalisation. ISAC’soriginalarchitectureplacedthecomponentsatthecenterofthesystem.
But now ISAC is being embedded in Isabelle and Isabelle/PIDE is already highly elaborated — where
willbetheplaceforthesecomponentsinIsabelle? Thisisoneofthemajoropenquestionsfor§4.
3.5 AutomatedSpecifications
Sometimes a user might not be interested in specification. For instance, when solving an equation, the
type of the problem and the respective Model_Pattern.T are clear, and only the hierarchy of problem
typeswouldhavetobesearchedfortheappropriatetype.
ISAC’soldJavafront-endhadaso-calledCAS-commandforthatsituation,whereonehadminimal
input,forinstancesolve(12−6·x=0, x). ThenISACcheckedthemostgeneralprecondition(an“=”in
theinput)andthenstartedabreadth-firstsearchinthetreeofequationsattheroot“univariate”,checking
insequencethetypeoftheinputterm,linear,root,polynomial,rational,complexortranscendental.
Fig.3 shows the currently available equations presented by the old Java fron-end. All these panels shall
Figure3: Thetreeofequations(middlepanel).
beredonebyIsabelle/PIDEviaIsabelle/VSCode.
Themoreinterestingquestionis,whetherthiscoarserefinementviapreconditionscanbegeneralised
toakindofmatching, whichinvolvesalsothepostcondition(seep.128); theoreticalbackgroundwould
mostlikelybetherefinementcalculus[1].
3.6 TransitiontotheSolve-Phase
Thesolve-phasetacklestheconstructionofaSolutionforagivenproblem,where“next-step-guidance”
isprovidedbyLucas-Interpretation[15]. ForthatpurposeLucas-Interpretationusesaprogram, andforW.Neuper 131
suchaprogramthevaluesspecifiedbyaModelinstantiatetheformalargumentsoftheprogramtoactual
arguments. So items move from Relate to Given and new items need to be added to the program’s
guard in order to provide the program with all data required for automatically construct a Solution.
ThustheModelfortheguardofthedemo_examplemightlookasshowninFig.4below.
Figure4: TheModelfortheMethod_Ref.
The reader might notice that the toggle ⊙⊗ has changed, indicating that the Model belongs to the
Method_Ref(Thetoggleisnotimplementedpresentlyandjustremindedofbyacomment).
SotheReferencescomeintoplay,theyraiselotsofopendesigndecisions: Weencounterinsightful
references into huge data collections; their representation will heavily depend on specific features of
VSCode (while the structure of theories, DAGs, has not even an interactive representation presently).
Shouldtheybecollapsedbysettings,iftheywoulddistractacertainclassfromproblemsolving? Should
studentsbeforcedtoinputReferences,andwhen?
AreasonableintermediatestepindevelopmentmightbethataModelcouldbeacceptedascomplete
(e.g. Fig.2)bythesystemevenwithemptyReferences(e.g. Fig.1)andaSolutioncouldbestarted.
TogglingtheModelbetweenModel_RefandMethod_Ref(theformershowninFig.2onp.128,the
latterinFig.4)willbeachallengeforimplementationinIsabelle/VSCode.
4 Implementation in Isabelle/Isar
This paper also intends to demonstrate that it is waste of resources to start development of educational
math software from scratch – nowadays users expectations on software are high such that an isolated
development cannot keep pace with the still rapidly evolving state of the art. This is particularly true
forfront-endtechnology. ISAC’slonglastingexperiencewithformulaeditorsclearlydemonstratesthat
unpleasantfact,whichenforcedISACtodroptenyearsoffront-enddevelopment.
This section is going to demonstrate simplicity of implementing a specific input language as intro-
duced in §3 above in one of the advanced proof assistants, in this case Isabelle. Isar [22] is the proof
languageofIsabelleandremarkably,thisisdefinedinagenericmannersuchthatalmostarbitraryformal
languagescanbedefined;foraparticularlyinterestingexamplesee[6].132 FormalSpecificationforEngineers
4.1 Isabelle’sOuterandInnerSyntax
Isabelle separates two kinds of syntax, an inner syntax for mathematical terms and an outer syntax
for Isabelle/Isar’s language elements. The latter is generic such that it allows for definition of various
language layers. And it is a pleasure to show how easily an ISAC Specification is defined such that
all inner syntax errors are indicated at the right location on screen, i.e. how easily all what is shown in
thescreen-shotsonthepreviouspagesareimplementedsuchthatsyntaxerrorsareshownappropriately:
01 keywords "Example" :: thy_decl
02 and "Specification" "Model" "References" "Solution"
TheabovetwolinesprepareIsartore-useavailableparsers12:
01 Outer_Syntax.command command_keyword\<open>Example_TEST\<close>
02 "prepare ISAC problem type and register it to Knowledge Store"
03 (Parse.name -- Parse.!!! (keyword\<open>Specification\<close> --keyword<:> --
04 keyword<Model> -- keyword<:> |-- Problem.parse_pos_model_input --
05 (keyword<References> -- keyword<:> |-- Parse.!!! References.parse_input_pos
06 )) >>
07 (fn (example_id, (model_input,
08 ((thy_id, thy_pos), ((probl_id, probl_pos), (meth_id, meth_pos))))) =>
09 Toplevel.theory (fn thy =>
10 let
11 val state = update_step example_id model_input
12 ((thy_id, thy_pos), ((probl_id, probl_pos), (meth_id, meth_pos)))
13 in set_data state thy end)));
With these two definitions done, one has in update_step only to provide appropriate calls of this
function:
01 fun term_position ctxt (str, pos) =
02 Syntax.read_term ctxt str
03 handle ERROR msg => error (msg ^ Position.here pos)
04 (*this exception is caught by PIDE to show "msg" at the proper location*)
The exception ERROR is caught by Isabelle/PIDE and, for instance, syntax errors detected by Syn-
tax.read_termaredisplayedattheproperlocationsonscreentogetherwithmsg. ThatisallwhatIsar
requires to check syntax of input as shown in the screen shots in the previous section and to indicate
errorsattheproperlocationonscreen.
The handling of semantic errors is accomplished with Isabelle/ML, Standard ML [12] enriched
with an abundant collection of tools for formal logic as well as for connection to the front-end via
Isabelle/PIDE[21]. Thiswillbeshowninthesequel.
4.2 InteractionandFeedback
Checking semantic appropriateness of user input to a Specification as described in §3 above, com-
prises a lot of questions: Does an item input to a Model belong to this particular example or is it just
Superfluous? If there a list is to be input, are all the elements present or are some missing (items
are Incomplete)? Is a Model complete with respect to a specified Problem_Ref? If Theory_Ref is
input,arealltheitemsofaModelstillparsedcorrectly(orcan,forinstance,”Rea+Imb”)notbeparsed
correctly,becausethespecifiedtheorydoesnotknowthetype“complex”)? Etc.
12In spite of Isabelle’s convenient latex extensions we still use verbatim, which displays “keyword<Specification>” as
clumsilyas“keyword\<open>Specification\<close>”W.Neuper 133
Thecentraldeviceforhandlingfeedbacktotheabovequestionsistheso-called
INTERACTION_MODEL with the type I_Model.T 13 (where variants is a list of integers and m_field
has been introduced by type Model_Pattern.T on p.125). Position.T establishes the reference to
thelocationonscreen:
01 type I_Model.single =
02 variants * (* pointers to variants given in Formalise.model *)
03 m_field * (* #Given | #Find | #Relate *)
04 (feedback * (* state of feedback for variables and values *)
05 Position.T); (* for pushing feedback back to PIDE *)
06 type I_Model.T = I_Model.single list;
feedback implements UR.13 and resembles the structure of datatype feedback in the presentation
layerasshownonp.129in§3.4. Thefirstthreecharacterssufficeforinternalnaming:
01 datatype I_Model.feedback =
02 Cor of (descriptor * (* a term identifying an item *)
03 (values)) (* of a particular example *)
04 | Inc of (descriptor * values) (* incomplete lists/sets,
if empty then output according to UR*)
05 | Sup of (descriptor * values) (* input not found Model *)
06 | Syn of TermC.as_string (* kept for P_Model.switch_pbl_met *)
4.3 Step-wiseConstructionofSpecifications
Step-wise construction is one of the axioms for ISAC’s design as captured on p.123. While step-wise
constructionappearsself-evidentforthesolve-phase,whereLucas-Interpretationsuggestsorchecksone
input formula after the other, this appears artificial for the specify-phase: one can input any item to a
Specification in any sequence, items of a Model as well as References. But there is also UR.3,
whichcallsforthesystem’sabilitytoproposeanextstep–andhereweare:
01 datatype Tactic.input =
02 (* for specify-phase *)
04 Add_Find of TermC.as_string (*add to the model*)
05 | Add_Given of TermC.as_string | Add_Relation of TermC.as_string
06 | Model_Problem (*internal*)
07 | Refine_Problem of Problem.id (*refine a Model_Pattern.T*)
08 | Refine_Tacitly of Problem.id (*internal*)
09 | Specify_Method of MethodC.id (*specify References*)
10 | Specify_Problem of Problem.id | Specify_Theory of ThyC.id
11 (* for solve-phase *)
12 | ...
TheaboveTacticsareshowntotheuser,whilesomeareusedonlyinternally;Refine_*willbeintro-
duced in §4.4 below. A variant stuffed with lots of data serve internal construction of a next step; the
listsbelowshowsonlysomeexamples:
01 datatype T = Add_Find’ of TermC.as_string * I_Model.T
02 | Add_Given’ of TermC.as_string * I_Model.T
04 | Add_Relation’ of TermC.as_string * I_Model.T
05 | Model_Problem’ of (*starts the specify-phase *)
13In ISAC’s code this definition is shifted into a separate structure Model_Def before the definition of the store of a
calculation,Ctree,whichstilllackstypepolymorphism134 FormalSpecificationforEngineers
06 Problem.id * (*key to a Problem.T Store.node*)
07 I_Model.T * (*model for the Problem *)
08 I_Model.T (*model for the MethoC *)
09 | Refine_Problem’ ...
4.4 RefinementofProblems
UR.12 calls for refinement, a respective motivation was given in §3.5. Here implementation details are
presented,becausethesubsequentsectionwilladdressefficiencyconsiderationraisedbyrefinement14.
AProblem.TisdefinedinanIsabelletheory;herethedefinitionofthemodel-patternoftherunning
exampleisshown. Thismodel-patterncoversalmostallexamplesofawell-knowntextbook,theitems
Figure5: Theproblem-patternfortherunningexample.
areidentifiedbythedescriptors;variableslikefixesaretobeinstantiatedfromaFormalise.model
as explained on p.127. The convenient representation in Fig.5 is stuffed with data required to solve a
problem(see,forinstance,the<eval_rls>)andexpandedtothetypeProblem.T:
01 type Problem.T =
02 {guh : Check_Unique.id, (* unique within Isac_Knowledge *)
03 mathauthors : string list, (* copyright etc *)
04 start_refine : References_Def.id, (* to start refinement with *)
05 thy : theory, (* allows to compile model, where_*)
06 cas : term option, (* CAS_Cmd *)
07 solve_mets : References_Def.id list,(* methods solving the T *)
08 where_rls : Rule_Set.T, (* for evaluation of preconditions*)
09 where_ : Pre_Conds.unchecked, (* preconditions as terms *)
10 model : Model_Pattern.T (* "#Given", "#Find", "#Relate" *)
11 }
BythistypeproblemsarestoredinatreeborrowedfromIsabelle;thekey["univariate_calculus",
Optimisation""] into this tree is created from the string "univariate_calculus/Optimisation"
inFig.5:
01 type store = (T Store.node) list
4.5 EfficiencyConsiderationswithParsing
Two decades ago, at the time when ISAC started with development, parsing required substantial re-
sources. Thusaspecificcomponent,O_Model.Twasshiftedin-betweenFormalise.model(p.126)and
theinteractionmodelI_Model.T(p.133).
14Bytheway,Lucas-Interpretation[15]isstraightenedconsiderablywhenequationsolvinginsub-problemsautomatically
refinestotheappropriatetypeofequationW.Neuper 135
01 type O_Model.single =
02 variants * (* pointers to variants given in Formalise.T *)
03 m_field * (* #Given | #Find | #Relate *)
04 descriptor * (* see Input_Descript.thy *)
05 values (* HOLlist_to_MLlist t | [t] *)
06 );
07 type O_Model.T = O_Model.single list;
Thisstructureiscreatedatthebeginningofthespecify-phase(byTactic.Model_Problem). Theterms
are already parsed, descriptor and values conveniently separated; also the variants are ready for
convenienthandling. AttheoccasionofparsingalsoanIsabelleProof_Contextisfedwiththetypesof
allvariablesinFormalise.model. Thisdischargesthestudentofthenecessitytoexplicitlyinputtypes.
Refinementoftypesofequations asintroducedbyUR.12isparticularlyresourcesconsuming: Fig.3
onp.130showsthatalreadytheoldprototypeimplementedquitealotoftypesofequations. Refinement
starts at the root ["univariate", "equation"] of the branch, an environment with respect to the
given equation has to be created from the I_Model.T and the current Model_Pattern.T, with this
environment for each node in the tree the respective "#Given" and "#Where" needs to be instantiated,
andlastnotleastthelatterrequiresevaluationbyrewriting(see§4.6below).
All that tasks act on terms, i.e. require parsing. If this is done during interactive problem solving,
responsetimewillgettohighevenwithmodernhardware. ThusnotonlyProblem.T(seedefinitionon
p.126) contains terms alreay parsed, but also Model_Pattern.T and other structures. These structures
(Model_Pattern.T,Problem.T,MethodC.TandError_Pattern.T)holdterms,wheretheexacttype
is not known at compile time, and where the type needs to be adapted to the current Problem.T. Thus
allthesestructureshaveafunction
01 val adapt_to_type Proof.context -> T -> T
andthesefunctionsinturncall
01 val adapt_term_to_type: Proof.context -> term -> term
whichisdefinedinstructureParseC.
4.6 Pre-ConditionsinProblemsandMethods
Pre-conditions are an essential part of a formal specification (definition in §2.2 Pt.2 on p.123). We
comparethedefinitiontoISAC’srepresentationofaModel(e.g. onp.127,p.128orp.131):
formalspecification ISAC’sModel
in Given
Pre(in) Where
out Find
Post(in,out) Relate
However,type Model_Pattern.T(defintiononp.125)doesnotcontainaprecondition(Pre(in),Where)
and so does the actual Model of a Problem.T (defintion on p.134; for specifics of Relate see p.127).
ThereasonisthattheroleofitemsinaModelistoconformwithaparticularFormalise.model(made
readybyparsinginI_Model.T)andwhetheritispresentornot–whereasapreconditionmustevaluate
to true in order to make a Model complete; this involves rewriting. The implementation details are as
follows.
01 type Pre_Conds.T = (bool * term) list;
02 type Pre_Conds.unchecked_pos = (term * Position.T) list
03 type Pre_Conds.checked_pos = bool * ((bool * (term * Position.T)) list)136 FormalSpecificationforEngineers
The role of preconditions is different from Model-items such that preconditions are stored only in a
Problem.T (accompanied by a Model) and evaluated by use of environments, which are generated on
theflyaccordingtoI_Modelactuallyinput:
01 val make_environments: Model_Pattern.T -> I_Model.T ->
02 Env.T * (env_subst * env_eval)
03 val check_pos: Proof.context -> Rule_Set.T -> unchecked_pos ->
04 Model_Pattern.T * I_Model.T -> checked_pos
5 Summary and Conclusions
This is the first concise description of how the ISAC prototype models the specify-phase. The specify-
phase concerns the transition from a problem statement given in the form prose text and/or illustrations
toaformalspecification.
The description starts with user requirements in §2 and thus presents the perspective of students
solvingexercisesinengineeringstudies(similarlearningscenarioscanbefoundinsecondaryschools).
Here is also the definition of the notion “formal specification” as given by input and output as well as
precondition and postcondition. §3 describes the design of the specify-phase with regard to the user
requirementsandidentifiesopendesignissues. Thedescriptionoftheimplementationin§4emphasises
thegenerictoolsofIsabelle/IsarandthepowerfulhelperfunctionsofIsabelle/MLtomotivatereadersto
use existing proof assistants as a basis for the development of for the development of learning systems
ratherthanstartingfromscratchagainandagain.
Another motivation for this description is to inform future collaborators of the Isac project about
implementationdetailsanditsbackground.
Conclusions Over the decades, Isac’s design of the specify-phase and the solve-phase was discussed
long and wide and has proven useful in field tests; the time is ripe to move into development for
widespread use. It seems helpful that the old Java-based front end has been abandoned and that the
originally very ambitious specifications [20] are significantly reduced: ISAC will change from a multi-
user system to a single-user system in line with the (current) architecture of Isabelle/PIDE; and in the
next step of development the scope of application will be limited to inclusive learning situations (visu-
allyimpairedstudentsintegrated)insecondaryeducationalinstitutionstotakeadvantageofthestructural
relationshipbetweenIsabelle’stermsandtheBrailledisplay.
ThesuddenpenetrationofAIwillposethefollowingnewresearchtasks. Startingfromadifferenti-
ationofproblemsolvingthrough
1. intuitivelyandassociativelythinkinghumans(whobearresponsibilityfortheiractions,etc)
2. AIwithdeeplearning
3. formalmathematics
the interaction of (3) and (2) will be analysed. Design and implementation of a user guide and a user
model(fromtheinteractionof(3)and(1))isalreadyplannedinthenextdevelopmentstep.
References
[1] Ralph-JohanBack&JoakimvonWright(1998): RefinementCalculus: ASystematicIntroduction. Springer-
Verlag. GraduateTextsinComputerScience,doi:10.1007/978-1-4612-1674-2.W.Neuper 137
[2] ChristophBenzmüller&DavidFuenmayor(2021):Value-OrientedLegalArgumentationinIsabelle/HOL.In
LironCohen&CezaryKaliszyk,editors:12thInternationalConferenceonInteractiveTheoremProving(ITP
2021),LeibnizInternationalProceedingsinInformatics(LIPIcs)193,SchlossDagstuhl–Leibniz-Zentrum
fürInformatik,Dagstuhl,Germany,pp.7:1–7:20,doi:10.4230/LIPIcs.ITP.2021.7.
[3] Bruno Buchberger (2023): Is ChatGPT Smarter Than Master’s Applicants? RISC Report Series 23-04,
ResearchInstituteforSymbolicComputation(RISC),JohannesKeplerUniversity,Linz,Austria. Available
athttps://www3.risc.jku.at/publications/download/risc_6684/23-04.pdf.
[4] Jasmin C.Blanchette: Hammering Away. A User’s Guide to Sledgehammer for Isabelle/HOL. contained in
theIsabelledistribution. Availableathttp://isabelle.in.tum.de/doc/sledgehammer.pdf.
[5] GabriellaDaróczy&WaltherNeuper(2013):Error-Patternswithin“Next-Step-Guidance”inTP-basedEdu-
cationalSystems. In:eJMT,theElectronicJournalofMathematics&Technology,7,pp.175–194. Available
athttps://php.radford.edu/~ejmt/ContentIndex.php#v7n2. SpecialIssue“TP-basedSystemsand
Education”.
[6] Adrian De Lon, Peter Koepke, Anton Lorenzen, Adrian Marti, Marcel Schütz & Makarius Wenzel (2021):
The Isabelle/Naproche natural language proof assistant (system description). In: 28th International
Conference on Automated Deduction (CADE 28), Lecture Notes in Computer Science, Springer-Verlag,
doi:10.1007/978-3-030-79876-5_36
[7] KarlJosefFuchs,SimonPlangg,MartinStein&GilbertGreefrath,editors(2020): ComputerAlgebraSys-
temeinderLehrer(innen)bildung(überarbeiteteNeuauflage). WTMVerlag,Münster.
[8] David Gries (1981): The science of programming. Texts and monographs in computer science, Springer-
Verlag,doi:10.1007/978-1-4612-5983-1.
[9] MatejaJamnik(2023): HowCanWeMakeTrustworthyAI? InMarcoGaboardi&FemkevanRaamsdonk,
editors: 8th International Conference on Formal Structures for Computation and Deduction (FSCD 2023),
LeibnizInternationalProceedingsinInformatics(LIPIcs)260,SchlossDagstuhl–Leibniz-ZentrumfürIn-
formatik,Dagstuhl,Germany,pp.2:1–2:1,doi:10.4230/LIPIcs.FSCD.2023.2.
[10] FranzKober(2012): LoggingofHigh-LevelStepsinaMechanizedMathAssistant. Master’sthesis, IICM,
GrazUniversityofTechnology. https://static.miraheze.org/isacwiki/e/e6/Fkober_bakk.pdf.
[11] KlausMiesenberger,WaltherNeuper,BernhardStöger&MakariusWenzel(2023): TowardsanAccessible
MathematicsWorkingEnvironmentBasedonIsabelle/VSCode. InPedroQuaresma,JoãoMarcos&Walther
Neuper,editors:Proceedings11thInternationalWorkshoponTheoremProvingComponentsforEducational
Software,Haifa,Israel,11August2022,ElectronicProceedingsinTheoreticalComputerScience375,Open
PublishingAssociation,pp.92–111,doi:10.4204/EPTCS.375.8.
[12] RobinMilner,MadsTofte,RobertHarper&DavidMacQueen(1997): TheDefinitionofStandardML(Re-
vised). TheMITPress,Cambridge,London,doi:10.7551/mitpress/2319.001.0001.
[13] Walther Neuper (2012): Automated Generation of User Guidance by Combining Computation and Deduc-
tion. In Pedro Quaresma & Ralph-Johan Back, editors: Electronic Proceedings in Theoretical Computer
Science,79,OpenPublishingAssociation,pp.82–101,doi:10.4204/EPTCS.79.5.
[14] Walther Neuper (2019): Technologies for “Complete, Transparent & Interactive Models of Math” in
Education. In Pedro Quaresma & Walther Neuper, editors: Proceedings 7th International Workshop
on Theorem proving components for Educational software, Oxford, United Kingdom, 18 july 2018,
Electronic Proceedings in Theoretical Computer Science 290, Open Publishing Association, pp. 76–95,
doi:10.4204/EPTCS.290.6.
[15] WaltherNeuper(2020):Lucas-InterpretationonIsabelle’sFunctions.InPedroQuaresma,WaltherNeuper&
JoãoMarcos,editors: Proceedings9thInternationalWorkshoponTheoremProvingComponentsforEduca-
tionalSoftware(ThEdu’20),Paris,France,29thJune2020,ElectronicProceedingsinTheoreticalComputer
Science,328,pp.79–95,doi:10.4204/EPTCS.328.5.
[16] Walther Neuper & Christian Dürnsteiner (2007): Angewandte Mathematik und Fachtheorie mithilfe adap-
tierter Basis-Software. Technical Report 683, IMST – Innovationen Machen Schulen Top!, University of138 FormalSpecificationforEngineers
Klagenfurt, Institute of Instructional and School Development (IUS), 9010 Klagenfurt, Sterneckstrasse 15.
Availableathttps://www.imst.ac.at/imst-wiki/images/f/f9/683_Kurzfassung_Neuper.pdf.
[17] WaltherNeuper,JohannesReitinger&AngelikaGründlinger(2008): BegreifenundMechanisierenbeimAl-
gebraEinstieg. TechnicalReport1063,IMST–InnovationenMachenSchulenTop!,UniversityofKlagen-
furt,InstituteofInstructionalandSchoolDevelopment(IUS),9010Klagenfurt,Sterneckstrasse15.Available
athttps://www.imst.ac.at/imst-wiki/images/9/9d/1063_Langfassung_Reitinger.pdf.
[18] WaltherNeuperetal.(2006):AngewandteMathematikundFachtheorie.TechnicalReport357,IMST–Inno-
vationenMachenSchulenTop!,UniversityofKlagenfurt,InstituteofInstructionalandSchoolDevelopment
(IUS), 9010 Klagenfurt, Sterneckstrasse 15. Available at http://imst.uni-klu.ac.at/imst-wiki/
index.php/Angewandte_Mathematik_und_Fachtheorie.
[19] Lawrence C. Paulson, Tobias Nipkow & Makarius Wenzel (2019): From LCF to Isabelle/HOL. Formal
AspectsofComputing31,pp.675–698, Springer,London,doi:10.1007/s00165-019-00492-1.
[20] ISACTeam(2002): ISAC–UserRequirementsDocument,SoftwareRequirementsDocument,Architectural
DesignDocument,SoftwareDesignDocument,UseCases,TestCases. TechnicalReport,InstituteforSoft-
waretechnology,UniversityofTechnology. Availableathttps://static.miraheze.org/isacwiki/0/
04/Isac-docu.pdf.
[21] Makarius Wenzel & Burkhart Wolff (2011): Isabelle/PIDE as Platform for Educational Tools. In Pedro
Quaresma&Ralph-JohanBack,editors: ProceedingsFirstWorkshoponCTPComponentsforEducational
Software,THedu’11,Wroclaw,Poland,31thJuly2011,EPTCS79,pp.143–153,doi:10.4204/EPTCS.79.9.
[22] MarkusWenzel(1999): Isar-aGenericInterpretativeApproachtoReadableFormalProofDocuments. In
G.Dowek,A.Hirschowitz,C.Paulin&L.Thery,editors: TheoremProvinginHigherOrderLogics,LNCS
1690,12thInternationalConferenceTPHOLs’99,Springer,doi:10.1007/3-540-48256-3_12.
[23] W.Neuper, B.Stöger & M.Wenzel (2022): Towards Accessible Formal Mathematics with ISAC and Is-
abelle/VSCode. IsabelleWorkshop2022https://sketis.net/isabelle/isabelle-workshop-2022.
Accessed: 202-10-13.