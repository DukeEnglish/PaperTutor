Adjustment Identification Distance:
A gadjid for Causal Structure Learning
Leonard Henckel1, Theo Würtzen2, and Sebastian Weichwald2,3
1School of Mathematics and Statistics, University College Dublin, Ireland
2Pioneer Centre for AI, University of Copenhagen, Denmark
3Department of Mathematical Sciences, University of Copenhagen, Denmark
February 14, 2024
Abstract
Evaluating graphs learned by causal discovery algorithms is difficult: The number of edges that differ
betweentwographsdoesnotreflecthowthegraphsdifferwithrespecttotheidentifyingformulastheysuggest
forcausaleffects. Weintroduceaframeworkfordevelopingcausaldistancesbetweengraphswhichincludesthe
structuralinterventiondistancefordirectedacyclicgraphsasaspecialcase. Weusethisframeworktodevelop
improvedadjustment-baseddistancesaswellasextensionstocompletedpartiallydirectedacyclicgraphsand
causal orders. We develop polynomial-time reachability algorithms to compute the distances efficiently. In
our package gadjid (open source at github.com/CausalDisco/gadjid), we provide implementations of our
distances; they are orders of magnitude faster than thestructural intervention distance and thereby provide
a success metric for causal discovery that scales to graph sizes that were previously prohibitive.
1 Introduction
Inferring the causal effect of a treatment on an outcome from observational data requires qualitative knowledge
of the underlying causalstructure,for instance informof acausalgraph[Pearl,2009]. We can, forexample, use
a causalgraphto decide whether a set of covariatesforms a valid adjustment set and enables correctestimation
of a causal effect via adjustment [Pearl, 1995, Perkovic et al., 2018].
Undercertainassumptions,wecanlearnthecausalgraphthatunderliesthecovariates;ataskknownascausal
discovery [e.g. Spirtes et al., 2000, Chickering, 2002, Heinze-Deml et al., 2018]. Causal discovery is challenging.
First,thecausalgraphisonlyidentifiablefromobservationaldataunderrestrictiveassumptions,suchasadditive
errorssatisfyingdistributionalorscalerestrictions[Shimizuetal.,2006,Park,2020]. Second,algorithmsbasedon
existingidentifiabilityresultsoftenrequirefurtherassumptionsorapproximationstobecomputationallyfeasible,
for example, testing only few of the combinatorically exploding number of required conditional independence
tests [Spirtes et al., 2000]. Third, causal discovery from finite data is statistically challenging and there are
pitfalls to evaluating causaldiscoveryalgorithmson simulateddata [Gentzel et al., 2019,Weichwaldet al., 2020,
Kaiser and Sipos, 2022, Reisach et al., 2021,2023].
The literature has focused on the first two problems. Yet, for causal discovery to become practically useful,
it is necessary to tackle the third problem and improve the evaluation criteria,benchmarks, and success metrics
that guide algorithm development [Mooij et al., 2016, Cheng et al., 2022, Rios et al., 2021]. A prerequisite for
research into more accurate causal discovery algorithms is that we quantify that accuracy, for which we need a
distance between a learned graph G and the true graph G . A common and very widely used choice in
guess true
the literature is the structural Hamming distance (SHD) or variants thereof which count the number of edges
that differ between graphs [Tsamardinos et al., 2006, de Jongh and Druzdzel, 2009, Constantinou, 2019]. The
SHD, however, does not reflect how similar graphs are when used to infer interventional distributions: A graph
G may have a largeHamming distance from G but still be a good estimate of G for performing causal
guess true true
inference (cf. Corollary 8 or [Peters and Bühlmann, 2015]). The number of edges that differ between graphs is
not a performance metric for causal discovery.
1
4202
beF
31
]LM.tats[
1v61680.2042:viXraThe literature on comparing causal graphs can broadly be divided into two approaches. The first approach
considers data-driven graph distances [Viinikka et al., 2018, Eigenmann et al., 2020, Peyrard and West, 2021,
Dhanakshirur et al., 2023]. These are challenging to use as performance metrics for algorithm development, as
evaluating these distances generallyrequires largesamples and is only computationally feasible for small graphs.
The second approach considers only the graph structure and its implications for causal inference to define a
graph distance; an example is the Structural Intervention Distance (SID) [Peters and Bühlmann, 2015]. We
focus on distances that consider only the graph structure. This approach has received less attention than the
firstapproachbutoffers advantages: First, itenablescomparisonsto graphsencoding expertknowledgewithout
having to specify all conditional distributions. Second, it is independent of the sample size, hyperparameter
tuning, and choice of density estimator.
TheSIDcountsinterventionaldensitiesf(Y |do(T =t))inG thatareincorrectlyinferredifweinsteaduse
true
G asthecausalgraphtocomputeinterventionaldensitiesviaparentadjustment. Fordirectedacyclicgraphs
guess
(DAGs), this amounts to counting the parent sets in G that are not valid adjustment sets in G . Using
guess true
this characterization, Peters and Bühlmann [2015] provide an algorithm with O(p4log(p)) time complexity in
the numberofnodesp.1 They proposeageneralizationofthe SIDto completedpartiallydirectedacyclicgraphs
(CPDAGs), which represent equivalence classes of DAGs, by iterating over the DAGs in the equivalence class
to compute a multi-set of distances. As one major use of causal graphs is inferring interventional densities, the
SID is a practically relevant distance. However, parent adjustment is only one of many approaches to compute
causal effects and is in fact statistically inefficient [Rotnitzky and Smucler, 2020, Henckel et al., 2022]. Further,
iterating over the DAGs in a Markov equivalence class to calculate the multi-set SID between CPDAGs has
exponential time complexity and the resulting non-scalar distance is difficult to interpret.
Contribution. We develop distances between causal graphs that reflect their dissimilarity when used to infer
causal effects. We propose a framework to construct an identifiability distance from a graphical identification
strategy, that is, an algorithmic approach to causal effect identification. We show that our framework includes
the SID for DAGs as a special case and use the framework to propose new distances with attractive properties.
We discuss for each distance a) whether the underlying identification strategy is good practice and used in
practice, and b) when it is zero. Within our framework and in contrast to the SID, our distances canonically
generalize to distances between any combination of DAGs and CPDAGs. We generalize one of the distances to
enable evaluation of learned node orders. For all distances, we develop algorithms with a worst-case complexity
ofO(p4),irrespectiveofwhetherthegraphsareDAGsorCPDAGs. Toourknowledge,this makesthemthe first
causal distances between CPDAGs with a polynomial runtime guarantee. For distances using local adjustment
strategies, which in the special case of DAGs also includes the SID, we show that this complexity reduces to
O(p2)forsparseandO(p3)fordensegraphs. Weprovideempiricalevidencefortheasymptotictimecomplexities
and fast runtimes of our algorithms. Finally, we discuss how future advances on sound and complete criteria for
causal effect identification could be integrated into our framework to develop distances for more general graph
types that allow for unobserved variables.
A gadjid for causal structure learning. Forourdistances,weprovideefficientRust-implementationswith
a Python interface. Our package gadjid (open source at github.com/CausalDisco/gadjid) enables researchers
to evaluate and benchmark causaldiscoveryalgorithms with causally meaningful and computationally tractable
performance metrics to guide and support the development of structure learning algorithms.
2 Preliminaries
We use graphs where nodes represent random variables and edges causal relationships. Here, we provide an
overview of the key terminology and refer to Appendix A for details.
We consider two types of graphs: directed acyclic graphs (DAGs) and completed partially directed acyclic
graphs (CPDAGs), see Figure 1. DAGs are graphs with directed edges (→) and without directed cycles. DAGs
can describe causal relationships without feedback loops [Pearl, 2009]. They also encode conditional indepen-
dences that can be read off the graph using the d-separation criterion [Pearl, 2009]. DAGs can be learned from
data only under strong assumptions. However,the class of DAGs encoding the same conditional independences,
known as its Markov equivalence class, can be learned under weaker assumptions. A CPDAG can uniquely
1Forcertainadjacencymatrices,theStrassenalgorithmformatrixmultiplicationmayenableareductiontoO(plog2(7)+1log(p)).
2V
4
V V V V
4 1 2 3
V V V V
1 2 3 4
V V V
1 2 3
Figure 1: A CPDAG (left) and the two DAGs in the corresponding Markov equivalence class (right).
representthisequivalenceclassiftherearenohiddenvariables[Meek,1995,Chickering,2002]. CPDAGscontain
directed (→) and undirected ( ) edges and satisfy further structural properties [Meek, 1995].
Causal DAGs and CPDAGs. We consider external interventions do(T=t) (short do(t)) for T ⊆ V that
set T to some value t for the entire population [Pearl, 1995]. A probability density function f over random
variables V=(V ,...,V ) is compatible with a causal DAG G =(V,E) if all densities f(v|do(t)) obey
1 p
f(v |Pa(V,G)) if T=t,
f(v|do(t))=
V∈V\T
(Q0 otherwise.
This equation is known as truncated factorization formula [Pearl, 2009], manipulated density formula [Spirtes
et al., 2000], or g-formula [Robins, 1986]. A density f is compatible with a CPDAG G if it is compatible with a
causal DAG in the Markov equivalence class represented by G.
Identifying formula. Causal graphs are used to estimate the causal effect of a treatment T ⊆ V on an
outcome Y ⊆ V from observational data, that is, to estimate (functionals of) the interventional distribution
f(y|do(t)). To do so,we requireanidentifying formulafor this interventionaldistribution, thatis, anequation
in the observationaldensity that solves for f(y|do(t)) for any f compatible with the causal graph. We refer to
inferring such an identifying formula from a causal graph as inferring the causal effect. An effect is identifiable
in a causal graph G if there is at least one identifying formula.
Valid adjustment. Let T,Y, and Z be pairwise disjoint node sets in a causal DAG or CPDAG G. Z is a
validadjustmentsetiff(y|do(t))= f(y|t,z)f(z)dzforanydensityf compatiblewithG. Graphicalcriteria
fully characterize valid adjustment sets in DAGs, CPDAGs, and other graph types [Perkovic et al., 2018].
R
Causal ordering. Let G be a DAG with node set V. A strict partialorder ≺ on V is called a causalorder of
G if for all nodes A,B ∈ V with A → B it holds that A ≺ B. In general, there are multiple causal orders. For
two DAGs G and H with node set V, we say that G respects the causal orders of H if every causal order of G
is a causal order of H. We define pre (B) = {A ∈ V | A ≺ B}, post (A) = {B ∈ V | A ≺ B}, and G as the
≺ ≺ ≺
transitively closed DAG with A→B if and only if A≺B.
3 Causal Identification Distance
We introduce a framework for developing identifiability distances between causal graphs. This framework lays
out how to extend distances to different graph types and align them with how causal graphs are used to answer
causal queries.
3.1 Framework
In our framework, a distance is defined by a) a sound and complete identification strategy and b) a verifier.
We use the identification strategy to derive identification formulas based on G and the verifier to evaluate
guess
whether the identification formulas obtained on G are correct in G . For simplicity, we only consider
guess true
3single-node interventions while the framework generalizesprovided a sound and complete identification strategy
and verifier (cf. also Section 4.3).
Definition 1 (Identification Strategy). An identification strategy is an algorithm that for a tuple (G,T,Y) of a
causal graph G and two distinct nodes T and Y in G, returns the tuple (T,Y) and either an identifying formula
I for f(y |do(t)) or none. An identification strategy I is sound and complete if a) I(G,T,Y)6=none if and only
if f(y |do(t)) is identifiable in G and b) all returned identifying formulas are correct for any f compatible with
G.
Example 2 (Parent Adjustment Strategy). For a DAG G and two distinct nodes T and Y, P = Pa(T,G) is
T
a valid adjustment set whenever Y ∈/ P . If, on the other hand, Y ∈ P , then, by the acyclicity of G, Y is a
T T
non-descendant of T and so there is no causal effect from T on Y. We can combine these two results to obtain
the sound and complete parent adjustment strategy
f(y |t,p )f(p )dp if Y ∈/ P
T T T T
I (G,T,Y)=
P
(f R(y) else.
In a DAG, all causal effects are identifiable and therefore I never returns none.
P
Definition 3 (Verifier). A verifier is an algorithm that given a graph G, distinct nodes T and Y in G, and an
identifying formulaI forf(y |do(t)), verifieswhether I iscorrectfor alldensities compatiblewithG andreturns
either correct or incorrect. For an input of none it verifies that the effect is not identifiable in G, that is, that no
identifying formula exists.
Identificationhasbeenwidelystudied;forexample,varioussufficientconditionsforthevalidityofadjustment
sets areknown[Pearl,1993,Maathuisand Colombo,2015]. Verification,however,has receivedlimited attention
andnoalgorithmisavailabletoverifyanarbitraryidentifyingformulaforDAGsorCPDAGs. Yet,forsometypes
of identifying formulas, necessary and sufficient graphical criteria exist and these can be used for verification.
In particular, for identifying formulas that use adjustment, we can use the necessary and sufficient adjustment
criterion for verification [Shpitser et al., 2010, Perkovic et al., 2018]. A necessary and sufficient criterion also
exists for instrumentalvariablesbut only for linear models [Henckeletal., 2023]. We focus onadjustment-based
identification strategies but our framework is amenable to other strategies provided a corresponding verifier
exists.
Example4(Adjustment-VerifierforDAGs). TheidentificationstrategyI reliesontwoidentificationprinciples:
P
a)validadjustmentandb)non-descent. TheverifierV inAlgorithm1issimple,sound,andcompleteanduses
adj
theadjustmentcriterionandanon-descentcheckfortheverificationofadjustment-basedidentificationstrategies.
In DAGs all effects areidentifiable and so the verifierrejects any none-identificationformula as incorrect, that is,
the if-branch in line 5 is not reached and only included for completeness.
Definition 5 (I-Specific Identification Distance). Given a sound and complete identification strategy I, we
define the I-specific identification distance between two graphsG and G with commonnode set V as the
true guess
number of identification formulas inferred by I on G that are incorrect relative to G , that is,
guess true
dI(G true,G guess,S)= 1 {incorrect} V(G true,I(G guess,T,Y))
(T X,Y)∈S
(cid:0) (cid:1)
where S⊆S={(T,Y)∈V×V|T 6=Y}. Unless otherwise noted, we use all p(p−1) pairs of distinct nodes in
V and write dI(G ,G )=dI(G ,G ,S).2
true guess true guess
Example 6 (SID is the I -Specific Distance for DAGs). Let G and G be DAGs with common node
P true guess
set V. Then dIP(G ,G ) coincides with SID(G ,G ) as defined by Peters and Bühlmann [2015]. For
true guess true guess
CPDAGs, however, the SID is defined as the multi-set obtained by calculating the SID for each DAG in the
Markovequivalenceclassandisnotadistanceinourframework;inSection5wepresentthecanonicalextension
of the I -specific distance to CPDAGs that outputs a scalar and retains interpretability.
P
2TheflexibilitytochooseothersetsS′⊂SallowsonetotailorthedistancedI(G true,G guess,S′)toconsideronlysomespecificnodes
of interest astreatment oreffect nodes or,given asuitableidentification strategy andverifier, toconsidermulti-nodeinterventions
whencomparinggraphs (seealsoSection4.3).
4Algorithm 1 Adjustment-Verifier V
adj
1: Input: Graph G, tuple (T,Y), identifying formula I
2: Output: Validity indicator V ∈{correct,incorrect}
3: V ←incorrect
4: if I =none and f(y |do(t)) not identifiable in G then
5: V ←correct
6: else if I =f(y) and Y ∈NonDe(T,G) then
7: V ←correct
8: else if I = f(y |t,z)f(z) dz and Z is a valid adjustment set relative to (T,Y) in G then
9: V ←correct
R
10: return V
3.2 General Properties
Any identification distance between a DAG and a supergraph of that same graph is zero. A corollary high-
lights that identification distances differ from the SHD: there exist DAGs for which identification distances are
maximally different from the SHD. Proofs are provided in Appendix B.
Proposition 7 (Distance to Super-DAG is Zero). Let I be a sound and complete identification strategy for
DAGs and V a corresponding verifier. For any DAG G , it holds that if G is a super-DAG of G , then
true guess true
dI(G ,G )=0.
true guess
As dI(G ,G ) = 0, identification distances are pre-metrics. Proposition 7 is a consequence of all causal
true true
effects in a DAG being identifiable; adding edges removes the information that certain effects are absent and
may reduce the number of correct identifying formulas, but never to zero. As a corollary, graphs may be close
in identification distance but far in SHD.
Corollary 8 (IdentificationDistancesDiffer fromthe SHD). Let dI be a strategy-specific identification distance.
Let G be a fully connected DAG with p nodes and G the empty DAG on the same node set. Then the SHD
guess true
d is maximal and maximally different from dI:
H
d (G ,G )−dI(G ,G )=p(p−1)/2−0.
H true guess true guess
4 DAG Distances
Weproposethreeadjustment-baseddistancesforDAGsandextendthemtoCPDAGsinSection5. Weproposea
parent adjustment distance whichbetweenDAGscorrespondstotheSIDbut,incontrast,generalizescanonically
toCPDAGs. Wedevelopanancestor adjustment distance thatassignslowdistancetographswithsimilarcausal
orders and an Oset adjustment distance that uses a statistically efficient identification strategy.
4.1 Parent Adjustment Distance
WecalldIP theparentadjustmentdistance(Parent-AID).Parent-AIDisanidentificationdistance(cf.Example6)
but yields unintuitive results between graphswith the same causalorders(cf. Lemma 10)and uses aninefficient
adjustmentstrategy(cf.Section4.3);weincludeitforcompleteness,asitincludestheSIDforDAGsasaspecial
case,but, incontrast,canonicallyextends to CPDAGs within ourframework(cf. Section5). We developrefined
adjustment-based distances in the next two subsections.
Parent adjustment is commonly used in practice [Gascon et al., 2015, Sunyer et al., 2015] and so may be
a reasonable choice to define a distance between causal graphs that is relevant from a practitioner-oriented
perspective. Parent adjustment is local, that is, for any pair (T,Y) the adjustment set only depends on T but
not Y, which we use to improve the time complexity of calculating the distance (cf. Section 6). For DAGs,
dIP(G ,G )=0 if and only if G is a supergraph of G [Peters and Bühlmann, 2015].
true guess guess true
5V 1 V 2 V 3 ... V p
Figure 2: Fully connected and chain DAG in Lemma 10.
4.2 Ancestor Adjustment Distance
Manycausaldiscoveryalgorithmslearnanorderingofthe nodes inaseparatefirststep[ShojaieandMichailidis,
2010, Bühlmann et al., 2014, Chen et al., 2019, Park, 2020] and pairwise causal effects can be learned from the
correct causal order alone [Bühlmann et al., 2014,Section 2.6]. We formalize this known result as follows.
Lemma 9 (Ancestors are Valid Adjustment Sets). Let T and Y be two distinct nodes in a DAG G. Then any
set Z such that Pa(T,G)⊆Z⊆NonDe(T,G) and Y ∈/ Z is a valid adjustment set for (T,Y) in G. As a corollary,
given an order ≺, pre (T) is a valid adjustment set for all Y ∈/ pre (T) in all DAGs for which ≺ is a causal
≺ ≺
order.
Nonetheless, the Parent-AID between two DAGs with the same causal orders can be large.
Lemma 10 (Parent-AID Misrepresents Causal Order). Let Gp be the fully connected DAG over p causally-
true
ordered nodes {V ,...,V } and Gp the chain V → V ··· → V (cf. Figure 2). Then, despite G and G
1 p guess 1 2 p true guess
respecting each others causal orders, dIP(Gp ,Gp )=p2−4p+4 which is close to its maximal value p(p−1)
true guess
in the sense that
lim dIP(Gp ,Gp )/p(p−1)=1.
true guess
p→∞
Considering DAGs as distant that respect each others causal orders may be misleading and illustrates a
limitation of a distance based on parent adjustment. We therefore propose to use another adjustment strategy
and distance.
Definition 11 (Ancestor Adjustment Strategy and Distance). Given two distinct nodes T and Y in a DAG G,
let A =An(T,G) and D =De(T,G). We define the ancestor adjustment strategy as
T T
f(y |t,a )f(a )da if Y ∈D ,
T T T T
I (G,T,Y)=
A
(f R(y) else,
which is a sound and complete identification strategy per Proposition 12. We call the corresponding distance
dIA the ancestor adjustment distance (Ancestor-AID).
Proposition 12 (Ancestor-AID Reflects Causal Order). The ancestor adjustment strategy I is sound and
A
complete for DAGs and so the corresponding ancestor adjustment distance dIA is the I -specific identification
A
distance. Further, for any two DAGs G and G with the same node set, dIA(G ,G )=0 if and only
true guess true guess
if G respects the causal orders of G .
guess true
The ancestor adjustment strategy is local in the sense that the adjustment set proposed for a pair (T,Y)
only depends on T. Adjusting for the ancestors has some advocates [Rubin, 2008]and is at least as statistically
efficient as parent adjustment [Henckel et al., 2022]; it is therefore a natural choice to define a distance between
causal graphs that is relevant from a practitioner-orientedperspective.
To evaluate the causal order of a learned graph, the Ancestor-AID is preferable to the Parent-AID.
4.3 Oset Adjustment Distance
In practice, identifying formulas are a tool to estimate a causal effect of interest. Different identifying formulas
correspond to different estimators for this effect. For example, in linear models we can estimate the average
treatment effect with an ordinary least squares regression of Y on T and Z; this estimator is consistent for any
valid adjustment set Z. Other properties of the estimator, such as its asymptotic variance, however, depend on
the adjustment set.
We can use the causal graph to decide which valid adjustment sets result in statistically efficient estimators;
importantly,for alargeclassofestimators,the validadjustmentsetPa(T,G)is closeto the leastefficientamong
6allvalidadjustmentsets[Rotnitzky andSmucler,2020,Witte etal.,2020,Henckeletal.,2022]. The parentsare
therefore an inefficient adjustment set and parent adjustment is perhaps not good practice. As an alternative
Henckel et al. [2022] have proposed the optimal adjustment set.
Definition 13 (Optimal Adjustment Set (Oset)). Let T and Y be two distinct nodes in a DAG G. Then the
optimal adjustment set (Oset) O(T,Y,G) is defined as
O(T,Y,G)=Pa(Cn(T,Y,G),G)\Forb(T,Y,G)
where Cn(T,Y,G) are the causal and Forb(T,Y,G) the forbidden nodes as defined in Appendix A.
IfY ∈De(T,G), thenO(T,Y,G)isavalidadjustmentsetwhenevera validadjustmentsetexists. Foralarge
classofestimators,the Osetis the moststatisticallyefficientamongallvalidadjustmentsets. We use this result
to propose another adjustment-based identification distance.
Definition 14 (Oset Adjustment Strategy and Distance). Given two distinct nodes T and Y in a DAG G, let
O =O(T,Y,G) and D =De(T,G). We define the Oset adjustment strategy as
T T
f(y |t,o )f(o )do if Y ∈D ,
T T T T
I (G,T,Y)=
O
(Rf(y) else,
which is a sound and complete identification strategy per Proposition 15. We call the corresponding distance
dIO the Oset adjustment distance (Oset-AID).
Proposition15(Oset-AIDistheI -SpecificDistance). TheOsetadjustmentstrategyI issoundandcomplete
O O
for DAGs and so the corresponding Oset adjustment distance dIO is the I -specific identification distance.
O
Oset adjustment has seen some early adoption by practitioners [Steiger et al., 2021]. Given its efficiency
guarantee, we consider it a natural choice to define a distance between causal graphs that is relevant from a
practitioner-oriented perspective. The Oset adjustment strategy is non-local as the Oset depends on both T
and Y. As a result, the Oset adjustment distance is computationally expensive (cf. Section 6). Further, we do
not have a graphical characterizationof all cases where the Oset adjustment distance is zero (cf. Example 18 in
Appendix C).
Joint interventions. Another advantage of the Oset adjustment strategy over the parent or ancestor adjust-
ment strategies is that the Oset—in contrast to the parents or ancestors—is a valid adjustment set whenever a
valid adjustment set exists, even if we consider joint interventions. As such, the Oset adjustment strategy en-
ables generalizations of the Oset adjustment distance to settings where S may contain multi-node interventions.
However,adjustment is not soundandcomplete for effects of jointinterventionsandthere mayexistidentifiable
effects that are not identifiable via adjustment. Therefore, this generalizationis strictly speaking not a strategy-
specific identification distance. Identifiable joint intervention effects that cannot be identified via adjustment
are characterized in Corollary 27 of Perkovic et al. [2018] and can be correctly identified by other strategies
[Nandy et al., 2017, Huang and Valtorta, 2006]. However, there is no verifier for these alternative strategies.
More research into verification is required to develop a proper strategy-specific distance to also consider joint
interventions.
5 CPDAG Distances
In generaland without strong assumptions, the true causalDAG cannot be identified or learned, even from infi-
nite data [e.g. Peters et al., 2014]. Instead, many causal discovery algorithms target the corresponding Markov
equivalence class and aim to learn its CPDAG [e.g. Chickering, 2002]. To evaluate common causal discovery
algorithms, we thus also need easy to compute and interpret distances between CPDAGs. Our strategy-specific
distance framework providesa recipe on how to developsuch distances: a) devise a sound and complete identifi-
cationstrategyandb)deviseacorrespondingverifier. Wefollowthisrecipetoproposenewandcomputationally
attractive distances for CPADGs based on the parent, ancestor, and Oset adjustment strategies. The distances
operatedirectlyontheCPDAGs,assessthecompatibilityofidentificationformulasbetweenthetwographs,and
returnascalardistance;this improvesuponpreviousapproachesofiteratingoveranexponentiallylargenumber
of Markov equivalent DAGs to calculate a multi-set of distances that is difficult to interpret. We also discuss
potential distances across graph types and their pitfalls.
75.1 CPDAG to CPDAG Distances
In contrast to DAGs, not all causal effects are identifiable given a CPDAG [Meek, 1995]. For example, we
cannot identify the effect of A on B given the CPDAG A B. An identification distance for CPDAGs must
therefore handle identification strategies that output none in case of non-identifiability. With the aim to extend
the SIDbetweenDAGsto CPDAGs, PetersandBühlmann [2015]pursuedtwoapproaches. The firstapproach—
consideringthe DAGsinthe MarkovequivalenceclassofaCPDAGto computeamulti-setofparentadjustment
distances—yieldsa difficult tointerpretmulti-setofvaluesandingeneraliscomputationallyinfeasible beyonda
couplenodes. Thesecondapproach—simplyignoringtuples wherethe effectis notidentifiable—failstoquantify
important differences in identification between two graphs; for example, the distance between the true CPDAG
A → B ← C and the guess CPDAG A B C would be 0 although no DAG exists that is in both Markov
equivalence classes. Our framework proposes a canonical solution: treat non-identifiability as a claim that we
can verify in G just like we verify identifying formulas returned by an identification strategy. In CPDAGs,
true
non-identifiability is characterized by a graphical condition [Perkovic et al., 2018, Perkovic, 2020], which for
single-node interventions is as follows.
Proposition 16 (Amenability). Consider distinct nodes T and Y in a CPDAG G. The interventional density
f(y | do(t)) is identifiable if and only if there exists no possibly directed path from T to Y that starts with an
undirected edge. If this holds, we say that (G,T,Y) is amenable.
Equipped with graphical conditions for non-identifiability and validity of adjustment sets in CPDAGs, we
can apply the adjustment verifier in Algorithm 1 to CPDAGs. Within our framework, any sound and complete
adjustment-styleidentificationstrategytogetherwiththisverifierdefinesastrategy-specificdistanceforCPDAGs.
To extend the three adjustment distances to CPDAGs, we need to extend the identification strategy by adding
an amenability check such that none is returned for (G,T,Y) that are not amenable and else the return values
of the identification strategies I , I , and I are the same as for DAGs.
P A O
TheparentadjustmentstrategyissoundandcompleteforCPDAGs[MaathuisandColombo,2015,Corollary
4.2] so are the Oset [Henckel et al., 2022, Theorem 3] and ancestor adjustment strategies (Proposition 20,
Appendix B). Thus, we generalize the Parent-AID, the Ancestor-AID, and the Oset-AID to distances between
CPDAGs.
5.2 DAG, CPDAG, and Order Distances
DAG to CPDAG distance. Given a suitable identification strategy and verifier, we can define a strategy-
specific distance between graphs of different type. For example, since the presented adjustment strategies and
verifier apply to both DAGs and CPDAGs, our distances accept any combination of DAG and CPDAG as G
true
and G . Yet, such a distance may be unintuitive: The distance between a DAG G and the CPDAG G
guess true guess
that encodes the Markov equivalence class of G is generally non-zero as some effects are non-identifiable in
true
theCPDAG;thedistancetothiscorrectCPDAGmayinfactbefurtherthantoanotherCPDAGthatencodesa
MarkovequivalenceclassthatdoesnotcontainG (cf.Example19,Appendix C).Across-graph-typedistance
true
may still be useful when comparing an algorithm that can learn a DAG, such as LiNGAM [Shimizu et al.,
2006], to an algorithm that cannot, such as GES [Chickering, 2002]. Our implementation therefore accepts
DAG-to-CPDAG and CPDAG-to-DAG comparisons.
Transformations to compare alike. An alternative is to transform one graph type to the other and then
apply a distance between DAGs or between CPDAGs. To obtain a proxy for the distance between a DAG G
true
and a CPDAG G , for example, one could pick a DAG corresponding to G and compare that to G ;
guess guess true
commonapproachesarea) to sample aDAG in the Markovequivalence classof G orb) to orientundirected
guess
edges in G for whicha correspondingedge inDAG G exists correctlyandthe remaining undirectededges
guess true
randomlywhileensuringacyclicity. Bothapproachesaread-hoc,non-deterministic,andignorecausalinformation
in the CPDAG G , such as claims about which effects are not identifiable. With our new CPDAG distance
guess
weenable aprincipledalternative: transformthe DAGG toits correspondingCPDAG andthencomparethe
true
CPDAG correspondingto the true DAGto the learnedCPDAG. This approachis natural,when the testdata is
simulated according to a DAG G and we compare the performance of two CPDAG learning algorithms, such
true
as GES and PCALG [Chickering, 2002, Spirtes et al., 2000].
8O(p) O(p2) O(p3) O(p4) O(p5)
Ancestor-AID, sparse Oset-AID, sparse Ancestor-AID, dense Oset-AID, dense
104
10−1
32 8192 16384 32 256 512 768 8 512 1024 8 128 320
#nodes p #nodes p #nodes p #nodes p
Figure 3: Empirical results on the algorithmic time complexity of calculating Ancestor-AID dIA and Oset-AID
dIO betweenrandomsparseanddensegraphs. Weprojecttheruntimeunderthedifferenttimecomplexitiesbased
on the smallest graphs in each panel and visualize the projected runtime as a fraction of the observedempirical
runtime; if the relative projected runtime increases/decreases with increasing number of nodes, the considered
time complexity suggests a faster/slower increase of runtime than empirically observed. The empirical analysis
suggests that our implementation of the Ancestor-AID achieves the time complexity of O(p2) for sparse and
O(p3) for dense graphs, and that the implementation of the Oset-AID achieves the time complexity of O(p3)
for sparse and O(p4) for dense graphs. See Appendix E for details.
DAG to order distance. Given a strict partial order ≺ on nodes V we can define the identification strategy
f(y |t,b )f(b )db if Y ∈A ,
T T T T
I (≺,T,Y)=
ord
(Rf(y) else,
where B = pre (T) and A = post (T). By Lemma 9 this strategy is sound and complete and we can
T ≺ T ≺
verify the returned identification formulas in a DAG G using V . As such we obtain a strategy-specific
true adj
distancedIord(G true,≺ guess)=dIA(G true,G ≺guess)betweenDAGsandstrictpartialorders. Thisdistanceoffersan
alternative to previous approaches, such as rank correlations or count-based order distances that lower bound
the SHD [Rolland et al., 2022].
6 Implementation
We sketch our implementation of the distances for CPDAG inputs with p nodes and m edges; see Appendix D
for details. First, consider a single tuple (T,Y). For the identification strategy, we check whether (G ,T,Y)
guess
is amenable and if so compute a) Pa(T,G ) for the Parent-AID, b) De(T,G ) and An(T,G ) for the
guess guess guess
Ancestor-AID, or c) De(T,G ) and O(T,Y,G )3 for the Oset-AID. For the verifier, we check whether a)
guess guess
(G ,T,Y)isamenable,b)Y ∈NonDe(T,G ),orc)the proposedadjustmentsetisavalidadjustmentsetfor
true true
(T,Y) in G . Algorithms exist to perform each of these steps in O(p+m) time [van der Zander et al., 2014],
true
so we can compute the distances in O(p2(p+m)) time by iterating over all tuples.
We improve this complexity for the Parent- and Ancestor-AID by sharing computations between tuples
instead of evaluating identification strategy and verifier for each of the p(p−1) tuples separately. For this we
use reachability algorithms,which are inspired by the Bayes-Ballalgorithm[Geiger et al., 1989,Shachter, 1998]:
Theystartfromanodeset,walkalongedgesperfixedrules,andreturnthesetofallreachednodes[cf.Wienöbst
et al., 2024, Appendix C]. Reachability algorithms find all nodes with a certain property that depends on the
rules used. For example, given T and the rule to continue only along → edges, the search algorithm finds all
nodes in De(T,G) in O(p+m) time. There are reachability algorithms to compute De(T,G), An(T,G), and
similar sets. We developnew walk-status-awarereachabilityalgorithmsthat, givena graphG, treatmentT, and
3InLemma21,AppendixC,weproveacharacterization oftheOsetthat, givenamenability,simplifiesitscomputation.
9
emitnur
detcejorp
evitalercandidate adjustment set Z, return a) all nodes such that (G,T,Y) is amenable, or b) all nodes Y such that Z
is a valid adjustment set for (T,Y) in G (Algorithms 2 and 3).
These reachabilityalgorithmsenable ourcomputationally efficientimplementation. Whenusing localadjust-
ment strategies, we can fix a T and compute both the identification strategy and verifier for all Y via at most
six reachability algorithms. Selecting each node as T once, we can calculate the Parent- and Ancestor-AID in
O(p(p+m)) time; this amountsto O(p2), the optimum, forsparsegraphswith m∈O(p) andto O(p3)for dense
graphs. The asymptotic runtime complexityof the Oset-AID remainsO(p2(p+m)) since O(T,Y,G)depends on
both T and Y.
The original SID implementation has O(p4log(p)) runtime for DAGs and exponential runtime for CPDAGs
[Peters andBühlmann,2015]. Our implementationofthe relatedParent-AIDbetweeneither DAGs orCPDAGs
has runtime O(p3) for dense and O(p2) for sparse graphs. To our knowledge, our distances are the first causal
distances between CPDAGs with a polynomial runtime guarantee.
7 Empirical Runtime Analysis
We calculate distances with our gadjid packageversion0.0.1,implemented in Rust and using a graphmemory
layout purposefully designed for fast memory access in reachability algorithms. We use the CRAN SID package
v1.1 and run all experiments on a laptop with 8 GB RAM and 4-core i5-8365Uprocessor. We draw DAGs with
pnodes,uniformlyrandomtotalorderofnodes,andedgescompatiblewiththis orderindependently drawnwith
probability20p/(p−1)forsparsegraphswith10pedgesinexpectationand0.3fordensegraphswith0.3p(p−1)/2
edges in expectation.
To empirically validate the theoretical asymptotic runtime complexities, we evaluate the Ancestor-AID and
Oset-AID on random DAGs. For each graph size, we record the runtime averaged over 5 repetitions. Based on
the runtimes for the smallest graphs,we projectwhat runtimes we wouldexpect for largergraphs under various
time complexities. Figure 3 shows the results and Appendix E provides details.
Next, we draw 11 pairs of random DAGs, calculate a distance, and if the median runtime is less than 60
seconds, we increase the number of nodes by one and repeat; we repeat until the median runtime exceeds 60
seconds and obtain:
Maximum graph size feasible within 1 minute
Method sparse dense
Parent-AID 13005 960
Ancestor-AID 8200 932
Oset-AID 546 250
SID 256 239
Finally, we consider the graph sizes for which the average runtime of the SID first exceeded one minute, and
the extremely sparse graphs from Peters and Bühlmann [2015]; for 11 random pairs of graphs of that size and
sparsity, we obtain the following average runtimes:
Average runtime
x-sparse4 sparse dense
Method
p=1000 p=256 p=239
Parent-AID 6.3 ms 22.8 ms 189 ms
Ancestor-AID 2.7 ms 38.7 ms 226 ms
Oset-AID 3.2 ms 4.69 s 47.3 s
SID ~1-2 h ~60 s ~60 s
8 Discussion
Our framework gives a recipe for developing distances for other graph types, such as maximal ancestral graphs
that allow for hidden variables: Find a sound and complete identification strategy and a corresponding verifier.
4Wedenotethesparsegraphswith0.75pexpectededgesconsideredinPetersandBühlmann[2015]asextremelysparse(x-sparse);
forx-sparse1000-noderandomgraphs,PetersandBühlmann[2015]reportedaruntimeofalmost7000s,whichonourourhardware
took~1h(running1insteadof11repetitions).
10While the adjustment style identification strategies we use for DAGs and CPDAGs are not sound and complete
forsettingswithhiddenvariables,soundandcompletealternativesexist[HuangandValtorta,2006,Shpitserand
Pearl,2006]. Yet,therearenoverifiersforthesealternatives. Further,advancesoncausaleffectidentificationand
inparticularverificationarethereforeneededbeforewecandevelopdistancesforothergraphtypes. Nonetheless,
thestrategy-specificdistanceframeworkprovidesahandbookonhowtodevelopsuchadistanceasthenecessary
methodology for causal effect identification and verification becomes available.
References
Josh Alman and Virginia Vassilevska Williams. A refined laser method and faster matrix multiplication.
arXiv:2010.05846, 2020.
Peter Bühlmann, Jonas Peters, and Jan Ernest. CAM: Causal additive models, high-dimensional order search
and penalized regression. The Annals of Statistics, 42(6):2526–2556,2014.
Wenyu Chen, Mathias Drton, and Y Samuel Wang. On causal discovery with an equal-variance assumption.
Biometrika, 106(4):973–980,2019.
Lu Cheng, Ruocheng Guo, Raha Moraffah, Paras Sheth, K Selçuk Candan, and Huan Liu. Evaluation methods
andmeasuresforcausallearningalgorithms. IEEE Transactions on Artificial Intelligence, 3(6):924–943,2022.
David Maxwell Chickering. Learning equivalence classes of Bayesian-network structures. Journal of Machine
Learning Research, 2:445–498,2002.
Anthony C Constantinou. Evaluating structure learning algorithms with a balanced scoring function.
arXiv:1905.12666, 2019.
Martijn de Jongh and Marek J Druzdzel. A comparison of structural distance measures for causal Bayesian
networkmodels. Recentadvances inintelligentinformation systems, challengingproblems ofscience, computer
science series, pages 443–456,2009.
MihirDhanakshirur,FelixLaumann,JunhyungPark,andMauricioBarahona. Acontinuousstructuralinterven-
tion distance to compare causal graphs. arXiv:2307.16452, 2023.
Marco Eigenmann, Sach Mukherjee, and Marloes H. Maathuis. Evaluation of causal structure learning algo-
rithms via risk estimation. In Proceedings of the Thirty-Sixth Annual Conference on Uncertainty in Artificial
Intelligence (UAI), pages 151–160,2020.
Mireia Gascon, Maribel Casas, Eva Morales, Damaskini Valvi, Ana Ballesteros-Gómez, Noelia Luque, Soledad
Rubio, Núria Monfort, Rosa Ventura, David Martínez, Jordi Sunyer, and Martin Vrijheid. Prenatal exposure
to bisphenol A and phthalates and childhood respiratory tract infections and allergy. Journal of Allergy and
Clinical Immunology, 135(2):370–378,2015.
Dan Geiger, Thomas Verma, and Judea Pearl. d-separation: From theorems to algorithms. In Max Henrion,
RossD.Shachter,LaveenN.Kanal,andJohnF.Lemmer,editors,Proceedings of the Fifth AnnualConference
on Uncertainty in Artificial Intelligence (UAI), pages 139–148,1989.
Amanda Gentzel, Dan Garant, and David Jensen. The case for evaluating causal models using interventional
measures and empirical data. In Proceedings of the Thirty-Second Annual Conference on Neural Information
Processing Systems (NeuRIPS), 2019.
Christina Heinze-Deml, Marloes H. Maathuis, and Nicolai Meinshausen. Causal structure learning. Annual
Review of Statistics and Its Application, 5:371–391,2018.
Leonard Henckel, Emilija Perković, and Marloes H. Maathuis. Graphical criteria for efficient total effect esti-
mation via adjustment in causal linear models. Journal of the Royal Statistical Society: Series B (Statistical
Methodology), 84(2):579–599,2022.
Leonard Henckel, Martin Buttenschoen, and Marloes H. Maathuis. Graphical tools for selecting conditional
instrumental sets. Biometrika, page asad066,11 2023.
11Yimin Huang andMarcoValtorta. Identifiability in causalBayesiannetworks: Asoundandcomplete algorithm.
In Proceedings of the Twenty-First National Conference on Artificial Intelligence (AAAI), pages 1149–1154,
2006.
Marcus Kaiser and Maksim Sipos. Unsuitability of NOTEARS for causal graph discovery when dealing with
dimensional quantities. Neural Processing Letters, 54(3):1587–1595,2022.
MarloesH.MaathuisandDiegoColombo. Ageneralizedback-doorcriterion. Annals of Statistics,43:1060–1088,
2015.
Christopher Meek. Causal inference and causal explanation with background knowledge. In Proceedings of the
Eleventh Annual Conference on Uncertainty in Artificial Intelligence (UAI), pages 403–410,1995.
Joris M. Mooij, Jonas Peters, Dominik Janzing, Jakob Zscheischler, and Bernhard Schölkopf. Distinguishing
cause from effect using observationaldata: Methods andbenchmarks. Journal of Machine Learning Research,
17(32):1–102,2016.
Preetam Nandy, Marloes H. Maathuis, and Thomas S Richardson. Estimating the effect of joint interventions
from observationaldata in sparse high-dimensional settings. Annals of Statistics, 45(2):647–674,2017.
GunwoongPark.Identifiabilityofadditivenoisemodelsusingconditionalvariances.JournalofMachineLearning
Research, 21(75):1–34,2020.
Judea Pearl. Comment: Graphical models, causality and intervention. Statistical Science, 8(3):266–269,1993.
Judea Pearl. Causal diagrams for empirical research. Biometrika, 82(4):669–688,1995.
Judea Pearl. Causality. Cambridge University Press, second edition, 2009.
EmilijaPerkovic.Identifyingcausaleffectsinmaximallyorientedpartiallydirectedacyclicgraphs.InProceedings
of the Thirty-Sixth Annual Conference on Uncertainty in Artificial Intelligence (UAI), pages 530–539,2020.
Emilija Perkovic,JohannesTextor,MarkusKalisch,andMarloesH.Maathuis. Completegraphicalcharacteriza-
tionandconstructionofadjustmentsetsinmarkovequivalenceclassesofancestralgraphs. Journalof Machine
Learning Research, 18(220):1–62,2018.
JonasPeters andPeter Bühlmann. Structuralinterventiondistance forevaluating causalgraphs. Neural compu-
tation, 27(3):771–799,2015.
Jonas Peters, Joris M. Mooij, Dominik Janzing, and Bernhard Schölkopf. Causal discovery with continuous
additive noise models. Journal of Machine Learning Research, 15:2009–2053,2014.
Maxime Peyrard and Robert West. A ladder of causal distances. In Proceedings of the Thirtieth International
Joint Conference on Artificial Intelligence (IJCAI), pages 2012–2018,2021.
Alexander G. Reisach, Christof Seiler, and Sebastian Weichwald. Beware of the simulated DAG! Causal dis-
covery benchmarks may be easy to game. In Proccedings of the Thirty-Fourth Annual Conference on Neural
Information Processing Systems (NeurIPS), pages 27772–27784,2021.
Alexander G. Reisach, Myriam Tami, Christof Seiler, Antoine Chambaz, and Sebastian Weichwald. A scale-
invariant sorting criterion to find a causal order in additive noise models. In Proceedings of the Thirty-Sixth
Annual Conference on Neural Information Processing Systems (NeurIPS), 2023.
Felix L. Rios, Giusi Moffa, and Jack Kuipers. Benchpress: A scalable and versatile workflow for benchmarking
structure learning algorithms. arXiv:2107.03863, 2021.
James M. Robins. A new approach to causal inference in mortality studies with a sustained exposure period-
application to control of the healthy worker survivor effect. Mathematical Modelling, 7:1393–1512,1986.
PaulRolland,VolkanCevher,MatthäusKleindessner,ChrisRussell,Dominik Janzing,BernhardSchölkopf,and
FrancescoLocatello.Scorematchingenablescausaldiscoveryofnonlinearadditivenoisemodels.InProceedings
of the Thirty-Ninth International Conference on Machine Learning (ICML), pages 18741–18753,2022.
12AndreaRotnitzkyandEzequielSmucler. Efficientadjustmentsetsforpopulationaveragecausaltreatmenteffect
estimation in graphical models. Journal of Machine Learning Research, 21:188–1,2020.
Donald B. Rubin. For objective causalinference, designtrumps analysis. The Annals of Applied Statistics, 2(3):
808 – 840, 2008.
Ross D. Shachter. Bayes-ball: The rational pastime (for determining irrelevance and requisite information in
belief networks and influence diagrams). In Proceedings of the Fourteenth Annual Conference on Uncertainty
in Artificial Intelligence (UAI), 1998.
Shohei Shimizu, Patrik O. Hoyer, Aapo Hyvärinen, and Antti Kerminen. A linear non-gaussian acyclic model
for causal discovery. Journal of Machine Learning Research, 7(10):2003–2030,2006.
Ali Shojaie and George Michailidis. Penalized likelihood methods for estimation of sparse high-dimensional
directed acyclic graphs. Biometrika, 97(3):519–538,07 2010.
Ilya Shpitser and Judea Pearl. Identification of joint interventional distributions in recursive semi-markovian
causal models. In Proceedings of the Twenty-First National Conference on Artificial Intelligence (AAAI),
pages 1219–1226,2006.
Ilya Shpitser, Tyler VanderWeele, and James Robins. On the validity of covariate adjustment for estimating
causal effects. In Proceedings of the Twenty-Sixth Annual Conference on Uncertainty in Artificial Intelligence
(UAI), pages 527–536,2010.
PeterSpirtes,ClarkGlymour,andRichardScheines. Causation, Prediction, and Search. MITPress,Cambridge,
MA, second edition, 2000.
Edgar Steiger,TobiasMussgnug,andLarsEric Kroll. CausalgraphanalysisofCOVID-19observationaldata in
german districts reveals effects of determining factors on reported case numbers. PLoS One, 16(5):e0237277,
2021.
JordiSunyer,MikelEsnaola,MarAlvarez-Pedrerol,JoanFornsGuzman,IoarRivas,MónicaLópez-Vicente,Elis-
abet Suades González, Maria Foraster, Raquel García-Esteban, Xavier Basagaña, Mar Viana, Marta Cirach,
Teresa Moreno, Andres Alastuey, Nuria Sebastian Galles, Mark Nieuwenhuijsen, and Xavier Querol. Associ-
ation between traffic-related air pollution in schools and cognitive development in primary school children: a
prospective cohort study. PLoS Medicine, 12(3), 2015.
Ioannis Tsamardinos, Laura E Brown, and Constantin F Aliferis. The max-min hill-climbing Bayesian network
structure learning algorithm. Machine Learning, 65(1):31–78,2006.
BenitovanderZander,MaciejLiskiewicz,andJohannesTextor. Constructingseparatorsandadjustmentsetsin
ancestral graphs. In Proceedings of the Thirtieth Annual Conference on Uncertainty in Artificial Intelligence
(UAI), pages 907–916,2014.
Jussi Viinikka, Ralf Eggeling, and Mikko Koivisto. Intersection-validation: A method for evaluating structure
learning without ground truth. In Proceedings of the Twenty-First International Conference on Artificial
Intelligence and Statistics (AISTAT-18), pages 1570–1578,2018.
Sebastian Weichwald, Martin E. Jakobsen, Phillip B. Mogensen, Lasse Petersen, Nikolaj Thams, and Gherardo
Varando. Causal structure learning from time series: Large regression coefficients may predict causal links
better in practice than small p-values. In Proceedings of the NeurIPS 2019 Competition and Demonstration
Track, pages 27–36,2020.
Marcel Wienöbst, Benito van der Zander, and Maciej Liśkiewicz. Linear-time algorithms for front-door adjust-
ment in causal graphs. arXiv:2211.16468, 2024.
Janine Witte, Leonard Henckel, Marloes H. Maathuis, and Vanessa Didelez. On efficient adjustment in causal
graphs. Journal of Machine Learning Research, 21(246):1–45,2020.
13A Additional Preliminaries
Simple graphs with directed and undirected edges. A simple graph G = (V,E) over nodes V = {V |
i
i∈[d]} with edges E is a graph where there is at most one edge between any two nodes. A graph is directed, if
all edges are directed edges →, and partially directed, if all edges are directed edges → or undirected edges .
Two nodes are adjacent, if an edge connects them. In particular a node is adjacent to itself.
Walks and paths. A walk w is a sequence of nodes (T,...,Y) where each successive pair of nodes is adjacent.
The nodes T and Y are called endpoint nodes on w. A path p is a sequence of distinct nodes (T,...,Y) and is a
special case of a walk. A walk w is possibly directed from T to Y if no directed edge along the path is directed
towards T (a possibly directed walk is sometimes called possibly causal). A walk w is directed from T to Y if
all edges along the path are directed and directed towards Y (a directed walk is sometimes called causal); every
directed walk is also a possibly directed walk. We often consider walks that are not possibly directed as they
contain at least one edge facing towards T, for ease, we call such a walk w non-causal. A directed path from T
to Y together with Y →T forms a cycle.
DAGs and PDAGs. Adirectedacyclicgraph(DAG)isasimpledirectedgraph,thatis,alledgesaredirected,
that has no cycles. A partially directed acyclic graph (PDAG) is a simple graph that is partially directed and
has no cycles. A DAG is also a PDAG. A walk w from a set T to a set Y is a walk from some node T ∈ T to
some node Y ∈Y, that is, T and Y are the endpoint nodes of the walk. The walk w is called proper, if it only
containsone node in T. Giventwo walksw =(A,...,B) andw′ =(B,...,C)we let w⊕w′ =(A,...,B,...,C)
denote the walk we obtain by concatenating w and w′.
Node relationships in DAGs and PDAGs. If the edge T → Y or T Y exists, T is a possible par-
ent of Y and Y a possible child of T. Let PossPa(Y,G) denote the set of all possible parents of Y and
PossCh(T,G) the set of all possible children of T. If there is a possibly directed path from T to Y or if
T = Y, T is a possible ancestor of Y and Y a possible descendant of T. Let PossAn(Y,G) denote the
set of all possible ancestors of Y and PossDe(T,G) the set of all possible descendants of T. If all edges
are directed, we analogously define the set of parents Pa(Y,G), children Ch(T,G), ancestors An(Y,G), and
descendants De(T,G). For a set T we define PossPa(T,G) = PossPa(T,G); we analogously define
T∈T
PossCh(T,G),PossAn(T,G),PossDe(T,G),Ch(T,G),Pa(T,G),De(T,G), and An(T,G). We also define
S
NonDe(T,G)=V\PossDe(T,G) which in the DAG case reduces to NonDe(T,G)=V\De(T,G).
Supergraph. A graph G =(V,E) is a called a supergraph of a graph G′ =(V,E′) if E′ ⊆E. We say that G
is a super-DAG of G′ if G is a DAG, and define super-CPDAG analogously.
Colliders, v-structures, and definite-status paths. A node V in a PDAG G is a collider on a path p if
p contains the subpath U → V ← W. Node V on a path p is called a definite non-collider on p if p contains a
subpath such that (a) U ←V, (b) V →W, or (c) U V W and U and W are not adjacent in G. A path p is
of definite status if every node on p is a collider, a definite-status non-collider, or an endpoint node. We define
all terms analogouslyfor walks. A path of the form U →V ←W in G is calleda v-structure if U and V are not
adjacent in G.
Blocking and d-separation in PDAGs. Let Z be a set of nodes in a PDAG G. A definite-status path p
is blocked given Z if p either contains a non-collider N ∈ Z or a collider C such that De(C,G)∩Z = ∅. A
definite-status walk w is blocked given Z if p either contains a non-collider N ∈ Z or a collider C such that
C ∈/ Z. A definite-status path or walk that is not blocked given Z is said to be open or d-connecting given Z.
Given three pairwise disjoint node sets T,Y,Z in a PDAG G we say that T is d-separatedfrom Y given Z in G
and write T⊥ Y |Z if Z blocks all definite-status paths from T to Y or equivalently all definite-status walks.
G
If it does not, we say that T and Y are d-connected given Z.
CPDAGs, Markov property, and Markov equivalence. A density f is Markov with respect to a DAG
G if for any three pairwise disjoint node sets T,Y,Z in G such that T⊥ Y |Z, T is conditionally independent
G
of Y given Z. Two DAGs that encode the same set of d-separation statements are called Markov equivalent.
Given a DAG G, the set of all DAGs that are Markov equivalent to G is called a Markov equivalence class
14and can be represented by a completed partially directed acyclic graph (CPDAG); a special subset of PDAGs
characterized by Meek [1995]. Note that a DAG is in general not a CPDAG. Given a CPDAG C let [C] denote
the corresponding equivalence class. For any DAG D ∈ [C] we say that C is the CPDAG of D. The CPDAG C
has the same v-structures and adjacencies as any DAG in [C]. Further, an edge → in C implies that every DAG
in [C] contains that edge →. An edge in C implies that some DAG in [C] contains the edge → and some other
DAG in [C] contains the edge ←.
Causal and forbidden Nodes. Given set T and Y in a DAG or CPDAG G, we define the causal nodes
Cn(T,Y,G) to be all nodes that lie on proper directed path from T to Y and are not in T. In a CPDAG G, we
define the possibly causalnodes PossCn(T,Y,G) to be allnodes that lie onproper possibly directedpaths from
T to Y and are not in T. We define the forbidden nodes as Forb(T,Y,G)=PossDe(PossCn(T,Y,G),G)∪T.
Amenability. Let T and Y be disjoint node sets in a DAG, CPDAG, MAG or PAG G. We saythat (G,T,Y)
is amenable if every proper possibly directed path from T to Y begins with an edge →.
The generalized adjustment criterion by Perkovic et al. [2018] provides necessary and sufficient graphical
conditions for a set to be a valid adjustment set:
Definition 17 (Generalized Adjustment Criterion). Let T,Y, and Z be pairwise disjoint node sets in a DAG,
CPDAG, MAG or PAG G. Then Z satisfies the generalized adjustment criterion relative to (T,Y) in G if the
following three conditions hold:
(Amenability) (G,T,Y) is amenable, and
(Forbidden set) Z∩Forb(T,Y,G)=∅, and
(Blocking) all proper definite-status non-causalpaths from T to Y are blocked by Z in G.
B Proofs
Proof of Proposition 7 (Distance to Super-DAG is Zero). LetI =I(G ,T,Y)beanidentifyingformula. Since
guess
I is sound and complete, I =f(y|do(t)) for any f compatible with G . Since any f compatible with G
guess guess
is also compatible with G (since all parent sets in G are supersets of parent sets in G ) it follows that
true guess true
I =f(y | do(t)) for any f compatible with G . Therefore, V(G ,I(G ,T,Y)) returns correct. Since this
true true guess
is true for any tuple (T,Y) our claim follows.
Proof of Lemma 9 (Ancestors are Valid Adjustment Sets). Since Forb(T,Y,G) \ De(T,G) = ∅, Z satisfies the
forbidden set condition of Definition 17. Let p be a non-causal path from T to Y. If p begins with an edge into
T, it contains a node in Pa(T,G) which is therefore also a node in Z that is a non-collider on p. It follows that
p is blocked. If p begins with an edge out of T, p is either directed or it must contain a collider C ∈ De(T,G).
Since Z∩De(T,G) =∅ and De(C,G) ⊆ De(T,G) it follows that p is blocked given Z. Therefore, Z satisfies the
adjustment criterion.
Proof of Lemma 10 (Parent-AID Misrepresents Causal Order). Here, Pa(V ,G ) = V for t−1 ≥ 1 and
t guess t−1
therefore the parent adjustment strategy I (G ,V ,V ) returns
P guess t y
f(v |v ,v )f(v )dv if y 6=t−1≥1,
y t t−1 t−1 t−1
f R(v y |v t) ("empty adjustment set") if t−1=0,
f(v y) if y =t−1≥1.
We now apply the verifier
VD
. Consider first inputs to the verifier of the form I = f(v ). The DAGs G
adj y true
and G have the same causal ordering and therefore any one of the p−1 such inputs with y = t−1 ≥ 1 is
guess
correct. Consider now the remaining inputs to the verifier of the adjustment form. Since V ∈ Pa(V ,G ) for
i t true
all i < t−1, no valid adjustment set exists for the effect of V on such a V in G . Further, if t < y then the
t i true
onlyvalidadjustmentsetis{V ,...,V }. Therefore,Pa(V ,G )isavalidadjustmentsetinG ifandonly
1 t−1 t guess true
ift=1ort=2andy >t. UsingI wethereforeobtainexactly3p−4=(p−1)+(p−1)+(p−2)identification
P
15formulas in G that are also correct in G , while the remaining (p2−p)−(3p−4)=p2−4p+4 are false.
guess true
It follows that
lim dIP(G ,G )/(p2−p)=1.
guess true
p→∞
Proof of Proposition 12 (Ancestor-AID Reflects Causal Order). Consider two nodes T and Y in a DAG G .
guess
If Y ∈D =De(T,G ), then A =An(T,G ) is a valid adjustment set in G by Lemma 9. If Y ∈/ D ,
T guess T guess guess T
then f(y |do(t))=f(y). Therefore, I is sound and complete.
A
ConsidertwoDAGsG andG ,suchthatG respectsthecausalordersofG ,thatis,De(T,G )⊆
true guess guess true true
De(T,G ) or equivalently An(T,G )⊆An(T,G ) for all nodes T. Fix a pair (T,Y) and consider I =
guess true guess TY
I (G,T,Y). If Y ∈/ De(T,G ) then Y ∈/ De(T,G ) and therefore, I = f(y) is a correct identifying
A guess true TY
formula in G . If Y ∈ De(T,G ) then Y ∈/ An(T,G ), which implies that Y ∈/ An(T,G ) and Y ∈/
true guess guess true
Pa(T,G ). Since Pa(T,G ) ⊆ An(T,G ) ⊆ An(T,G ) ⊆ NonDe(T,G ) and NonDe(T,G ) =
true true true guess guess guess
V\De(T,G ) ⊆ V\De(T,G ) we can therefore invoke Lemma 9 to conclude that I is correct in G .
guess true TY true
Therefore, dIA(G ,G )=0.
true guess
Suppose now that G does not respect the causalorder of G , that is, there exists a pair T,Y such that
guess true
Y ∈De(T,G )\De(T,G ). Since Y ∈/ De(T,G ), I =f(y) but this is wrong in G .
true guess guess TY true
Proof of Proposition 15 (Oset-AID is the I -Specific Distance). The soundness and completeness of I follows
O O
by the results of Henckel et al. [2022] and that the causal effect on a non-descendant is the observational
density.
C Additional Examples and Results
Example 18 (Counter-Examples where Oset Adjustment Distance is (not) Zero). Let G1 be the graph from
true
Figure 4a, G2 be the graph from Figure 4c, and G be the graph from Figure 4b.
true guess
Consider the pair (G1 ,G ). Since, V is an isolated node in G1 any identifying formula produced
true guess 2 true
by I for a pair involving V will be correct irrespective of G . Further, I (G ,V ,V ) = f(v ) and
O 2 guess O guess 3 1 1
I (G ,V ,V ) = f(v | v ). Since V ∈/ De(V ,G1 ) and the empty set is a valid adjustment set relative to
O guess 1 3 3 1 1 3 true
(V ,V ) inG1 it followsthatdIO(G1 ,G )=0. This showsthatthe Osetadjustmentdistance maybe zero
1 3 true true guess
even if G is not a supergraph of G .
guess true
Consider the pair (G2 ,G ). Since I (G ,V ,V ) = f(v | v ) and the empty set is not a valid
true guess O guess 2 3 3 2
adjustment set relative to (V ,V ) in G2 , dIO(G2 ,G ) 6= 0. This shows that G respecting the causal
2 3 true true guess guess
order of G does not ensure that the Oset adjustment distance is zero.
true
Example 19 (Correct CPDAGmay be furtherfrom trueDAGthan Incorrect CPDAG). LetGD beacomplete
true
DAG. Let G1 be the corresponding CPDAG, that is, the complete CPDAG. Since every effect in G is
guess guess
non-identifiable it follows that for any strategy-specific distance dI(G ,G1 ) = p(p−1). Let G2 be the
true guess guess
empty CPDAG. Since exactly half the effects in G are zero it follows that for any identification strategy that
true
uses a descendant check, such as I or I , dI(G ,G2 )=p(p−1)/2
A O true guess
Proposition 20 (Ancestor Adjustment Strategy is Sound and Complete for CPDAGs). Consider nodes T and
Y in a CDPDAG G, such that (G,T,Y) is amenable. Then An(T,G) is a valid adjustment set relative to (T,Y)
in G.
Proof. Since by assumption (G,T,Y) is amenable and An(T,G) satisfies the forbidden set condition of Defini-
tion 17, it only remains to show that An(T,G) satisfies the blocking condition. To see this consider a definite-
status non-causal path p from T to Y. If p begins with an edge ← it contains a node in Pa(T,G) and is
therefore blocked given An(T,G). If it begins with an edge or →, then it must contain at least one collider
C ∈ PossDe(T,G) by the fact that it is of definite status and may therefore not contain −V ← but contains at
least one backwards facing edge. Since De(C,G)∩An(T,G)=∅, it follows that p is blocked given An(T,G).
Lemma 21 (Oset-Characterization Simplifies Given Amenability). Consider two node sets T and Y in a
CPDAG G such that (G,T,Y) is amenable. Then
O(T,Y,G)=Pa(De(T,G)∩PropAn(Y,T,G),G)\De(T,G),
16V V V V V V V V V
1 2 3 1 2 3 1 2 3
a –G t1 rue b – G guess c– G t2 rue
Figure 4: DAGs for Example 18.
where PropAn(Y,T,G)) is the set of all nodes N, such that there exists a directed path from N to some Y ∈Y
that does not contain any nodes in T.
Proof. Recall that O(T,Y,G)=Pa(Cn(T,Y,G),G)\Forb(T,Y,G). Clearly,
Cn(T,Y,G)=De(T,G)∩PropAn(Y,T,G)
by the definition of Cn(T,Y,G). Since every causal node is in PropAn(Y,T,G) so is every node in O(T,Y,G).
Since every node that is both in PropAn(Y,T,G) and De(T,G) is a causal node and therefore forbidden it
follows that O(T,Y,G)∩De(T,G) = ∅. By Lemma E.6 by Henckel et al. [2022], Forb(T,Y,G) ⊆ De(T,G)
and therefore removing all nodes in De(T,G) from Pa(Cn(T,Y,G),G) is equivalent to removing all nodes in
Forb(T,Y,G).
D Algorithm Development
Many graph properties involved in the validation of adjustment sets, such as amenability, forbidden nodes, or
blocking, are based on the (non-)existence of paths with certain properties. For example, two nodes T and Y
are d-connected in a DAG given Z if and only if a path exists between them that is not blocked by Z. We
can reformulate the problem of verifying whether such a path exists as a reachability task: Starting from T,
try reaching Y by following all possible paths that are not blocked by Z until either you reach Y or you have
exhausted all possible paths.
The Bayes-Ball algorithm [Geiger et al., 1989, Shachter, 1998] uses the reachability framework to obtain all
nodes in a DAG that are d-connected to T given Z. A key insight for its efficient implementation is that a
d-connectingwalkexistsbetweentwonodesifandonlyifad-connectingpathexistsbetweenthem; thus,wecan
avoid having to a) check for each collider along the path that one of its descendants is in Z before continuing
and to b) follow all possible paths for which we need to keep track of all previously visited nodes along any
givenpathtraversal(to avoidvisiting the same node morethan once). Instead,we cantraversealongwalks and
continueawalkfromV toW alonganincoming/outgoingedgeifa’)W hasnotpreviouslybeenreachedthrough
an incoming/outgoing edge and if b’) the walk is not blocked by Z (if we face → V ←W, we continue from V
to W only if V ∈Z, otherwise we continue only if V 6∈Z). The benefit of a’)and b’) overa) and b) is that both
conditions are local to the current node in a walk and verifiable without querying ancestor sets or storing and
checking against all previously visited nodes. In this walk reachability algorithm, each node is visited at most
twice and each edge considered a constant number of times [see, for example, Appendix A in Wienöbst et al.,
2024] and therefore its runtime is linear in the number of nodes p plus the number of edges m; in dense graphs
the number of edges grows quadratic in the number of nodes and consequently the runtime is O(p2) for dense
graphs.
Wienöbst et al. [2024] generalize the algorithmic concept underlying Bayes-Ball to a class of DAG search
algorithms akin to a depth-first graph search that recursively visits neighbouring nodes that have not been
reached by the same kind of edge before. Since each node V is visited at most once per edge type (for example,
→V or←V inDAGs),theruntimeoftheirgensearch algorithmisalsoO(p2). Ruletablesencodetheconditions
for continuing on a given walk based on how the current node was reached and how the potential next node
W would be reached. Which rule table we use for the gensearch algorithm determines the properties of the
nodes that will be reached and therefore returned by the algorithm; for example, they show that a sequence of
gensearch algorithms with carefully chosen rule tables finds a minimal adjustment set in O(p+m) time.
Key to implementing our adjustment distances efficiently, is a new walk-status-awarereachability algorithm
that, given a DAG or CPDAG G with p nodes and m edges, set Z, and treatment nodes T, returns all nodes
Y such that Z is a valid adjustment set for (T,Y) in G in O(p +m) time. We use this algorithm to verify
an adjustment set for many Y simultaneously. To implement this algorithm, we prove a modified adjustment
17criterion, adapt the reachability algorithm for finding d-connected nodes in DAGs to account for walks that are
not of definite-status in CPDAGs, implement an amenability check, and show how to find nodes that satisfy all
conditions of the modified adjustment criterion with only one reachability algorithm. We proceed as follows:
• In Appendix D.1 we provea modified adjustment criterionthat translates all conditions of the generalized
adjustment criterion [Perkovic et al., 2018] into conditions on the (non-)existence of certain walks. An
adjustmentcriterionintermsofwalksallowsustoverifywhetheritholdsusingonlyreachabilityalgorithms.
• In Appendix D.2 we show how to verify blocking in CPDAGs with a reachability algorithm that uses no
non-local information to verify whether a walk is definite-status or not.
• In Appendix D.3 we provide motivation and intuition for our decision to add a walk-status to reachability
algorithms that is propagated forward in the depth-first search traversal of the graph. The addition of a
walk status allows us to track walks that do not transmit reachability,but may change status and become
walks for which we need to track nodes reached by such a walk.
• In Appendix D.4, we demonstrate how we use our new reachabilityalgorithmto calculate the Parent- and
Ancestor-AID between DAGs or CPDAGs with O(p(p+m)) and the Oset-AID with O(p2(p+m)) time
complexity.
D.1 Modified Adjustment Criterion
We prove a modified adjustment criterion that translates all conditions of the generalized adjustment criterion
[Perkovic et al., 2018] into conditions on the (non-)existence of certain walks. Having an adjustment criterion
exclusively in terms of walks allows us to use reachability algorithms to verify it.
Lemma 22 (Modified Adjustment Criterion for Walk-BasedVerification). Consider nodes T and Y in a DAG
or CPDAG G and a node set Z in G. The set Z fulfills the adjustment criterion if and only if
1. every proper possibly directed walk from T to Y begins with a directed edge out of T, and
2. no proper possibly directed walk from T to Y contains a node in Z, and
3. every proper definite-status walk from T to Y that contains a backwards facing edge is blocked by Z.
Proof. We proveour claims for the CPDAG case as the DAG case canbe shownwith the same basic arguments
butismuchsimpler. WefirstshowthatifZdoesnotsatisfytheadjustmentcriterionthenitalsodoesnotsatisfy
the alternativeadjustment criterion. Since the two criteriaboth assume amenability we canassume amenability
holds. Suppose that there exists a proper definite-status non-causal path p from T to Y that is open given Z.
Consider all colliders C ,...,C and the corresponding directed paths q ,...,q from C to some node Z ∈ Z.
1 k 1 k i i
Ifanyofthe q containsanode inT′ ∈Twecanreplacepwithq (T′,C )⊕p(C ,Y)sowithoutlossofgenerality
i i i i
we can assume this is not the case. By appending the q to p we obtain a proper definite-status walk from T to
i
Y that contains an edge ←, inherited from p.
We can therefore assume, no such p exists and that Z ∩ Forb(T,Y,G) 6= ∅. Since Forb(T,Y,G) =
PossDe(PossCn(T,Y,G),G)wecaninfactassumethatthereexistsanodeZ ∈Z∩(PossDe(PossCn(T,Y,G),G)\
PossCn(T,Y,G)). ForsuchanodeZ thereexistsadirectedpathp fromT toZ byLemmaE.6ofHenckeletal.
1
[2022] and a possibly directed path p from some causal node N. Since N is possibly causal there also exists a
2
possibly directed path p from N to some node in Y ∈ Y. We can choose all three paths to not contain other
3
nodesinZ. LetI bethe nodeclosesttoZ,wherep andp intersectandconsiderp =p (Z,I)⊕p (I,Y). Note
2 3 4 2 3
that p is colliderless and by taking shortcuts we obtain a definite-status path p∗, that is also colliderless. By
4 4
assumption on Z, p∗ must be non-causal and therefore the walk w =p ⊕p∗ has Z as a definite-status collider,
4 1 4
contains no other node in Z and all other nodes are endpoint nodes or definite-status non-colliders. The walk w
therefore violates the blocking condition of the modified criterion.
We now showthat if Z satisfiesthe adjustment criterionthen it satisfies the alternative adjustment criterion.
Again we can assume amenability holds. It suffices to show that any proper non-causal definite-status walk w
from T ∈ T to Y ∈ Y is blocked given Z. Suppose w is colliderless. This in particularly implies that w begins
with an edge T ← N. By snipping cycles and appropriate shortcuts we obtain a definite-status, colliderless,
non-causal path, where we use that N will always be of definite status and therefore the directed edge into T
18will never be removed. This path p is blocked given Z and therefore contains a node in Z. Therefore, so does w
which implies that it is blocked given Z. Suppose now that w contains colliders C ,...,C . By snipping cycles
1 k
and taking shortcuts we can again obtain a definite-status path p from T to Y. Suppose p is possibly directed,
that is, consists of possibly causal nodes. Then at least on of the colliders must be a descendant of a possibly
causal node and therefore w is blocked. If p is not possibly directed it must either contain a non-collider in Z
that is also a non-collider on w or a collider C, such that De(C,G)∩Z 6= ∅. In the former case, w is obviously
blocked. In the latter case, at least one of the C must satisfy C ∈/ Z which again suffices to conclude that w is
i i
blocked.
With this modified adjustment criterion we can algorithmically verify that a set Z is a valid adjustment set
for (T,Y) in DAG or CPDAG G, by verifying that
1. no proper possibly directed walk that does not begin with a directed edge out of T reaches Y, and
2. no proper possibly directed walk that contains a node in Z reaches Y, and
3. no proper definite-status non-causal walk that is not blocked by Z reaches Y.
Condition1.isequivalenttoCondition1.inLemma 22;sinceweneedtoverifythatnosuchwalkreachesY,the
reachabilityalgorithmwillneedtocontinuewalkingpossiblydirectedwalksthatdonotstartwithanedgeoutof
T evenif they are blockedby Z. Condition2.is equivalentto Condition2.inLemma 22;since we needto verify
that no such walk reaches Y, the reachability algorithm will need to continue walking possibly directed walks
that start with an edge out of T even if they contain a node in Z. Condition 3. is equivalent to the blocking
Condition 3. in Lemma 22; since the (non-)existence of blocked non-causal paths does not appear in any of the
conditions, the reachability algorithm can stop walking non-causal walks upon reaching a blocking node in Z;
however,theblockingconditionposesaproblemasverifyingwhetherapathisblockedrequiresanon-localcheck
to verify that it is of definite-status. In the following subsection, we show how to verify blocking in CPDAGs
with a reachability algorithm while avoiding this non-local definite-status check.
D.2 D-separation via a Reachability Algorithm for CPDAGs
In this section, we show how to verify blocking in CPDAGs by a reachability algorithm without needing to
discern the non-local property of a walk being definite-status or not. This is necessary to enable the use of
reachability algorithms with local decision rules to verify the blocking condition on definite-status walks in the
modified adjustment criterion. We show this in 5 steps:
• Lemma 23: Indefinite-status paths are irrelevant for d-separation in CPDAGs
• Lemma 24: Existence of open definite-status walks or paths coincides in CPDAGs
• Lemma 25: Reachability algorithm with non-local decision rules for d-connectedness in CPDAGs
• Lemma 26: We may treat some indefinite-status walks as definite-status
• Lemma 27: We may treat some more indefinite-status walks as definite-status
The following lemma by Henckel et al. [2022] characterizes d-separation in a CPDAG in terms of definite-
status paths.
Lemma 23 (Indefinite-statuspathsareirrelevantford-separationinCPDAGs). Consider nodesetsT,Y and Z
in a CPDAG G. Then T is d-separated from Y given Z in every DAG D ∈[G] if an only if every definite-status
path from T to Y is blocked given Z in G.
Checking whether a collider is open on a definite-status path requires checking a non-local condition, as we
need to consider all descendants of the collider. In DAGs we can circumvent that by considering walks instead,
as it is possible to show that anopen path exists if andonly if anopen walk exists. We now show that a similar
result holds for CPDAGs, connecting definite-status paths and connecting definite-status walks.
Lemma 24 (Existence of open definite-status walks or paths coincides in CPDAGs). Consider node sets T,Y
and Z in a CPDAG G. Then there exists a definite-status path from T to Y that is open given Z if and only if
there exists a definite-status walk from T to Y that is open given Z.
19Proof. Letpbeadefinite-statuspathfromsomeT ∈TtosomeY ∈YthatisopengivenZinG. LetC ,...,C
1 k
be all colliders on p. By assumption there exist directed paths q ,...,q from C to some node Z ∈ Z that we
1 k i i
choose to not contain any other node in Z. Then w = p(T,C )⊕q (C ,Z )⊕q (Z ,C )⊕···⊕p(C ,Y) is a
1 1 1 1 1 1 1 k
definite-status walk from T to Y that is open given Z.
For the converse direction consider a walk w and let I be the node closest to T on w that appears twice w,
i.e., w = w(T,I)⊕w(I,I)⊕w(I,Y). Consider the walk w′ =w(T,I)⊕w(I,Y). We will now show that either
w′ itselfisadefinite-statuswalkfromT toY suchthatnono-colliderisin Zandeverycolliderhasadescendant
in Z or that we can construct a shortcut walk that is. Since w′ contains at least one repeating node less than
w we can then iterate this contraction to obtain a definite-status path open given Z. Every node on w′ inherits
their definite status fromthe path w exceptforI. Suppose I ∈Z, then I mustbe a colliderwheneverit appears
on w and therefore it also a definite-status collider on w′ which is therefore of the claimed form. Suppose now
that I ∈/ Z. Then it must be a non-collider whenever it appears on w. There are three cases to consider: a) I
is a collider on, w′ b) I is a definite-status non-collider on w′ and c) I is not of definite status on w′. In case
a) w must have been of the form T··· → I → ··· ← I ← ···Y. Therefore w must contain a collider that is a
descendant of I. Therefore De(I,G)∩Z6=∅. In case b) w′ trivially fulfills the required conditions.
In case c) we again consider three subcases: a) A → I −B, b) A−I ← B and c) A−I −B. In all three
casesA andB aredefinite-statusnon-collidersonw′ as they inheritedtheir status fromw andthey cannothave
been colliders. This also implies that A,B ∈/ Z. In case a) there must also exist an edge A → B and we can
replace w′ with w′(T,A)⊕w′(B,Y). The node A is a definite non-collider on this new walk. If B is also we are
done. If it is not, i.e., we have the structure A → B −B′ we can replace w′ again by repeating the argument
we just made and taking the shortcutto B′. We cando so iteratively, until we encounter either a definite-status
non-collider or Y itself. Either way we obtain a definite-status walk such that every non-collider is not in Z and
everycollider has a descendantthat is. Caseb) follows by the exactsame argumentreversingthe rolesof A and
B. In case c) we must have an edge A−B. Again we replace w′ by taking the shortcut. If A is not of definite
status on the new walk,i.e, it contains the segment A′−A−B, there must exist an edge A′−C. We can again
iteratively takeshortcuts until we either obtainanA′ thatis a definite-status non-colliderorarriveatT. If B is
not of definite status we repeat the same procedure untile we arrive at definite-status B′ or Y. In all cases, we
obtain a walk w′ of definite status that is open given Z.
BasedonLemma24wecanproposeareachabilityd-separationalgorithmthatadditionallytracksanddiscerns
whether a walk in a CPDAG is definite-status or not. The algorithm is a gensearch algorithm [Wienöbst et al.,
2024, Algorithm 6] using the rule table given in Table 1 to traverse the graph. We now prove that this table is
correct for d-separation in CPDAGs.
Lemma 25 (Reachability algorithm with non-local decision rules for d-connectedness in CPDAGs.). Consider
a node set T in a CPDAG G and let Z be a node set in G. The output of a reachability algorithm (gensearch by
Wienöbst et al. [2024]) with the rule table given in Table 1 is the set of all nodes Y ∈ V that are d-connected
with T given Z in G.
case continue to W yield W
init T −W always always
init T →W always always
init T ←W W ∈/ Z always
−V −W V ∈/ Z and V of definite status V ∈/ Z and V of definite status
−V →W V ∈/ Z V ∈/ Z
−V ←W never never
→V −W never never
→V →W V ∈/ Z V ∈/ Z
→V ←W V ∈Z V ∈Z
←V −W V ∈/ Z V ∈/ Z
←V →W V ∈/ Z V ∈/ Z
←V ←W V ∈/ Z V ∈/ Z
Table 1: Rule table for gensearch algorithm [Wienöbst et al., 2024] to compute all d-connected nodes in a
CPDAG.
20Proof. Every node adjacent to some T ∈T is d-connected with T given Z. Therefore, the initialization step of
the reachability algorithm is correct. Now suppose that if we arrive at a node V in the reachability algorithm
thatthereexistssomedefinite-statuswalkw fromsomeT ∈TtoV thatisopenZandconsideraproperstepof
the reachability algorithm continuing from V. Based on the rule table we continue and yield W precisely when
appending the edge between V and W to w results in a definite-status d-connecting walk w′ from T to W, i.e.,
if V is definite non-collider on w′ and V ∈/ Z or if V is a collider on w′ and V ∈Z. By induction it follows that
for every reachable node Y there exists a definite-status d-connecting walk from T which by Lemma 24 suffices
to conclude that T and Y are d-connected given Z.
We now show that if a node Y is d-connectedwith some T ∈T givenZ then it will be returnedas reachable.
ByLemma24thereexistadefinite-statusd-connectingwalkfromT toY. Wenowmakeaninductionargument
on the length l of the shortest such walk. If l = 1, the algorithm clearly returns Y, so suppose the algorithm
returnsallnodeswithshortestpathsoflengthl =k−1andsupposeforY the shortestwalkw isoflengthl =k.
Let w′ be the walk we obtain by removing the final edge from w. It’s a walk of length l that is d-connecting
givenZandthereforethisholdsforit’sendnodeY′. Bythe inductionhypothesisY′ isreachable. Further,since
w is a definite-status d-connecting walk we can see that by applying the rule table to Y′ the algorithm will also
return Y.
From an implementation perspective, it is problematic that in the fourth row of Table 1 we need to check
whether V is of definite status, since this requires storing adjacent nodes for previously visited nodes, that is,
this rule is non-local. We now show that we can simply drop this check without modifying the output of the
algorithm and in this way obtain a local algorithm.
Lemma 26 (We maytreatsomeindefinite-statuswalksasdefinite-status). Consider a node set T in a CPDAG
G and let Z be a node set in G. Suppose we modify the rule table in Table 1 by treating the V W case as
if V were of definite status (irrespective of whether it actually is). The resulting reachability algorithm has the
same output as the original algorithm.
Proof. The two algorithms agree locally in all cases except in the case −V −W, with V ∈/ Z not of definite
status, where the originalalgorithmdoes notcontinue to W andthe modified algorithmdoes andalso considers
allverticessuchthatW−W′ orW →W′ ifW ∈/ Z. SupposethatstartingfromsomeT ∈T, V isthe firstnode
where the two algorithms disagree, i.e., there exists a V′ reachable by both algorithms such that V′−V −W,
V ∈/ Z and V′−W. Since V′ is reachable with the original algorithm and we continue onto an undirected edge,
V′ ∈/ Z and we arrive at V′ via an edge of the form ← V′ or −V. The original algorithm will therefore reach
W, either via ← V′−W or −V′−W unless in the latter case V′ is not of definite status. If the latter is the
case we can repeat the argument to obtain a new V′ until we either arrive at a V′ that is of definite status or
the walk T −W. In either case, W is reachable and if W ∈/ Z we will consider all vertices such that W −W′ or
W →W′.
Finally, we will use a d-separation reachability algorithm within our new reachability algorithm to verify
adjustment validity. Here, we also need to verify whether Z contains possibly causal nodes, that is, whether
there exists a proper possibly directed path from T to Y that contains a node in Z (see Lemma 22). To do so,
we may have to continue along segments of the form → N if N ∈/ Z which are of indefinite status. We now
show that we can further modify the d-separationrule tables to accommodate this without changing the output
of the d-separation reachability algorithm. This will allow us to run all three checks required in the validity
algorithm simultaneously. If we were only interested in d-separation, the rule table from Lemma 26 is more
computationally efficient.
Lemma 27 ( We may treat some more indefinite-status walks as definite-status). Consider a node set T in a
CPDAG G and let Z be a node set in G. Suppose we modify the rule table in Table 1 by treating the V W
case as if V were of definite status and the → V case by proceeding if V ∈/ Z (analogous to the rule for
definite-status non-colliders). The resulting reachability algorithm has the same output as the original algorithm.
Proof. WehavealreadyestablishedinLemma26,thatwecanignorethedefinite-statuscheckwithoutmodifying
the output so consider analgorithmbasedonthis rule table andcompare it to analgorithmwith the additional
rulemodificationstatedinthe lemma. The twoalgorithmsagreelocallyinallcasesexceptinthe case→V −W,
with V ∈/ Z, where the original algorithm does not continue to W and the modified algorithm does and also
considers all vertices such that W −W′ or W → W′ if W ∈/ Z. Suppose that starting from some T ∈ T, V is
21the first node where the two algorithms disagree, i.e., there exists a V′ reachable by both algorithms such that
V′ → V −W, V ∈/ Z and V′ → W. Since V′ is reachable with the original algorithm and we continue onto
an undirected edge, V′ ∈/ Z and we arrive at V′ via an edge of the form ← V′ or −V. The original (and the
modified) algorithm will therefore reach W, either via ←V′ →W or −V′ →W. In either case, W is reachable
and if W ∈/ Z we will consider all vertices such that W −W′ or W → W′ and if W ∈ Z we will consider all
vertices such that W ← W′. This means W′ is reachable either way and we will in fact move onto a larger
number of the adjacent nodes of W, regardless. The extra check we make in the modified algorithm therefore
does not modify the output.
D.3 Walk-Status in Reachability Algorithms
In addition to the result from Appendix D.1 and Appendix D.2, we require one more idea in order to be able to
verifytheadjustmentcriterionwithareachabilityalgorithm: whenverifyingtheadjustmentcriterionawalkmay
at first not violate the adjustment criterionbut as we append edges to it it may become a walk whose existence
violates the adjustment criterion. For example, a directed walk starting from T does not violate the adjustment
criterion until it either encounters a node in Z or turns into an open definite-status non-causal walk. In order
to track such walks, we need to carry forward information about the current walk’s status when traversing the
graph;specifically,werequirethataquinarywalkstatusbepropagatedforward. Knowingawalk’sstatusallows
us to use more complex local rules about when to continue a walk (for example, only stopping on a blocked
walk when the walk is non-causal) and assigning different tags to a node depending on the status of the walk
with which we reached it; two examples of this are a) adding a non-amenable tag to nodes we can reach with
a possibly directed walk that begins with an undirected edge, and b) adding a not-validly-adjusted-for tag to
nodes we can reach with a possibly directed walk that contains a node in Z, since this is a walk that contains a
possibly causal node.
Assume we start the algorithm in T given some Z, by construction we never walk back into T, that is, all
walks are proper walks. Also, we never visit the same node via the same edge on a walk of the same type twice,
such that our algorithm has runtime guarantee O(p+m) analogous to the Bayes-Ball and gensearch algorithm.
The walk status is quinary and one of the following:
PDT→OPEN – These are possibly directed walks that started with an edge pointing out of T are not blocked by
Z. ReachinganodeY byaPDT→OPEN walkdoesnottellusanythingaboutwhether(G,T,Y)isamenable
or whether Z is a valid adjustment set for (T,Y). Instead, we need to keep walking such a walk as it may
turnintoablocked(possiblydirectedwalkthatstartedwithanedgepointingoutofT)walkuponpassing
through Z or a non-causal walk upon traversing along a backward-facing edge ←, which are walks that
contain information about amenability or validity of adjustment for the nodes reached.
PDT OPEN –ThesearepossiblydirectedwalksthatstartedwithanundirectededgeoutofT andarenotblocked
by Z. Reaching a node Y by a PDT OPEN walk tells us that (G,T,Y) is not amenable (which implies
that Z cannot be a valid adjustment set for (T,Y)) as Condition 1 in the Modified Adjustment Criterion
is violated. We need to keep walking such a walk as other nodes reached by it are also not amenable and
as it may turn into a blocked (possibly directed walk that started with an undirected edge out of T) or a
non-causal walk (which we need to check are blocked).
PDT→BLOCKED – These are possibly directed walks that started with an edge pointing out of T and contain a
node in Z. Reaching a node Y by a PDT→BLOCKED walk tells us that Z is not a valid adjustment set for
(T,Y)asCondition2intheModifiedAdjustmentCriterionisviolated(thewalkmusthavepassedthrough
anode in Z). We needto keepwalkingsuchawalkas Zis alsonota validadjustmentsets forother nodes
reached by this walk and as it may turn into a non-causal walk (which we need to check are blocked).
PDT BLOCKED –ThesearepossiblydirectedwalksthatstartedwithanundirectededgeoutofT andareblocked
by Z. Reaching a node Y by a PDT BLOCKED walk tells us that (G,T,Y) is not amenable (which implies
that Z cannot be a valid adjustment set for (T,Y)) as Condition 1 in the Modified Adjustment Criterion
is violated. We need to keep walking such a walk as other nodes reached by it are also not amenable and
as it may turn into a non-causal walk (which we need to check are blocked).
NONCAUSAL— These are walks that have passed through at least one backward-facing edge and are thus non-
causal and are not blocked by Z; if they were blocked by Z we would just stop walking such a non-causal
22blocked walk. Reaching a node Y by a NONCAUSAL walk tells us that Z is not a valid adjustment set for
(T,Y) as Condition 3 in the Modified Adjustment criterion is violated.
To summarise and help intuition, we provide the following illustration of the possible walk-status changes:
start T W
PDT OPEN PDT BLOCKED
→V →W
V →W
start T ←W NONCAUSAL when walking →V ←W,V ∈Z when walking  ,V ∈Z
V W
→V W
sP taD rT t→ TO →PE WN   PDT→BLOCKED
An instructive first example of a reachability algorithm is Algorithm 2 to check amenability, which we use
alsoinourimplementationofthe identificationstrategiesforCPDAGs. Here,theroutinesimplifiesconsiderably,
since we only start walking PDT OPEN and PDT BLOCKED walks from T and all nodes Y reached by a such a
walk are nodes such that (G,T,Y) is not amenable.
Finally,inAlgorithm3wepresentthekeytoefficientlyimplementingadjustmentverificationforouradjustment-
based identification distances: Given a graph (DAG or CPDAG) G, treatment T, and candidate adjustment set
Z, Algorithm 3 returns in O(p+m) time two lists a) NAM (“not amenable”) containing all Y such that (G,T,Y)
is not amenable, and b) NVA (“not validly adjusted for”) containing all Y such that Z is not a valid adjustment
set for (T,Y) in G.
Algorithm 2 Check amenability of a CPDAG G relative to (T,Y) for a given set T of treatment nodes and all
possible Y
1: Input: CPDAG G and a set of treatment nodes T in G
2: Output: Set NAM of nodes Y 6∈T in G such that G is not amenable relative to (T,Y)
3: function visit(arrivedby, V)
4: visited.insert(V)
5: if arrivedby == init then ⊲ Start walking proper possibly directed walks that do not start out of
T
6: for W in AdjacentNodes(V)\T do
7: if W not in visited then
8: visit( , W)
9: else ⊲ Continue walking proper possibly directed walks
10: NAM.push(V) ⊲ Reached V by a proper possibly directed walk that does not start out of T
11: for W in AdjacentNodes(V)\T do
12: if W not in visited then
13: visit( , W)
14: for W in Ch(V)\T do
15: if W not in visited then
16: visit(→, W)
17: Initialise NAM as empty set
18: Initialise visited as empty HashSet
19: for V in T do visit(init, V)
20: return NAM
23Algorithm 3 Validate Z as adjustment set relative to (T,Y) for a given set T of treatment nodes and all possible Y
in G
1: Input: CPDAG (or DAG) G, a set of treatment nodes T in G, and a set of adjustment nodes Z in G
2: Output: Set NAM of nodes Y 6∈T in G such that G is not amenable relative to (T,Y)
3: Set NVA of nodes Y 6∈T in G such that Z is not a valid adjustment set for (T,Y) in G
4: function nextsteps(arrivedby, V) ⊲ Return (moveonby, W, blocked) triplets
5: Initialise next as empty set
6: if arrivedby == → then
7: for W in Pa(V)\T do ⊲ collider →V ←W
8: next.push((←, W, 1(V 6∈Z)))
9: else if arrivedby in {init,←} then
10: for W in Pa(V)\T do ⊲ ←V ←W
11: next.push((←, W, 1(V ∈Z)))
12: for W in AdjacentNodes(V)\T do ⊲ →V W or V W or ←V W
13: next.push(( , W, 1(V ∈Z)))
14: for W in Ch(V)\T do ⊲ →V →W or V →W or ←V →W
15: next.push((→, W, 1(V ∈Z)))
16: return next ⊲ omits steps to T and V ←W
17: function visit((arrivedby, V, walkstatus))
18: visited.insert((arrivedby, V, walkstatus))
19: if walkstatus in {PDT OPEN,PDT BLOCKED} then
20: NAM.push(V) andNVA.push(V) ⊲ Reached V by a possibly directedwalk that does not startout of T
21: else if walkstatus == NONCAUSAL then
22: NVA.push(V) ⊲ Reached V by a non-causalwalk that is not blocked by Z
23: else if walkstatus == PDT→BLOCKED then
24: NVA.push(V) ⊲ Reached V by a possibly directed walk that is blocked by Z
25: for (moveonby, W, blocked) in nextsteps(arrivedby, V) do
26: next = none
27: if walkstatus == init then
28: if moveonby == → then next = (→, W, PDT→OPEN) ⊲ Start possibly directed walk T→
29: else if moveonby == then next = ( , W, PDT OPEN) ⊲ Start possibly directed walk T
30: else if moveonby == ← then next = (←, W, NONCAUSAL) ⊲ Start non-causalwalk
31: else if walkstatus in {PDT→OPEN,PDT→BLOCKED} then
32: if moveonby in {→, } then
33: if blocked == false then next = (moveonby, W, walkstatus)
34: else if blocked == true then next = (moveonby, W, PDT→BLOCKED)
35: else if moveonby == ← and blocked == false and walkstatus == PDT→OPEN then
36: next = (moveonby, W, NONCAUSAL)
37: else if walkstatus in {PDT OPEN,PDT BLOCKED} then
38: if moveonby in {→, } then
39: if blocked == false then next = (moveonby, W, walkstatus)
40: else if blocked == true then next = (moveonby, W, PDT BLOCKED)
41: else if moveonby == ← and blocked == false and walkstatus == PDT OPEN then
42: next = (moveonby, W, NONCAUSAL)
43: else if walkstatus == NONCAUSAL and blocked == false then
44: next = (moveonby, W, NONCAUSAL)
45: if next is not none and next not in visited then VISIT(next)
46: Initialise NAM as empty set
47: Initialise NVA as empty set
48: Initialise visited as empty HashSet
49: for V in T do visit((init, V, init))
50: return NAM and NVA
24D.4 Our Algorithm Enables Efficient Calculation of Parent-, Ancestor-, and Oset-
AID
Forthe three distances,Parent-AID,Ancestor-AID,andOset-AID,weneedto identify adjustmentsetsin G
guess
with anadditionalamenabilitycheckincaseG is aCPDAG andthen verifythe proposedadjustmentsetsin
guess
G . WhilealgorithmswithO(p+m)runtimeexistforeachinvolvedcomputation,thealgorithmicdevelopment
true
in the preceding subsections is crucial to enable efficient calculation of the distances: Algorithm 3 enables us to
verify adjustment sets for all {(T,Y′) | Y′ ∈ V\{T}} with one O(p+m) run, instead of performing (p−1)
separate runs of a valid adjustment verifier algorithm. For simplicity and as an instructive example, we first
discuss our implementation of the Parent-AID for DAGs and then present the general routine for implementing
our distances.
D.4.1 Calculating the Parent Adjustment Identification Distance Efficiently
To calculate the Parent-AID between two DAGs G and G over p nodes and m edges, we need to iterate
true guess
over all tuples (T,Y) of nodes, obtain the parent set of the treatment in G , and check whether this set is a
guess
valid adjustment set in G with respect to (T,Y). For their SID implementation, Peters andBühlmann [2015]
true
report a worst-case runtime of O(p·log (p)·p3) where the factor p3 corresponds to squaring of the adjacency
2
matrix of G which is done ⌈log (p)⌉ times to assemble a path matrix that codes which nodes are reachable
true 2
from each of the n treatment nodes.5
Combiningtheabovealgorithms,wecancalculatetheParent-AIDwithanalgorithmwithruntimeO(p(p+m))
as follows:
• Initialise the mistake count c=0
• For each node T (each of the following steps can be completed in O(p+m) time)
– Obtain Z as the set of parents of T in G
guess
– Obtain ND as the set of non-descendants of T in G
true
– Obtain NVA as the the set of nodes Y such that Z is not a valid adjustment set for (T,Y) in G
true
– Add
|Z\ND| + |Z∁ ∩NVA|
guessednoeffect,butdescendantinGtrue ZvalidadjustmentsetinGguess,butnotinGtrue
to the mistake count c | {z } | {z }
• Return dIP(G ,G )=c
true guess
OurParent-AIDcoincides withthe SID onlyasdistance betweenDAGs,but, incontrasttothe SID,general-
izes to CPDAGs. The multi-set SID betweenCPDAGs requiresexponentialruntime, while Parent-AIDbetween
CPDAGs is still O(p(p+m)) as shown in the next subsection.
D.4.2 Calculating Adjustment Identification Distances Efficiently
We fix the treatment T and apply our algorithm to all tuples (T,Y),T 6= Y simultaneously. We also group
our identifying formulas as follow: For each T, the identification strategy algorithm returns a vector of (node,
identifying formula) tuples which we code as a triple (A,B,(Y,Z(Y)) Y∈C) consisting of a) the set nodes A for
which the causal effect from T is not identifiable, b) a set of nodes B for which the causal effect from T is zero
and c) a set of two-tuples consisting of the remaining nodes Y ∈C=(A∪B)c and for each Y a corresponding
valid adjustment set Z(Y). To compute this vector, we first apply a reachability algorithm to compute I =
amen(T,G ) (Algorithm 2), where amen(T,G) denotes the set of nodes Y such that (G,T,Y) is amenable .
guess
For the parent strategy we then compute P = Pa(T,G guess) and return (Ic,P,(Y,P) Y∈I\P). For the ancestor
strategywecomputeA=An(T,G),D=De(T,G)andreturn(Ic,Dc∩I,(N,A) N∈D). Forthe Osetstrategy,we
5One may be able to reduce the cubic runtime for the matrix multiplication if the adjacency matrices exhibit extra known
structure, though,thealgorithmwiththebestknownasymptoticruntimetodateofO(p2.37)isagalacticalgorithmandnotusable
inpractice[AlmanandWilliams,2020]. Forcertainadjacencymatrices,theStrassenalgorithmformatrixmultiplicationmayenable
areduction toO(plog2(7))(log (7)≈2.81).
2
25compute D, O(T,Y,G)=Pa(D∩An(Y,G))\D for each Y ∈D and return (Ic,Dc∩I,(Y,O(T,Y,G guess)) Y∈D).
We repeat these steps for each T and return a vector of three-tuples. The overall complexity is therefore
O(p(p+m)) for the parent and ancestor strategies,and O(p2(p+m)) for the Oset strategy. The additional p is
due to O(T,Y,G) depending on Y, whereas Pa(T,G) and An(T,G) do not depend on Y.
ConsidernowtheverificationstepforafixedtreatmentT andthecorrespondingtriple(A,B,(Y,Z(Y)) Y∈C).
We compute I′ = amen(T,G ) and D′ = De(Y,G ) in O(p+m) using reachability algorithms. For each
true true
unique Z(Y) we then apply a reachability algorithm to compute set of nodes N ∈ V(T,Z(Y),G ) such that
true
Z(Y) is a valid adjustment set relative to (T,N) in G (Algorithm 3). For the parent and ancestor strategy
true
there is only one Z(Y), so we only need to do this step once. We then add
|A∩I′|+|B∩D′|+#{Y ∈C\V(T,Z(Y),G )}
true
tothedistancebetweenG andG . AswehavetorepeatthisforeachT,theoverallruntimefortheverifier
true guess
is O(p(p+m)) for the parent and ancestor strategies, and O(p2(p+m)) for the Oset strategy.
E Empirical Analysis of Algorithmic Time Complexity
To empirically analyze the runtime complexity of our distance implementations, we evaluate the algorithms on
inputsofvaryingsizepandmeasuretheruntimer (p)(here,weusethewalltime). Foragivencomplexity,such
emp
as O(p2), we then projectthe runtime we wouldexpectfor any p basedonthe runtime observedforthe smallest
size p. We denote the projected runtime for p as r (p). The idea is that the ratio of the projected runtime
proj
r (p)andtheobservedempiricalruntimer (p)approaches1inthelimitofp→∞iftheimplementationhas
proj emp
the complexity used to compute r (p). For a given algorithm distance(G ,G ) we proceed as follows.
proj true guess
• (Grid of graph sizes)
Specify a grid of graph sizes P, for example, P =(8,16,32,64,128,256,512,1024).
• (Observed empirical runtimes)
Sample, for each p ∈ P, 11 pairs of DAGs G = (V,E ) and G = (V,E ) with |V| = p and
true true guess guess
edges drawn independently with probablity 20p/(p−1) for sparse and 0.3p(p−1)/2 for dense graphs (the
expectednumberofedgesisthus linearinthe numberofnodesforsparse,andquadraticfordense graphs).
Werundistanceonthose11pairsandcomputetheaverageruntimeoverthese11runs,denotedr (p).
emp
• (Project the runtime under the given time complexity O(c(p)) where, for example c(p)=p2)
Weobtaintheprojectedruntimeforinputs ofsizepunderthegiventime complexitybasedonthesmallest
input size p∗ =min(P) as
r (p∗)
emp
projected runtime: r (p)=c(p) .
proj c(p∗)
• (Relative projected runtime)
To compare the projected runtime to the observed empirical runtime, we then visualize the projected
runtime as a fraction of the observed empirical runtime
r (p)
proj
relative projected runtime: .
r (p)
emp
As we consider asymptotic complexity, we need to evaluate for large enough p to assess the following trends
of relative projected runtimes for increasing p. If, when comparing to O(c(p)), the relative projected runtime
increaseswiththe number ofnodes p,this indicates thatthe empiricaltime complexityis lowerthanO(c(p)). If,
when comparing to O(c(p)), the relative projected runtime decreases with the number of nodes p, this indicates
that the empiricaltime complexity is largerthanO(c(p)). If the algorithmhastime complexity O(c(p)) then we
expect the relative projected runtime for this complexity to be close to constant.
26