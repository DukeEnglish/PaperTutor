Safety Verification of Wait-Only Non-Blocking
Broadcast Protocols
1 2 3
Lucie Guillou , Arnaud Sangnier , and Nathalie Sznajder
1
IRIF,CNRS, UniversitéParis Cité, France
2
DIBRIS,Universitàdi Genova, Italy
3
LIP6, CNRS,SorbonneUniversité, France
Abstract. We study networks of processes that all execute the same
finite protocol and communicate synchronously in two different ways: a
process can broadcast one message to all other processes or send it to
at most one other process. In both cases, if no process can receive the
message, it will still be sent. Weestablish a precise complexity class for
twocoverabilityproblemswithaparameterisednumberofprocesses:the
statecoverabilityproblemandtheconfigurationcoverabilityproblem.It
is already known that these problems are Ackermann-hard (but decid-
able) inthegeneralcase. Weshowthatwhentheprotocol isWait-Only,
i.e., it hasnostatefrom which aprocess cansend andreceivemessages,
the complexity dropsto P and PSpace, respectively.
Keywords: Parameterised Networks· Broadcast · Verification
1 Introduction
Verification of distributed systems. The ubiquity of distributed and concurrent
systems in nowadays applications leads to an increasing need to ensure their
correct behaviour. Over the last two decades, the verification of such systems
has become a crucialresearchdirection in the field of computer science. Indeed,
analysingdistributedsystemshasproventobechallenging.Onedifficulty isdue
to the numerousinterleavingscausedby the concurrentbehaviourofthe system
entities, that make the design and modelling of these systems very complex.
Moreover,thenumberofagentsisoftennotknownapriori;inthatcase,verifying
all possible behaviours of such a system amounts to analyse it for any number
of agents, i.e. an infinite number of times. The unpredictability of the number
of participants in a system makes classical techniques such as model-checking
impractical and requires some new techniques.
Parameterised verification. Addressing the challenge of unbounded entities in-
volves designing schematic programs or protocols intended for implementation
by multiple identical processes and parameterised by the number of entities.
While in general parameterised verification is undecidable [AK86], several re-
alistic restrictions enable automatic verification. Among them, one can high-
light systems where entities have no identity, and systems with simple com-
4202
raM
72
]OL.sc[
1v19581.3042:viXramunication mechanism. Several papers have considered synchronous communi-
cation means, as rendez-vous [GS92,DRB02,HS20,BER21,GSS23] and broad-
cast[EFM99,DSTZ12].Notethat,surprisingly,parameterisedverification,when
decidable, is sometimes significantly easier than the same problem with a fixed
number of entities [DEGM17]. In all those models, all the entities execute the
same programwhich is modelled as a finite-state automaton.
Wait-Only Non-Blocking Broadcast protocols In[GSS23],theauthorshavestud-
ied the complexity of severalparameterisedverificationproblems in the context
ofnon-blockingrendez-vous.Thiscommunicationmechanism,motivatedbyJava
Threads programming, involves at most two processes: when a process sends a
message, it is received by at most one process ready to receive the message,
and both processes jointly change their local state. However, when no process
is ready to receive the message, the message is sent anyway and lost, and only
the sender changes its local state. This is in contrast with classical rendez-vous
as studiedfor instance in[GS92],where asender is preventedto sendamessage
if no process can receive it. The model proposed in [GSS23] allows to capture
some behaviour of the Threads:when a Thread is suspended in a waiting state,
it can be woken up upon the reception of a notify message sent by another
Thread, but the sender is not blocked if no Thread is suspended; it simply con-
tinuesitsexecutionandthenotifymessageislost.However,thisfailstocapture
the behaviour of what occurs when a Thread sends a notifyAll message that
will be received by all the suspended Threads waiting for that message. This,
as already highlighted in [DRB02], is modelled by the broadcast mechanism, in
which a message sent by a process will be received by all the processes ready
to receive it. Observe that broadcast is also a non-blocking means of communi-
cation. In this work we consider Non-Blocking Broadcast protocols, that allow
forbothbroadcastandnon-blockingrendez-vous.Oneimportantprobleminpa-
rameterised verification is the coverability problem: is it possible that, starting
from an initial configuration, (at least) one process reaches a bad state? With
classical rendez-vous mechanism, this problem is in P [GS92], while with non-
blocking rendez-vous, it is Expspace-complete [GSS23]. For protocols enabling
both broadcast and non-blocking rendez-vous, the problem is decidable [EK03]
and Ackermann-hard [SS13,EFM99,ARZ15]. In this work we study the cover-
abilityproblemforasyntacticrestrictionoftheprotocols,introducedin[GSS23],
namelyWait-Onlyprotocols,inwhichthereisnostatefromwhichaprocesscan
both send and receive a message. In this context, when processes communicate
with non-blocking rendez-vous only, the coverability problem is in P [GSS23].
Our contributions. We show that the coverability problem for Wait-Only Non-
Blocking Broadcast protocols is P-complete, and that the configuration cover-
ability problem is PSpace-complete. This last problem asks whether it is possi-
ble to cover a given configuration (and not simply a bad state) from an initial
state. Note that both problems are in P when forbidding broadcasts [GSS23],
however,inthiswork,theP-membershipproofislessinvolvedandthePSpace-
membership proof uses a different technique.
22 Model and verification problems
We denote by N the set of natural numbers. For a finite set E, the set NE
represents the multisets over E. For two elements s,s′∈NE, we denote by s+s′
the multiset such that (s+s′)(e)= s(e)+s′(e) for all e ∈ E. We say that s′ is
bigger than s, denoted s ⪯ s′ if and only if s(e) ≤ s′(e) for all e ∈ E. If s ⪯ s′,
then s′−s is the multiset such that (s′−s)(e)=s′(e)−s(e) for all e∈E. Given
a subset E′ ⊆E and s∈NE, we denote by ∣∣s∣∣ E′ the sum Σ e∈E′s(e) of elements
of E′ present in s. The size of a multiset s is given by ∣∣s∣∣=∣∣s∣∣ . For e∈E, we
E
use sometimes the notation e for the multiset s verifying s(e)=1 and s(e′)=0
for alle′∈E∖{e}and, to representfor instance the multiset with four elements
a,b,b and c, we will also use the notations Ha,b,b,cI or Ha,2⋅b,cI.
2.1 Networks of Processes using Rendez-Vous and Broadcast
We now present the model under study in this work. We consider networks of
processes where each entity executes the same protocol given by a finite state
automaton. Given a finite alphabet Σ of messages,the transitions of a protocol
are labelled with four types of actions that can be executed by the processes
of the network. For m∈Σ a process can (1) send a (non-blocking) rendez-vous
overthemessagem with!m,(2)sendabroadcastovermwith!!m,(3)receivea
rendez-vous or a broadcast over m with ?m and (4) perform an internal action
with τ (assuming τ /∈Σ). In order to refer to these different actions, we denote
by !Σ the set {!m ∣ m ∈ Σ}, by !!Σ the set {!!m ∣ m ∈ Σ} and by ?Σ the set
{?m ∣ m ∈ Σ}. Finally, we use the notation Op to represent the set of labels
Σ
!!Σ∪!Σ∪?Σ∪{τ} and Act to represent the set of actions !!Σ∪!Σ∪{τ}.
Σ
Definition 1. A Non-Blocking Broadcast protocol P (NB-Broadcast protocol)
is atuple(Q,Σ,q ,T)suchthatQisafinitesetofstates,Σ is afinitealphabet,
in
q is an initial state, and T ⊆Q×Op ×Q is the transition relation.
in Σ
In this work, we are in particular interested in studying some syntactical
restrictions on such protocols.We say that a protocolis Wait-Only when for all
q ∈ Q, either {q′ ∣ (q,α,q′) ∈ T with α ∈?Σ} = ∅, or {q′ ∣ (q,α,q′) ∈ T with α ∈
!!Σ∪!Σ ∪{τ}} = ∅. We call a state respecting the first or both conditions an
active state and a state respecting the second condition a waiting state. In the
following,wedenotebyQ thesetofactivestatesofP andQ itssetofwaiting
A W
states.
Iftheprotocoldoesnotcontainanybroadcasttransitionoftheform(q,!!m,q′),
we call it a Non-Blocking Rendez-vous protocol (NB-Rendez-vous protocol).
Example 1. An example of protocol is depicted on Figure 1. We name P the
protocol drawn without the dashed arrow between q2 and q3, and Pdashed the
complete protocol. Note that P is a Wait-Only protocol, indeed each state is
either an active state (q in,q2,q3,q5 and q6), or a waiting state, (q1 and q4).
However, Pdashed is not a Wait-Only protocol, since q2 is neither an active state
nor a waiting state as it has an outgoing transition labelled with an action !!c,
and an outgoing transition labelled with an action ?a.
3q3
?a ?a
?b
!!a
q1 q2
!!c
q
in !b
?c !!a
q4 q5 q6
Fig.1: Example of a protocol denoted Pdashed (we note P the protocol Pdashed
without the dashed arrow between q2 and q3)
We shall now present the semantics associated to protocols. Intuitively, we
consider networks of processes, each process being in a state of the protocol
and changing its state according to the transitions of the protocol with the
following assumptions. A process can perform on its own an internal action τ
andthis does not changethe state of the other processes.When a processsends
a broadcast with the action !!m, then all the processes in the network which
are in a state from which the message m can be received (i.e. with an outgoing
transition labelled by ?m) have to take such a transition. And when a process
sends a rendez-vous with the action !m, then at most one process receives it: in
fact, if there is at least one process in a state from which the message m can
be received, then exactly one of these processes has to change its state, along
with the receiver (while the other processes do not move), but if no process can
receive the message m, only the sender performs the action !m. This is why we
call this communication mechanism a non-blocking rendez-vous.
Wemovenowtotheformaldefinitionofthesemantics.LetP =(Q,Σ,q ,T)
in
be a protocol.
A configuration C over P is a non-empty multiset over Q, it is initial when-
ever C(q)=0 for all q ∈Q∖{q }. We note C the set of all configurations over
in
P, and I the set of all initial configurations over P.
Forq∈Q,wedenotebyR(q)the set{m∈Σ ∣there exists q′ ∈Q,(q,?m,q′)∈
T} of messages that can be received when in the state q. Given a transition
t=(q,α,q′)∈T,wedefinetherelationÐ→t ⊆C×C asfollows:fortwoconfigurations
C,C′ we have C Ð→t C′ iff one of the following conditions holds:
(a) α=τ, and C(q)>0 and C′=C−HqI+Hq′I;
(b) α=!!m, and C =Hq1,q2,...,q n,qI for some n∈N, and C′=Hq 1′,q 2′,...,q n′,q′I
where for all 1≤i≤n, either m∉R(q ) and q′ =q , or (q ,?m,q′)∈T;
i i i i i
(c) α=!m, and C(q)>0, and (C−HqI)(p)=0 for all p∈Q such that m∈R(p),
and C′=C−HqI+Hq′I;
(d) α =!m and C(q) > 0 and there exists p ∈ Q such that (C−HqI)(p)> 0 and
(p,?m,p′)∈T for some p′∈Q, and C′=C−Hp,qI+Hq′,p′I.
Observe that when C Ð→t C′, we necessarily have ∣∣C∣∣=∣∣C′∣∣.
4The case (a) corresponds to the internal action of a single process, the case
(b) to the emission of a broadcast hence all the processes that can receive the
messagehaveto receive it.The case(c) correspondsto the casewhere a process
sendsarendez-vousandthereisnoprocesstoanswertoit,henceonlythesender
changes its state. The case (d) corresponds to a classical rendez-vous where a
process sends a rendez-vous and another process receives it. Note that for both
the broadcastand the rendez-vous,the absence of a receiver does not preventa
sender from its action. We call non-blocking our semantics because of the case
(c), which contrasts with the broadcast model of [EFM99] for instance, where
this case is not possible.
We write C →C′ whenever there exists t∈T such that C Ð→t C′, and denote
by →∗ [resp. →+] the reflexive and transitive [resp. transitive] closure of →. An
execution ρ is then a finite sequence of the form C0
Ðt→1
C1
Ðt→2
...
Ðt→n
C n, it is
said to be initialized when C0 is an initial configuration in I.
Example 2. We considerthe protocolP ofFigure 1.We havethen the following
executionstarting at the initial configurationHq ,q ,q I with three processes:
in in in
Hq in,q in,q
inIÐ( ÐqiÐn, Ð!!a Ð,q Ð1→)
Hq1,q in,q
inIÐ(q ÐinÐ,! Ðb, Ðq4→)
Hq2,q4,q
inIÐ(q ÐinÐ,! Ðb, Ðq4→)
Hq2,q4,q4I
Ð(q Ð2Ð,!! Ðc, Ðq1→) Hq1,q5,q5IÐ(q Ð5, Ð!! Ða, Ðq6→)
Hq3,q6,q5I.
It corresponds to the following sequence of events: one of the agents broadcasts
message a (not received by anyone), then another agent sends message b which
leads to a rendez-vous with the first agent on q1, the last agent sends message
b which is not received by anyone (the sending is possible thanks to the non-
blockingsemantics),theagentinstateq2 broadcastsmessagecwhichisreceived
by the two other agents, and finally, one of the agents in q5 broadcasts letter a
which is received by the process on q1.
Remark 1. Observe that internal transitions labelled by τ can be replaced by
broadcasttransitionsoftheform!!τ.Sincenotransitionislabelledby?τ,whenτ
isbroadcasted,noprocessisreadytoreceiveitandthesemanticsisequivalentto
the one of aninternaltransition.Observe alsothat since τ ∈Act , transforming
Σ
internal transitions into broadcasts keeps a protocol Wait-Only.
Following this remark, we will omit internal transitions in the rest of this work.
2.2 Verification Problems
We presentnowthe verificationproblems we are interestedin.Both these prob-
lems consistin ensuringa safetyproperty:wewantto checkthat,no matter the
numberofprocessesinthenetwork,aconfigurationexhibitingaspecificpattern
can never be reached. If the answer to the problem is positive, it means in our
context that the protocol is not safe.
The state coverability problem StateCover is stated as follows:
5StateCover
Input:An NB-BroadcastProtocol P and a state q ∈Q;
f
Question:Do there exist C ∈I and C′∈C such that C →∗C′, and C′(q )>0 ?
f
When the answer is positive, we say that q is coverable by P. The sec-
f
ond problem, called the configuration coverability problem ConfCover, is a
generalisationof the first one where we look for a multi-set to be covered.
ConfCover
Input:An NB-BroadcastProtocol P and a configuration C ∈C;
f
Question:Do there exist C ∈I and C′∈C such that C →∗C′, and C ⪯C′ ?
f
Remark 2. Note that if P is a Wait-Only protocol and its initial state q is a
in
waiting state, then no state besides q is coverable and the only coverable con-
in
figurationsarethe initialones.Hence,when talkingabout Wait-Onlyprotocols,
we assume in the rest of this work that the initial state q is always an active
in
state.
Example 3. In the protocol P of Figure 1, configuration Hq3,q6I is coverable as
Hq in,q in,q inI→∗ Hq3,q6,q5I (see Example 2) and Hq3,q6I⪯Hq3,q6,q5I.
Results. WesummarizeinTable 1theresultsonNB-Broadcastprotocols,where
our results appear in red. Note that for what concerns the lower bounds for
NB-Broadcast protocols, they have been proved in [SS13][Fact16, Remark 17]
for Broadcast protocols with a classical “blocking” rendez-vous semantics, i.e.
whereaprocessrequestingarendez-vouscannottakethetransitionifnoprocess
answers the rendez-vous. However, it is possible to retrieve the lower bound for
NB-Broadcast protocols without rendez-vous by using the fact that “blocking”
rendez-vous can be simulated by broadcast as shown in [EFM99,ARZ15].
Type of protocols StateCover ConfCover
NB-Broadcast Decidable [EK03] and Ackermann-hard[SS13,ARZ15,EFM99]
NB-Rendez-vous ExpSpace-complete [GSS23]
Wait-OnlyNB-Rendez-vous in P[GSS23], P-hard
Wait-OnlyNB-Broadcast P-complete PSpace-complete
Table 1: Coverability in NB-Broadcast protocols
In the restof this work,we will focus onWait-Only NB-Broadcastprotocols
which we name Wait-Only protocols for ease of notation.
3 Preliminaries properties
Wait-Only protocols enjoy a nice property on coverable states. The property
makesadistinctionbetweenactivestatesandwaitingstates.First,weshowthat
6when an active state is coverable, then it is coverable by a number of processes
as big as one wants, whereas this is not true for a waiting state. Indeed, it is
possible that a waiting state can be covered by exactly one process at a time,
and no more. However, we show that if two active states, or if an active state
and a waiting state are coverable, then there is an execution that reaches a
configuration where they are both covered.
This property relies on the fact that once the active state has been covered
in an execution, it will not be emptied while performing the sequence of actions
allowing to cover the second (waiting state), since no reception of message can
happen in sucha state. As we will see,this phenomenon canbe generalisedto a
subset of active states.
Example 4. Going back to the protocol P of Figure 1, consider the active state
q2.ItiscoverableasshownbytheexecutionHq in,q
inIÐ( ÐqiÐn, Ð!!a Ð,q Ð1→)
Hq1,q
inIÐ(q ÐinÐ,! Ðb, Ðq4→)
Hq2,q4I. From this execution, for any integer n∈N, one can build an execution
leading to a configuration covering Hn⋅q2I. For instance, for n=2, we build the
following execution:
Hq in,q in,q in,q
inIÐ( ÐqiÐn, Ð!!a Ð,q Ð1→)
Hq1,q in,q in,q
inIÐ(q ÐinÐ,! Ðb, Ðq4→)
Hq2,q4,q in,q inI
Ð( ÐqiÐn, Ð!!a Ð,q Ð1→)
Hq2,q4,q1,q
inIÐ(q ÐinÐ,! Ðb, Ðq4→)
Hq2,q4,q2,q4I.
Furthermoreeachcoverablewaitingstateiscoverablebyaconfigurationthatalso
contains q2. For instance, Hq2,q4I is coverable as shown by the above execution.
NotethatwhenconsideringPdashed,whichisnotWait-Only,suchanexecution
isnotpossibleasthe secondbroadcastofa shouldbereceivedbytheprocesson
q2.Infact,q2 iscoverablebyonlyoneprocessandnomore.Thisisbecauseq1 is
coverable by at most one process at a time; every new process arriving in state
q1 will do so by broadcasting a, message that will be received by the process
alreadyinq1.Thenanyattempttosendtwoprocessesinq2 requiresabroadcast
of a, hence the receptionof a by the process alreadyin q2. For the same reason,
inPdashed,Hq1,q2I is notcoverablewhereasq1 isa coverablewaitingstateandq2
a coverable active state.
Before stating the main lemma of this section (Lemma 1), we need an ad-
ditional definition. For each coverable state q ∈ Q, let min be the minimal
q
number of processes needed to cover q. More formally, min = min{n ∣ n ∈
q
N, there exists C ∈ C s. t. Hn.q I →∗ C and C(q) > 0}. Note that min is de-
in q
fined only when q is coverable.
Lemma 1. Let P = (Q,Σ,q in,T) be a Wait-Only protocol, A = {q1,...,q n} ⊆
Q a subset of coverable active states and p ∈ Q a coverable waiting state.
A W
Then, for all N ∈N, there exists an execution C0 →∗ C
m
such that C0 ∈I, and
{N ⋅q1,...,N ⋅q n,p}⪯C m. Moreover, ∣∣C0∣∣=N.∑n i=1min qi+min p.
The proof of this lemma relies on the two following properties on executions
of Wait-Only protocols:
7Lemma 2. GivenaninitializedexecutionC0Ðt→1 C1Ðt→2 ......Ðt →k C
k
andanother
initial configuration C 0′, we can build an execution Ĉ 0 Ðt→1 Ĉ 1 Ðt→2 ...... Ðt →k Ĉ k
with Ĉ 0 = C0+C 0′. For all 0 ≤ i ≤ k, Ĉ i(q) = C i(q) for all q ∈ Q∖{q in}, and
Ĉ(q )=C (q )+C′(q ).
i in i in 0 in
This property comes from the fact that q is an active state. Hence, if we
in
startfroma biggerconfiguration,wecantake exactlythe sametransitionsas in
the initial execution, the additional processes will stay in the initial state.
Lemma 3. Given aninitialized executionC0Ðt→1 C1Ðt→2 ......Ðt →k C k,given some
M ≥ 1, for all configurations (not necessarily initial) C̃ 0 such that C̃ 0(q in) ≥
M.C0(q in), we have the execution C̃ 0 Ðt→1 ... Ðt →k C̃ k in which, for all 0 ≤ i ≤ k:
C̃ i(q)≥ C̃ 0(q)+C i(q) for all q ∈ Q A∖{q in}, C̃ i(q) ≥C i(q) for all q ∈ Q
W
and
C̃ i(q in)≥(M −1).C0(q in)+C i(q in).
This last property states that, if one mimicks an initialized execution from
another(noninitial)configuration,theprocessesalreadypresentinactive states
(different from the initial state) will not move during the execution.
Proof of Lemma 1. LetN ∈N.Using these two properties,we cannow prove
the lemma. We start by proving that there exists an execution C0 →∗ C
m
such
thatforallq∈A,C m(q)≥N and∣∣C0∣∣=N.∑n i=1min qi.Weproveitbyinduction
onthesizeofA.IfA=∅,thepropertyistriviallytrue.Letn∈N,andassumethe
propertytoholdforallsubsetsA⊆Q
A
ofsizen.TakeA={q1,q2,...,q n+1}⊆Q
A
of size n+1 such that all states q ∈ A are coverable and let A′ = A∖{q1}. Let
C0 Ðt→1 C1 Ðt→2 ...... Ðt →k C
k
be an execution covering q1 with ∣∣C0∣∣ = min q1. Let
C′ Ðt →′ 1 C′ Ðt →′ 2 ... Ðt′ m→ C′ be an execution such that for all q′ ∈ A′, C′ (q′) ≥
0 1 m m
N and ∣∣C′∣∣ = N.∑n+1 min (it exists by induction hypothesis). We let CN =
0 i=2 qi 0
H(N.min )⋅q I and C′′ = C′ +CN. Thanks to Lemma 2, we can build an
q1 in 0 0 0
execution C′′ Ðt →′ 1 C′′ Ðt →′ 2 ... Ðt′ m→ C′′, with C′′(q) = C′ (q) for all q ∈ Q∖{q }
0 1 m m m in
and C′′(q ) = C′ (q )+CN(q ) = C′ (q )+N.min . So, for all q′ ∈ A′,
m in m in 0 in m in q1
C′′(q′)=C′ (q′)≥N and ∣∣C′′∣∣=∣∣C′∣∣+∣∣CN∣∣=N.∑n+1 min +N.min .
m m 0 0 0 i=2 qi q1
Nowthatwehaveshownhowtobuildanexecutionthatleadstoaconfigura-
tionwith morethanN processesonallstates in A′ andenoughprocessesin the
initialstate,weshowthatmimickingN timestheexecutionallowingtocoverq1
allows to obtain the desired result. Let C0,1 =C m′′. We know that for all q′ ∈A′,
C0,1(q′)≥ N, and C0,1(q in)≥N.min q1. Since ∣∣C0∣∣ =min q1, using Lemma 3, we
can build the execution C0,1 Ðt→1 ... Ðt →k C k,1 with C k,1(q in) ≥ (N −1).min q1,
C k,1(q′)≥C0,k(q′)+C k(q′)≥N forallq′∈A′ andC k,1(q1)≥C0,k(q1)+C k(q1)≥
1. Iterating this construction and applying each time Lemma 3, we obtain that
there is an execution C0,1 Ðt→1 ...Ðt →k C k,1 Ðt→1 ...Ðt →k C k,2...Ðt→1 ...Ðt →k C k,N−1 Ðt→1
... Ðt →k C with C (q ) ≥ (N −i).min , C (q′) ≥ N for all q′ ∈ A′ and
k,N k,i in q1 k,i
C k,i(q1) ≥ C k,i−1(q1)+1 ≥ i. Observe that to obtain that C k,i(q1) ≥ i from
Lemma 3, we use the fact that q1∈Q A. Hence, C k,N(q1)≥N and C k,N(q′)≥N
8for all q′ ∈A′ and we have build an execution where C (q)≥ N for all q ∈ A
k,N
and ∣∣C ∣∣=∣∣C′′∣∣=N.∑∣A∣ min , as expected.
k,N 0 i=1 qi
At last, take a subset A = {q1,...,q n} ⊆ Q
A
of coverable active states. Let
C0 →∗ C
m
be an execution such that C m(q) ≥ N for all q ∈ A and ∣∣C0∣∣ =
N.∑n min . Let p∈Q a coverable state and C′ →∗ C′ such that C′(p)≥1
i=1 qi W 0 k k
and ∣∣C 0′∣∣ = min p. By Lemma 2, we let Ĉ 0 = C0+C 0′ and we have an execution
Ĉ 0 →∗ Ĉ m with Ĉ m(q)=C m(q) for all q ∈Q∖{q in}, and Ĉ m(q in)=C m(q in)+
C′(q ). Hence, Ĉ (q)≥N for all q ∈A and Ĉ (q )≥C′(q ), and note that
0 in m m in 0 in
∣∣Ĉ m∣∣ = ∣∣Ĉ 0∣∣ = ∣∣C0∣∣+∣∣C 0′∣∣ = N.∑n i=1min qi +min p. Then, with C̃ 0 = Ĉ m, by
Lemma 3,wehaveanexecutionC̃ 0→∗C̃
k
withC̃ k(q)≥C̃ 0(q)+C k(q)≥C̃ 0(q)≥
N for all q∈A, and C̃ k(p)≥C k(p)≥1, and ∣∣C̃ 0∣∣=∣∣Ĉ 0∣∣=N.∑n i=1min
qi
+min p.
◻
4 StateCover for Wait-Only protocols is P-complete
4.1 Upper bound
We present here a polynomial time algorithm to solve the state coverability
problemwhenthe consideredprotocolisWait-Only.Ouralgorithmcomputes in
a greedy manner the set of coverable states using Lemma 1.
Given a Wait-Only protocol P =(Q,Σ,q ,T), we compute iteratively a set
in
of states S ⊆ Q containing all the states that are coverable by P, by relying
on a family (S i) i∈N of subsets of Q formally defined as follows (we recall that
Act =!!Σ∪!Σ):
Σ
S0={q in}
S i+1=S
i
∪ {q∣there exists q′∈S i,(q′,α,q) ∈T,α∈Act Σ}
∪{q 2′ ∣there exist q1,q2∈S i,q 1′ ∈Q,a∈Σ s. t. (q1,!a,q 1′)∈T and (q2,?a,q 2′)∈T}
∪{q 2′ ∣there exist q1,q2∈S i,q 1′ ∈Q,a∈Σ s. t. (q1,!!a,q 1′)∈T and (q2,?a,q 2′)∈T}
Intuitivelyateachiteration,weaddsomecontrolstatestoS i+1 eitherifthey
can be reached from a transition labelled with an action (in Act ) starting at
Σ
a state in S or if they can be reached by two transitions corresponding to a
i
communication by broadcast or by rendez-vous starting from states in S . We
i
thendefineS =⋃ n∈NS n.Observethat(S i) i∈N isanincreasingsequencesuchthat
∣S i∣≤∣Q∣foralli∈N.ThenwereachafixpointM ≤∣Q∣suchthatS
M
=S M+1=S.
Hence S can be computed in polynomial time.
The two following lemmas show correctnessof this algorithm.We first prove
that any state q∈S is indeed coverable by P. Moreover,we show that min the
q
minimal number of processes necessary to cover q∈Q is smaller than 2∣Q∣.
Lemma 4. If q ∈ S, then there exists C ∈ I and C′ ∈ C such that C →∗ C′,
C′(q)>0 and ∣∣C∣∣≤2∣Q∣.
9Proof. Let M ∈ N be the first natural such that S
M
= S M+1. We have then
S =S and M ≤∣Q∣. We proveby induction that for all 0≤i≤M, for allq∈S ,
M i
there exists C ∈I and C′ ∈C such that C →∗ C′, C′(q)>0 and ∣∣C∣∣≤2i.
As S0 = {q in}, the property trivially holds for i = 0, since Hq inI ∈ I and
Hq I(q )>0.
in in
Assumenowthe propertytobe truefori<M andletq∈S i+1.Ifq∈S i,then
by induction hypothesis, we have that there exists C ∈ I and C′ ∈ C such that
C →∗ C′, C′(q)>0 and ∣∣C∣∣≤2i <2i+1 . We suppose that q∉S and proceed by
i
a case analysis on the way q has been added to S i+1.
1. thereexistsq′∈S andt=(q′,α,q)∈T withα∈Act .Byinductionhypothe-
i Σ
sis,thereexistsanexecutionC →∗C′ suchthatC′(q′)>0and∣∣C∣∣≤2i.But
we have then C′ Ð→t C′′ with C′′(q)>0, and consequently as well C →∗ C′′.
This is true because of the “non-blocking” nature of both broadcast and
rendez-vous message in this model. Hence there is no need to check for a
process to receive the message to ensure the execution C →∗C′′.
2. thereexistq1,q2∈S iandq 1′ ∈Qandthereexistsa∈Σsuchthat(q1,!a,q 1′),(q2,
?a,q)∈T.By inductionhypothesis,wehavethatthere exists C1,C2 ∈I and
C 1′,C 2′ ∈C such that C1→∗C 1′ and C2→∗C 2′ and C 1′(q1)>0 and C 2′(q2)>0
and∣∣C1∣∣≤2i and∣∣C2∣∣≤2i.Note furthermorethatbydefinitionq1 is inQ
A
and as (q2,?a,q)∈T, q2 do not belong to Q A. Hence q1≠q2. By Lemma 1,
weknowthatthereexistC ∈I andC′∈C suchthatC →∗ C′ andC′(q1)>0
and C′(q2) > 0. Furthermore, recall that min
qi
for i ∈ {1,2} is the minimal
number of processes needed to cover q , by Lemma 1, ∣∣C∣∣ ≤ min +min .
i q1 q2
By induction hypothesis, min +min ≤2i+2i, hence ∣∣C∣∣≤2i+1 .
q1 q2
WethenhaveC′Ð(q Ð1Ð,!a Ð,q Ð1′ →)
C′′withC′′=C′−Hq1,q2I+Hq 1′,qI.HenceC →∗C′′
with C′′(q)>0.
3. there exist q1,q2 ∈ S
i
and q 1′ ∈ Q and there is some a ∈ Σ such that
(q1,!!a,q 1′),(q2,?a,q) ∈ T. As above, we obtain the existence of an exe-
cution C →∗ C′ with C′(q1) > 0 and C′(q2) > 0, and ∣∣C∣∣ ≤ 2i+1 . Then
C′ = Hq1,q2,...,q kI and C′
Ð(q Ð1, Ð!! Ða, Ðq1′ →)
C′′ with C′′ = Hq 1′,q,...,q k′I with, for
all 3≤j ≤k, either a∉R(q ) and q =q′ or (q ,?a,q′)∈T. In any case, we
j j j j j
have C →∗ C′′ with C′′(q)>0.
So, for any q ∈ S, q ∈ S and we have an execution C →∗ C′ with C ∈ I such
M
that C′(q)>0 and ∣∣C∣∣≤2M ≤2∣Q∣. ⊓⊔
Wenowprovethecompletenessofouralgorithmbyshowingthateverystate
coverable by P belongs to S.
Lemma 5. If there exists C ∈ I and C′ ∈ C such that C →∗ C′ and C′(q)> 0,
then q∈S.
Proof. WeconsidertheinitializedexecutionC0
Ðt→1 C1Ðt→2 ...Ðt→n
C
n
withC =C0
and C = C′. We will prove by induction on 0 ≤ i ≤ n that for all q such that
n
C (q)>0, we have q∈S .
i i
10For i=0, we have C0=H∣∣C∣∣⋅q inI, and S0={q0}. Hence the property holds.
Assumethepropertytobetruefori<n,andletq∈QsuchthatC i+1(q)>0.
If C i(q)>0,then by induction hypothesis we haveq∈S
i
and since S i⊆S i+1,we
deducethatq∈S i+1.AssumenowthatC i(q)=0.Weproceedbyacaseanalysis.
1. t i+1 =(q′,!a,q) or t i+1 =(q′,!!a,q) for some a∈Σ and q′ ∈Q. Since C i ÐtiÐ+→1
C i+1, we have necessarily C i(q′) > 0. By induction hypothesis, q′ ∈ S i, and
by construction of S i+1, we deduce that q′∈S i+1.
2. t i+1 = (q1,!a,q 1′) or t i+1 = (q1,!!a,q 1′) with q 1′ ≠ q. Since C i(q) = 0 and
C i+1(q) > 0, there exists a transition of the form (q2,?a,q) with q1 ≠ q2
(because q1∈Q
A
and (q2,?a,q)∈T hence q2∉Q W). Consequently,we know
thatwehaveC i(q1)>0andC i(q2)>0.Byinductionhypothesisq1,q2belong
to S i and by construction of S i+1 we deduce that q∈S i+1.
⊓⊔
The two previous lemmas show the soundness and completeness of our algo-
rithm to solve StateCover based on the computation of the set S. Since this
setofstatescanbecomputedinpolynomialtime,weobtainthefollowingresult.
Theorem 1. StateCover is in P for Wait-Only protocols.
Furthermore, completeness of the algorithm along with the bound on the
number of processes established in Lemma 4 gives the following result.
Corollary 1. Given a Wait-Only protocol P =(Q,Σ,q ,T), for all q ∈Q cov-
in
erable by P, then min the minimal number of processes necessary to cover q is
q
at most 2∣Q∣.
4.2 Lower Bound
We show that StateCover for Wait-Only protocols is P-hard. For this, we
provideareductionfromtheCircuitValueProblem(CVP)whichisknowntobe
P-complete [Lad75]. CVP is defined as follows: given an acyclic Boolean circuit
withninputvariables,oneoutputvariable,mbooleangatesoftypeand,or,not,
and a truth assignment for the input variables, is the value of the output equal
to a given boolean value? Given an instance of the CVP, we build a protocol
in which the processesbroadcastvariables (input ones or associatedwith gates)
along with their boolean values. These broadcasts will be received by other
processes that will use them to compute boolean value of their corresponding
gate, and broadcast the obtained value. Hence, different values are propagated
through the protocol representing the circuit, until the state representing the
output variable value we look for is covered.
TakeforexampleaCVPinstanceC withtwovariablesv1,v2,andtwogates:
onenot gateonvariablev1 denotedg1(v1,¬,o1)(whereo1 standsfortheoutput
variable of g1), and one or gate on variable v2 and o1 denoted g2(o1,v2,∨,o2)
(where o2 stands for the output variable of gate g2). Assume the input boolean
value for v1 [resp. v2] is ⊺ [resp. –]. The protocol associated to C is displayed
11on Figure 2. Assume the output value of C is o2, we will show that q ⊺2 [resp.
q –2 ] is coverable if and only if o2 evaluates to ⊺ [resp. –]. Note that with the
truth assignment depicted earlier, o2 evaluates to –, and indeed one can build
an execution covering
q2
with three processes:
–
H3.q I→H2.q ,q2 I→Hq ,q1 ,q2 IÐ( ÐqinÐ, Ð!!( Ðv1Ð,⊺ Ð) Ð,q Ðin→) Hq ,q1 ,q2 I
in in 0 in 0 0 in – 0
Ð(q Ð–1 Ð,!! Ð(o Ð1, Ð– Ð),q Ð–1 →)
Hq
,q1 ,q2 IÐ( ÐqinÐ, Ð!!( Ðv2Ð,– Ð) Ð,q Ðin→)
Hq
,q1 ,q2
I
in – 1 in – –
?(v1,⊺)
!!τ
q01
?(v1,–)
q⊺1 !!(o1,⊺) q–1 !!(o1,–)
q
in !!τ ?(o1,⊺) q⊺2 !!(o2,⊺)
!! !! (( vv 21 ,, –⊺ )) q02 ?(o1? ,( –v )2,⊺) q12 ?(v2,–) q–2 !!(o2,–)
Fig.2: Protocol for a CVP instance with two variables v1,v2, two gates
g1(¬,v1,o1) and g2(∨,o1,v2,o2), and input ⊺ for v1 and – for v2 and output
variableo2.Depending onthe truthvalue ofo2 totest,thestateweasktocover
can be
q2
or
q2
.
– ⊺
Formal proofs of the reduction are given in Appendix B. Together with
Theorem 1, we get the following theorem.
Theorem 2. StateCover for Wait-Only protocols is P-complete.
This reduction can be adapted to Wait-Only NB-Rendez-vous protocols, which
leads to the following theorem, proving that the upper bound presented in
[GSS23] is tight.
Theorem 3. StateCover for Wait-OnlyNB-Rendez-vous protocols is P-hard.
5 ConfCover for Wait-Only protocols is
PSpace-complete
Wepresenthereanalgorithmtosolvetheconfigurationcoverabilityproblemfor
Wait-Only protocols in polynomial space.
5.1 Main ideas
For the remaining of the section, we fix a Wait-Only protocol P =(Q,Σ,q ,T)
in
and a configuration C ∈ C to cover, and we let K = ∣∣C ∣∣. The intuition is
f f
12the following: we (only) keep track of the K processes that will cover C . Of
f
course, they might need other processes to reach the desired configuration, if
theyneedtoreceivemessages.Thatiswhywealsomaintainthesetofreachable
states along the execution. An abstract configuration will then be a multiset of
K states(concretepartoftheconfiguration)andasetofallthereachablestates
(abstractpartofthe configuration).Lemma 1ensuresthat itis enoughto know
which active states are reachable to ensure that both the concrete part and the
activestatesoftheabstractpartarecoverableatthesametime.However,there
is a case where this abstraction would not be enough: assume that one of the
K processes has to send a message, and this message should not be received
by the other K −1 processes. This can happen when the message is received
by a process in the part of the configuration that we have abstracted away. In
that case, even if the (waiting) state is present in the set of reachable states,
Lemma 1 does not guarantee that the entire configuration is reachable, so the
transition to an abstract configuration where none of the K −1 processes has
received the message might be erroneous. This is why in that case we need to
precisely keep track of the process that will receive the message, even if in the
end it will not participate in the covering of C . This leads to the definition of
f
the ⇒ transition below.
switch
This proof is structured as follows: we present the formal definitions of the
abstract configurations and semantics in Section 5.2. In Section 5.3, we present
the completeness proof, Section 5.4 is devoted to prove the soundness of the
construction.Inthelatter,wealsogivesomeingredientstoproveanupperbound
onthe numberofprocessesneededtocovertheconfiguration.InSection 5.5one
canfindthemaintheoremofthissection:itstatesthattheConfCoverproblem
is in PSpace and if the configuration is indeed coverable, it presents an upper
bound on the number of processes needed to cover it. In Section 5.6, we prove
that this lower bound is tight as the problem is PSpace-hard.
5.2 Reasoning with Abstract Configurations
We present the abstract configurations we rely on. Let us fix K = ∣∣C ∣∣. An
f
abstract configuration γ is a pair (M,S) where M is a configuration in C such
that ∣∣M∣∣ = K and S ⊆ Q is a subset of control states such that {q ∈ Q ∣
M(q)>0}⊆S. We call M the M-part of γ and S its S-part. We denote by Γ
the set of abstract configurations and by γ the initial abstract configuration
in
γ =(HK⋅q I,{q }). An abstract configuration γ =(M,S) represents a set of
in in in
configurations JγK ={C ∈ C ∣M ⪯C and C(q)>0 implies q ∈S}. Hence in JγK,
we have all the configurations C that are bigger than M as long as the states
holding processes in C are stored in S (observe that this implies that all the
states in M appear in S).
Wenowdefineanabstracttransitionrelationforabstractconfigurations.For
this matter, we define three transition relations ⇒ ,⇒ and ⇒ and let
step ext switch
⇒ be defined by ⇒ ∪ ⇒ ∪ ⇒ . Let γ = (M,S) and γ′ = (M′,S′) be
step ext switch
two abstract configurations and t=(q,α,q′) be a transition in T with α=!a or
13α=!!a. Forκ∈{step,ext,switch},we haveγ ⇒t γ′ iff allthe following conditions
κ
hold:
– S ⊆S′, and,
– for all p∈S′∖S, either p=q′ or there exist p′∈S and (p′,?a,p) in T, and,
– one of the following cases is true:
● κ =step and M Ð→t M′. This relation describes a message emitted from
the M-part of the configuration;
● κ=ext and q∈S and M +HqIÐ→t M′+Hq′I;
● κ=extandthereexists(p,?a,p′)inT suchthatq,p∈S andM+Hq,pIÐ→t
M +Hq′,p′I (note that in that case M = M′). The relation ext hence
describes a message emitted from the S-part of the configuration;
● κ = switch and q ∈ S and α =!a and there exists t′ = (p,?a,p′)∈ T such
that HpI ⪯ M and Hq′I ⪯ M′ and M −HpI = M′−Hq′I and M +HqI Ð→t
M′+Hp′I.This relationdescribesasending fromastate inthe S-partof
the abstract configuration leading to a rendez-vous with one process in
the M-part,anda "switch"ofprocesses:we removethe receiverprocess
of the M-part and replace it by the sender.
Note that in any case, q, the state from which the message is sent, belongs
t t
to S. We then write γ Ô⇒γ′ whenever γ ⇒ γ′ for κ∈{step,ext,switch} and we
κ
do not always specify the used transition t (when omitted, it means that there
exists a transitions allowing the transition). We denote by ⇒∗ the reflexive and
transitive closure of ⇒.
!b
?c
q1 q2 q3
!!a
?b
q
in !!τ
?a !!c ?b
q4 q5 q6 q7
Fig.3: A Wait-Only protocol P′.
Example 5. We consider the Wait-Only protocol P′ depicted on Figure 3 with
setofstatesQ′.WewanttocoverC
f
=Hq3,q3,q6I(henceK =3).Inthisexample,
the abstract configuration γ = (Hq2,q2,q4I,{q in,q1,q2,q4,q5,q6}) represents all
the configurationsof P′ with atleast two processeson q2 andone on q4, andno
process on q3 nor q7.
Considering the following abstract execution, we can cover C :
f
14γ
in
Ô(q ÔinÔ,!! Ôτ,q Ô4⇒)
(Hq4,q in,q inI,{q
in,q4})Ô(q ÔinÔ,!! Ôτ,q Ô4⇒)
(Hq4,q4,q inI,{q in,q4})
step step
Ô(q ÔinÔ,!! Ôa,q Ô1⇒)
(Hq5,q5,q1I,{q
in,q1,q4,q5})Ô(q Ô5,! Ô!c, Ôq6⇒)
(Hq5,q5,q2I,Q′∖{q3,q7})
step ext
Ô(q Ô2, Ô!b, Ôq3⇒) (Hq5,q5,q3I,Q′)Ô(q Ô5,! Ô!c, Ôq6⇒)
(Hq6,q5,q3I,Q′)
step step
Ô(q Ô2, Ô!b, Ôq3⇒) (Hq3,q5,q3I,Q′)Ô(q Ô5,! Ô!c, Ôq6⇒)
(Hq3,q6,q3I,Q′)
switch step
It corresponds for instance to the following concrete execution:
Hq in,q in,q inI+Hq in,q inI→+Hq4,q4,q inI+Hq4,q inIÐ( ÐqiÐn, Ð!!a Ð,q Ð1→) Hq5,q5,q1I+Hq5,q inI
Ð( ÐqiÐn, Ð!!a Ð,q Ð1→) Hq5,q5,q1I+Hq5,q1IÐ(q Ð5Ð,!! Ðc, Ðq6→) Hq5,q5,q2I+Hq6,q1I
Ð( Ðq2Ð,!b Ð,q Ð3→) Hq5,q5,q3I+Hq7,q1IÐ(q Ð5Ð,!! Ðc, Ðq6→)
Hq6,q5,q3I+Hq7,q2I
Ð( Ðq2Ð,!b Ð,q Ð3→) Hq3,q5,q3I+Hq7,q7IÐ(q Ð5Ð,!! Ðc, Ðq6→) Hq3,q6,q3I+Hq7,q7I
The M-partof our abstract configurationHq6,q5,q3I reachedjust before the
⇒ transition does not correspond to the set of processes that finally cover
switch
C , at this point of time, the processes that will finally cover C are in states
f f
q2, q5, and q3. But here we ensure that the process on q6 will actually receive
the b sent by the process on q2, leaving the process on q3 in its state. Once this
hasbeenensured,processonq6 isnotusefulanymore,andinsteadwefollowthe
process that was on q2 before the sending, hence the ⇒
switch
transition.
The algorithm used to solve ConfCover, is then to seek in the directed
graph (Γ,⇒) if a vertex of the form (C ,S) is reachable from γ .
f in
Beforeprovingthatthisalgorithmiscorrect,weestablishthefollowingprop-
erty.
Lemma 6. Let (M,S) and (M′,S′) be two abstract configurations and S̃⊆ Q
such that S ⊆S̃. We have:
1. J(M,S)K⊆J(M,S̃)K.
2. If (M,S)⇒(M′,S′) then there exists S′′⊆Q such that (M,S̃)⇒(M′,S′′)
and S′⊆S′′.
Proof. The first point is a direct consequence of the definition of JK. For the
second point, it is enoughto take S′′=S′∪S̃and apply the definition of ⇒. ⊓⊔
5.3 Completeness of the algorithm
InthissubsectionweshowthatifC canbecoveredthenthereexistsanabstract
f
configuration γ = (C ,S) such that γ ⇒∗ γ. We use C to represent the set
f in ≥K
15{C ∈ C ∣ ∣∣C∣∣ ≥ K} of configurations with at least K processes and C the set
=K
{C ∈C ∣∣∣C∣∣=K} of configurations with exactly K processes. This first lemma
showsthe completenessforasinglestepofourabstracttransitionrelation(note
that we focus on the M-part, as it is the one witnessing C in the end).
f
Lemma 7. Let C,C′ ∈C and t∈T such that C Ð→t C′. Then for all M′∈C
≥K =K
suchthat M′⪯C′,thereexistsM ∈C and S′⊆Q suchthat (M,S)⇒(M′,S′)
=K
with S ={q∈Q∣C(q)>0}, C ∈J(M,S)K and C′∈J(M′,S′)K.
Proof. Let M′ ∈ C such that M′ ⪯ C′. We assume that t = (q,α,q′) with
=K
α ∈ {!a,!!a}. We let S = {p ∈ Q ∣ C(p) > 0} and S′ = S ∪{p ∈ Q ∣ C′(p) > 0}.
By definition of S and S′, for all p ∈ S′∖S, either p = q′ or there exists p′ ∈ S
and (p′,?a,p) in T. In fact, let p ∈ S′∖S such that p ≠ q′. Since C Ð→t C′, we
have necessarily that there exist p′ ∈Q such that C(p′)>0 (hence p′ ∈S), and
(p′,?a,p) in T. We now reason by a case analysis to determine M ∈ C such
=K
that (M,S) ⇒ (M′,S′) and C ∈ J(M,S)K. The different cases are: (i) α =!!a,
(ii) α=!a andthe messageis not received, (iii) α=!a and the messageis received
by a process. Because of space constraints, we present here only case (iii) as
it exhibits the most different abstract behaviours. The two other cases can be
found on Appendix C.1.
(iii) if α =!a and the message is received by a process (i.e. it is a rendez-vous),
denoteby(p,?a,p′)thereceptiontransitionissuedbetweenC andC′.Using
the definition of →, we get C′ = C −Hq,pI+Hq′,p′I. We consider the four
following disjoint cases:
– M′(q′) = 0 and M′(p′) = 0. Since Hq′,p′I ⪯ C′ and M′ ⪯ C′, we get
that C′ =M′+Hq′,p′I+M2 for some multiset M2. We deduce that C =
M′+Hq,pI+M2.ThisallowsustodeducethatM′⪯C andconsequently
C ∈J(M′,S)K. Moreover, M′+Hp,qIÐ→t M′+Hq′,p′I and q,p∈S. Hence
t
(M′,S)⇒ (M′,S′).
ext
– M′(q′) = 0 and M′(p′) > 0. In that case C′ = M′+Hq′I+M2 for some
multiset M2. Let M = M′−Hp′I+HpI. We have then C = C′+Hq,pI−
Hq′,p′I=M′+Hq′I+M2+Hq,pI−Hq′,p′I=M′+M2−Hp′I+HpI+HqI=M+HqI+
M2.ThisallowsustodeducethatM ⪯C andconsequentlyC ∈J(M,S)K.
Furthermoreq∈S andM+HqIÐ→t M′+Hq′I.Hence (M,S)⇒t (M,S′).
ext
– M′(q′) > 0 and M′(p′) = 0. In that case C′ = M′+Hp′I+M2 for some
multiset M2. Let M = M′−Hq′I+HpI. We have then C = C′+Hq,pI−
Hq′,p′I=M′+Hp′I+M2+Hq,pI−Hq′,p′I=M′+M2−Hq′I+HpI+HqI=M+
HqI+M2.Thisallowsustodeducethatq∈SandM ⪯C andconsequently
C ∈J(M,S)K.WealsohaveHpI⪯M andHq′I⪯M′andM−HpI=M′−Hq′I
and M +HqIÐ→t M′+Hp′I. Hence (M,S)⇒t (M′,S′). Observe that
switch
we need to use the ⇒ transition relation in this case. Assume that
switch
C(s) > 0 for some state s ∈ S such that (s,?a,s′) ∈ T, and that any
configuration in C such that M ⪯ C contains such state s. Then,
=K
applying ⇒ to such a multiset M will take awaythe process onstate
step
s and will lead to an abstract configuration with M′⪯/ C′.
16– M′(q′)>0 and M′(p′)>0. In that case C′=M′+M2 for some multiset
M2.LetM =M′−Hp′,q′I+Hp,qI.WehavethenC =C′+Hq,pI−Hq′,p′I=
M +M2. This allows us to deduce that M ⪯ C and consequently C ∈
J(M,S)K and that M Ð→t M′. Hence (M,S)⇒t (M′,S′). ⊓⊔
step
Thetwopreviouslemmasallowus toestablishcompletenessofthe construc-
tion,by asimple induction onthe lengthofthe consideredexecution.The proof
can be found on Appendix C.1.
Lemma 8. Let C ∈I and C ∈C such that C →∗ C. For all M ∈C such
in ≥K in =K
that M ⪯C there exists S ⊆Q such that C ∈J(M,S)K and γ ⇒∗(M,S).
in
5.4 Soundness of the algorithm
We now prove that if we have γ ⇒∗ (M,S) then the configuration M can be
in
covered.We first establish that the S-part of a reachable abstract configuration
stores only states that are reachable in a concrete execution.
Lemma 9. If γ =(M,S) is an abstract configuration such that γ ⇒∗ γ, then
in
all states q∈S are coverable.
Proof. We suppose that we have γ
in
= γ0 ⇒ γ1 ⇒ ... ⇒ γ
n
= (M,S) and we
prove this lemma by induction on n, the length of the abstract execution.
Case n = 0: In that case (M,S) = γ0 = (K ⋅Hq inI,{q in}), as q
in
is trivially
coverable,the property holds.
Casen>0:Weassumethatthepropertyholdsforall0≤m<nandconsider
the abstract execution γ0 Ôt ⇒1 γ1 Ôt ⇒2 ...Ôtn⇒γ
n
where γ0 =γ
in
and γ
i
=(M i,S i)
for all 0 ≤ i ≤ n. Let p ∈ S n. If p ∈ S n−1, then by induction hypothesis, p is
coverable.Otherwise,p∈S n∖S n−1,andlett n=(q,α,q′)withα∈{!a,!!a∣a∈Σ}.
By definition of ⇒, q∈S n−1 and
– either q′ = p, and by induction hypothesis, there exists an initialized ex-
ecution C0 →∗ C with C(q) > 0 and in that case, C0 →∗ C Ð→t C′ for a
configuration C′ such that C′(p)>0 and p is coverable.
– or α ∈ {!a,!!a} for some a ∈ Σ and (p′,?a,p) ∈ T, with p′ ∈ S n−1. By in-
duction hypothesis, both q and p′ are coverable, with q ∈ Q and p ∈ Q .
A W
By Lemma 1, there exists an execution C0 →∗ C such that C(q) ≥ 1 and
C(p′)≥1. We then have C Ðt→n C′ with C′(p)>0 (if α=!a then the process
onp′ canreceivethemessageaandmovetop,andifα=!!athentheprocess
onp′ willnecessaryreceivethebroadcastandmovetop),andpiscoverable.
⊓⊔
Thenextlemmaestablishessoundnessofthealgorithm.Moreover,itgivesan
upperboundontheminimalnumberofprocessesneededtocoveraconfiguration.
17Lemma 10. Let(M,S)beanabstractconfigurationsuchthatγ in⇒γ1⇒...⇒
γ =(M,S). Then, there exist C ∈ I, C ∈ C such that M ⪯ C and C →∗ C.
n in in
Moreover, ∣∣C ∣∣=∣∣C∣∣≤K+2∣Q∣×n.
in
Proof. We reason by induction on n, the length of the abstract execution.
Case n=0: The property trivially holds for C =HK⋅q I.
in
Casen>0:Weassumethatthepropertyholdsforall0≤m<nandconsider
the abstract execution γ0 Ôt ⇒1 γ1 Ôt ⇒2 ...Ôtn⇒γ
n
where γ0 =γ
in
and γ
i
=(M i,S i)
forall0≤i≤n.Byinductionhypothesis,weknowthatthereexistC
in
∈I,C n−1∈
C suchthatM n−1⪯C n−1 andC in →∗ C n−1 and∣∣C in∣∣=∣∣C n−1∣∣≤K+2∣Q∣×(n−1).
If M n = M n−1 then the property holds. Assume now that M n ≠ M n−1. We let
t n =(q,α,q′) with α=!a or α=!!a. By definition of ⇒, we know that S n−1 ⊆S n
and that q ∈S n−1. Thanks to Lemma 9, q is coverable. We now perform a case
analysis:
– Assume γ
n−1⇒tn
step
γ n. Then M
n−1Ðt→n
M n, and since M n−1⪯C n−1, we have
C n−1=M n−1+M for some multiset M.
● If α =!!a, then M n−1 +M = Hq1,...q K−1,qI +Hp1,...,p LI and M n =
Hq′,...q′ ,q′I where for all 1 ≤ i ≤ K −1, either (q ,?a,q′) ∈ T or
1 K−1 i i
a ∉ R(q ) and q = q′. For each 1 ≤ i ≤ L, define p′ as p′ = p if
i i i i i i
a∉R(p )orp′ issuchthat(p ,?a,p′)∈T.IfweletM′=Hp′,...,p′ Iand
i i i i 1 L
C n=M n+M′, we have by definition that C n−1Ðt →n C
n
with M n⪯C n.
● If α=!a and (M n−1−HqI)(p)>0 for some p∈Q such that (p,?a,p′)∈T
(i.e., a rendez-vous occurred), it holds that M n−1+M Ð→t M n+M and
we choose C =M +M.
n n
● If α =!a and (M n−1 −HqI)(p) = 0 for all p ∈ Q such that a ∈ R(p)
(i.e.itwasanon-blockingsendingofamessage),theneitherthereexists
(p,?a,p′)∈T suchthatM(p)>0,eitherforallp∈QsuchthatM(p)>0,
a∉R(p).Inthefirstcase,arendez-vouswilloccurintheexecutionoft
n
over C n−1, and we have M n−1+M Ðt→n M n+M −HpI+Hp′I. We then let
C n=M n+M−HpI+Hp′I. In the latter case, M n−1+M Ðt→n M n+M and
with C n=M n+M. In both cases, we have , C n−1 Ð→t C n and M n⪯C n.
In all cases, we have C in →∗ C n−1 → C n and ∣∣C in∣∣ = ∣∣C n∣∣ = ∣∣C n−1∣∣ ≤
K+2∣Q∣×(n−1)≤K+2∣Q∣×n.
– Assume γ
n−1⇒tn
extγ
n
or γ
n−1⇒tn
switchγ n.As q is coverable,fromCorollary 1,
there exists an execution Cq →∗ Cq such that Cq ∈ I and Cq(q) > 0 and
in in
∣∣Cq ∣∣≤2∣Q∣. From Lemma 2, we have the following execution: C +Cq →∗
in in in
C in +Cq. Next, from Lemma 3, by taking M = 1 and C˜ 0 = C in +Cq, we
haveanexecution C in+Cq →∗C n−1+C′q where C′q(q)>0. We deduce that
C n−1+C′q =M n−1+HqI+M for some multiset M. We now proceed with a
case analysis:
● Caseγ n−1⇒tn extγ
n
whereM n−1+HqIÐt→n M n+Hq′I.Bydefinitionof→,we
alsohaveM n−1+HqI+M →M n+Hq′I+M′ forsomemultisetM′.Letting
C n=M n+Hq′I+M′ givesusthatthatC in+C iq n→∗ M n−1+HqI+M →C n.
18● Case γ n−1⇒tn
switch
γ n: by definition of ⇒ switch, we know that there exists
(p,?a,p′) ∈ T with p ∈ S n−1 such that M n−1 = M′+HpI and that M′+
HpI+HqI Ðt→n M′ +Hq′I +Hp′I and M = M′ +Hq′I. Furthermore, by
n
definitionof→,wehaveM′+Hp,qI+M →M′+Hp′,q′I+M.Hencesetting
C =M′+Hp′,q′I+M =M +Hp′I+M gives us that that C +Cq →∗
n n in in
M n−1+HqI+M →C n, with M n⪯C n.
In both cases, we have shown that there exists C such that M ⪯ C
n n n
and C +Cq →∗ C . Furthermore we have that ∣∣C ∣∣ = ∣∣C +Cq ∣∣ ≤
in in n n in in
K+2∣Q∣×(n−1)+2∣Q∣≤K+2∣Q∣×n. ⊓⊔
5.5 Upper Bound
Using Lemmas 8 and 10, we know that there exists C ∈ I and C′ ∈ C such
that C →∗ C′ and C
f
⪯ C′ iff there exists an abstract execution γ
in
⇒ γ1 ⇒
⋯ ⇒ γ with γ = (C ,S) for some S ⊆ Q, hence the algorithm consisting in
n n f
deciding reachabilityofa vertex ofthe form(C ,S)fromγ inthe finite graph
f in
(Γ,⇒) is correct. Note furthermore that the number of abstract configurations
∣Γ∣ is bounded by ∣Q∣∣∣Cf∣∣ ×2∣Q∣. As the reachability of a vertex in a graph is
NL-complete, this gives us a NPSpace procedure, which leads to a Pspace
procedure thanks to Savitch’s theorem.
Theorem 4. ConfCover is in PSpace.
Remark 3. Thanks to Lemma 10, we know that γ
in
⇒ γ1 ⇒ ⋯ ⇒ γ
n
with
γ =(C ,S) iff there exists C ∈I, C ∈C such that C ⪯C and C →∗ C and
n f in f in
∣∣C ∣∣=∣∣C∣∣≤K+2∣Q∣×n.But due to the number ofabstractconfigurations,we
in
can assume that n≤2∣Q∣×∣Q∣∣∣Cf∣∣ as it is unnecessary in the abstract execution
γ
in
⇒ γ1 ⇒ ⋯ ⇒ γ
n
to visit twice the same abstract configuration. Hence the
configuration C is coverable iff there is C ∈ I and C′ ∈ C such C →∗ C′ and
f
C
f
⪯C′ and ∣∣C∣∣=∣∣C′∣∣≤K+2∣Q∣×2∣Q∣×∣Q∣∣∣Cf∣∣.
5.6 Lower Bound
ToprovePSpace-hardnessoftheConfCoverproblemforWait-Onlyprotocols,
we reduce the intersection non-emptiness problem for deterministic finite au-
tomata,whichis knowntobe PSpace-complete[Koz77].ThePSpace-hardness
in fact holds when considering Wait-Only protocols without any (non-blocking)
rendez-vous transitions, i.e. transitions of the form (q,!a,q′).
Let A 1,...,A
n
be a list of deterministic finite and complete automata with
A =(Σ,Q ,q0,{qf},∆ )forall1≤i≤n.Observethatwerestrictourreduction
i i i i i
toautomatawithauniqueacceptingstate,whichdoesnotchangethecomplexity
of the problem. We note Σ∗ the set of words overthe finite alphabet Σ and ∆∗
i
the function extending ∆ to Σ∗, i.e, for all q ∈ Q , ∆∗(q,ε) = q, and for all
i i i
w∈Σ∗ and a∈Σ, ∆∗(q,wa)=∆ (∆∗(q,w),a).
i i i
We build the protocolP withsetofstates Q,displayedinFigure 4 whereP
i
for 1 ≤ i ≤ n is a protocol mimicking the behaviour of the automaton A : P =
i i
19!!go q
s
!!a,a∈Σ
!!τ
?go
!!τ q1 q10 P1 q 1f ?go
q
in !!τ ... q fail
q n
?go
q n0 P n q nf
?go
Fig.4: Protocol P for PSpace-hardness of ConfCover.
(Q ,Σ,q0,T ), with T = {(q,?a,q′) ∣ (q,a,q′) ∈ ∆ }. Moreover, from any state
i i i i i
q∈⋃ 1≤i≤nQ i, there is an outgoing transition(q,?go,q fail). These transitions are
depicted by the outgoingtransitions labelledby ?go from the orangerectangles.
NotethatP isWait-OnlyasallstatesinP forall1≤i≤narewaitingstates
i
and the only active states are q
in
and q s. We show that ⋂ 1≤i≤nL(A i)≠∅ if and
only if there is an initial configuration C ∈I and a configuration C′ ∈C such
P P
that C →∗C′ and C ⪯C′ with C =Hqf,...,qfI.
f f 1 n
The idea is to synchronize (at least) n processes into simulating the n au-
tomata. To this end, we need an additional (leader) process that will broadcast
a messagego, whichwillbe receivedby the n processes,leading eachofthem to
reachadifferentautomatoninitialstate.Then,theleaderprocesswillbroadcast
a word letter by letter. Since the automata are all complete, these broadcast
will be received by all the processes that simulate the automata, mimicking an
execution. If the wordbelongs to all the automata languages,then eachprocess
simulating the automata ends the simulation on the unique final state of the
automaton. Note that if the leader process broadcasts the message go a second
time, then all the processes simulating the automata stop their simulation and
reach the state q . Formal proofs can be found in Appendix C.2.
fail
6 Conclusion
We have proved that when extending the model presented in [GSS23] with
broadcasts, StateCover for Wait-Only protocols remains in P, and is even
P-complete. We also explained how to retrieve a P lower bound for the model
of[GSS23]forbothproblemsrestrictedtoWait-Onlyprotocols.HoweverConf-
CoverforWait-OnlyprotocolsisnowPSpace-complete.Inthefuture,wewish
to study notonly coverabilityproblems butextend the analysisofthis modelto
liveness properties. We also wish to expand this model with dynamic creations
ofmessagesandprocessesinordertotake astep closerto the modellingofJava
Threads programming, where Threads can dynamically create new objects in
which they can synchronize with notify and notifyAll messages.
20References
AK86. K.R.AptandD.C.Kozen. Limitsforautomaticverificationoffinite-state
concurrent systems. Inf. Process. Lett., 22(6):307–309, 1986.
ARZ15. B. Aminof, S. Rubin, and F. Zuleger. On the expressive power of commu-
nication primitivesin parameterised systems. InLPAR’15,volume9450 of
Lecture Notes in Computer Science, pages 313–328. Springer, 2015.
BER21. A.R.Balasubramanian, J. Esparza, andM.A.Raskin. Findingcut-offsin
leaderless rendez-vousprotocols is easy. In FOSSACS’21, volume 12650 of
LNCS, pages 42–61. Springer, 2021.
DEGM17. A.Durand-Gasselin,J.Esparza,P.Ganty,andR.Majumdar. Modelcheck-
ing parameterized asynchronous shared-memory systems. Formal Methods
in System Design, 50(2-3):140–167, 2017.
DRB02. G. Delzanno, J. F. Raskin, and L. Van Begin. Towards the automated
verificationofmultithreadedjavaprograms. InTACAS’02,volume2280of
LNCS, pages 173–187. Springer, 2002.
DSTZ12. G. Delzanno, A. Sangnier, R. Traverso, and G. Zavattaro. On the com-
plexityofparameterized reachability inreconfigurablebroadcast networks.
In FSTTCS’12, volume 18 of LIPIcs, pages 289–300. Schloss Dagstuhl -
Leibniz-Zentrum fürInformatik, 2012.
EFM99. J. Esparza, A. Finkel, and R. Mayr. On the verification of broadcast pro-
tocols. In LICS’99,pages 352–359. IEEE Comp. Soc. Press, July 1999.
EK03. E. Allen Emerson and V. Kahlon. Model checking guarded protocols. In
(LICS 2003, pages 361–370. IEEE, 2003.
GS92. S. M. German and A. P. Sistla. Reasoning about systems with many pro-
cesses. Journal of the ACM,39(3):675–735, 1992.
GSS23. L.Guillou, A.Sangnier,and N.Sznajder. Safety analysisof parameterised
networks with non-blocking rendez-vous. In CONCUR’23, volume 279 of
LIPIcs, pages 7:1–7:17. loss Dagstuhl - Leibniz-Zentrum für Informatik,
2023.
HS20. F.HornandA.Sangnier. Decidingtheexistenceofcut-offinparameterized
rendez-vousnetworks. In CONCUR’20,volume171 of LIPIcs,pages 46:1–
46:16. Schloss Dagstuhl - Leibniz-Zentrum fürInformatik, 2020.
Koz77. DexterKozen. Lowerboundsfornaturalproofsystems. InFOCS’77,pages
254–266. IEEE Computer Society,1977.
Lad75. Richard E. Ladner. The circuit valueproblem is log space complete for P.
SIGACT News, 7(1):18–20, 1975.
SS13. S. Schmitz and P. Schnoebelen. The power of well-structured systems. In
CONCUR’13, volume 8052 of Lecture Notes in Computer Science, pages
5–24. Springer,2013.
21A Proofs of Section 3
Proof of Lemma 2.
Formally,wecanproveLemma 2byinductionon0≤i≤k.Fori=0,itcomes
from the definitions. Now assume that Ĉ(q) = C (q) for all q ∈ Q∖{q }, and
i i in
Ĉ(q )=C (q )+C′(q ), and let M =C′(q ).
i in i in 0 in 0 in
– Ift′ i+1=(p1,!!m,p2),letC i=Hp1,q 1′,...,q N′ ′−1IandC i+1 =Hp2,p′ 1,...,p′ N′−1I.
For all 1 ≤ i ≤ N′−1, either m ∉ R(q′), and p′ = q′, or (q′,?m,p′) ∈ T. By
i i i i i
induction hypothesis, Ĉ
i
= Hp1,q 1′,...,q N′ ′−1,M ⋅q inI. Since q
in
is an active
state, we know that m∉R(q in), hence Ĉ i+1=Hp2,p′ 1,...,p′ N′−1,M⋅q inI, and
Ĉ i+1(q)=C i+1(q) for all q∈Q∖{q in}, and Ĉ i+1(q in)=C i+1(q in)+C 0′(q in).
– If t′
i+1
= (p1,!m,p2) and there exist q,q′ ∈ Q such that (q,?m,q′) ∈ T and
C i(q) > 0, then C i = Hp1,q,q 1′,...q N′ ′−2I and C i+1 = Hp2,q′,q 1′,...q N′ ′−2I.
By induction hypothesis, Ĉ i = Hp1,q,q 1′,...q N′ ′−2,M ⋅q inI and hence Ĉ i+1 =
Hp2,q′,q 1′,...q N′ ′−2,M ⋅q inI.
– If t′
i+1
=(p1,!m,p2) and for all q,q′ ∈Q such that (q,?m,q′)∈T, C i(q)=0,
then for all q,q′ ∈ Q such that (q,?m,q′) ∈ T, Ĉ(q) = C (q) = 0. Indeed,
i i
since q in is an active state, q in ≠q. Then C i+1 =C i−Hp1I+Hp2I and Ĉ i+1 =
Ĉ i−Hp1I+Hp2I.Hence,Ĉ i+1(q)=C i+1(q)forallq∈Q∖{q in}andĈ i+1(q in)=
C i+1(q in)+C 0′(q in).
◻
Proof of Lemma 3.Again,wecanprovethis propertybyinductionon0≤i≤
k. For i=0, it is obvious since C0(q)=0 for all q ∈Q∖{q in}. Let now 0≤i<k
and assume that the property is true. Let N1 =C0(q in). Then C̃ i ÐtiÐ+→1 C̃ i+1 is a
transition that preserves the property. The proof of it depends on t i+1:
– If t i+1=(p1,!!a,p2), then by induction hypothesis, C̃ i(p1)≥C̃ 0(p1)+C i(p1)
ifp1≠q in,andC̃ i(p1)≥(M−1).N1+C i(p1)ifp1=q in.Moreover,C i(p1)>0,
hence the transition t i+1 can be taken from C̃ i. Let C i =Hp1,q 1′,...,q N′ 1−1I,
then C i+1 = Hp2,p′ 1,...,p′ N−1I such that for all 1 ≤ i ≤ N, either a ∉ R(q i′)
and p′
i
= q i′, or (q i′,?a,p′ i) ∈ T. Also, C̃
i
= Hp1,q 1′,...,q N′ 1−1,q 1′′,...,q K′′I and
C̃ i+1 =Hp2,p′ 1,...,p′ N1−1,p′ 1′,...,p′ K′I, with, for all 1≤i≤K, either a∉R(q i′′)
andp′ i′=q i′′,or(q i′′,?a,p′ i′)∈T.So itisobviousthatforallq′ ∈Q,C̃ i+1(q′)≥
C i+1(q′). Let now q′ ∈ Q A. Either C̃ i+1(q′) = C̃ i(q′)+ℓ for some ℓ ≥ 0, or
C̃ i+1(q′) = C̃ i(q′)−1 (and q′ = p1). In the first case, C i+1(q′) = C i(q′)+ℓ′,
withℓ≥ℓ′≥0.Indeed,let{q1,...,qr}bethesetofstatessuchthatC̃(qj)>0
i
and(qj,?a,q′)forall1≤j≤r.Forall1≤j ≤r,C (qj)≤C̃(qj)byinduction
i i
hypothesis,so C i+1(q′)=C i(q′)+ℓ′ andC̃ i+1(q′)=C̃ i(q′)+ℓwith ℓ≥ℓ′≥−1
(observe that if ℓ′ = −1, it means that q′ = p1 and that no process has
gone to p1 when receiving a). Hence, if q′ ≠ q in, by induction hypothesis,
C̃ i+1(q′)≥C̃ 0(q′)+C i(q′)+ℓ=C̃ 0(q′)+C i+1(q′)−ℓ′+ℓ≥C̃ 0(q′)+C i+1(q′).
If otherwise q′ =q in, by induction hypothesis, C̃ i+1(q in)=C̃ i(q in)+ℓ≥(M−
1).N1+C i(q in)+ℓ=(M−1).N1+C i+1(q in)−ℓ′+ℓ≥(M−1).N1+C i+1(q in).
22Inthesecondcase,wehavethatC̃ i+1(p1)=C̃ i(p1)−1,sonoprocessreceiving
message a goes to p1. Then C i+1(p1) = C i(p1)−1, because for all q ∈ Q
W
such that (q,?a,p1)∈T, C m′′ ,i(q)=0, and C m′′ ,i(q)≥C i(q), so no process in
C
i
can receive message a and go to p1 neither. So, if p1 ≠q in, by induction
hypothesis, C̃ i+1(p1) ≥ C̃ 0(p1)+C i(p1)−1 = C̃ 0+C i+1(p1), and if p1 = q in,
C̃ i+1(q in) ≥ (M −1).N1+C i(q in)−1 = (M −1).N1+C i+1(q in) and we are
done.
– Let t i+1 = (p1,!a,p2) and there exist p,p′ ∈ Q such that (p,?m,p′) ∈ T and
C i(p)> 0 and C i(p1)> 0. Then, C i+1 = C i−Hp1,pI+Hp2,p′I. By induction
hypothesis, if p1 ≠q in, C̃ i(p1)≥C̃ 0(p1)+C i(p1), if p1 =q in, C̃ i(p1)≥(M −
1).N1+C i(p1),and C̃ i(p)≥C i(p)hence C̃ i ÐtiÐ+→1 C̃ i+1. Moreover,C̃ i+1 =C̃ i−
Hp1,pI+Hp2,p′I.Hence,ifp1≠q in,C̃ i+1(p1)=C̃ i(p1)−1≥C̃ 0(p1)+C i(p1)−1=
C̃ 0(p1)+C i+1(p1),andifp1=q in,C̃ i+1(p1)=C̃ i(p1)−1≥(M−1).N1+C i(p1)−
1=(M−1).N1+C i+1(p1). Now, by induction hypothesis, we also have that
C̃ i(p)≥C i(p).Hence,C̃ i+1(p)=C̃ i(p)−1≥C i(p)−1=C i+1(p).Letanyother
q∈Q A.Ifq∉{p2,p′,q in},C̃ i+1(q)=C̃ i(q)≥C̃ 0(q)+C i(q)=C̃ 0(q)+C i+1(q).If
q=q
in
∉{p2,p′},C̃ i+1(q)=C̃ i(q)≥(M−1).N1+C i(q)=(M−1).N1+C i+1(q).
Ifq∈{p2,p′},thenC̃ i+1(q)=C̃ i(q)+1≥C̃ 0(q)+C i(q)+1=C̃ 0(q)+C i+1(q)if
q≠q in,andC̃ i+1(q)=C̃ i(q)+1≥(M−1).N1+C i(q)+1=(M−1)+N1+C i+1(q)
ifq=q in.Letq∈Q
W
suchthatp≠q,ifq∉{p2,p′},C̃ i+1(q)=C̃ i(q)≥C i(q)=
C i+1(q). If p∈{p2,p′}, then C̃ i+1(q)=C̃ i(q)+1≥C i(q)+1=C i+1(q).
– Ift i+1=(p1,!a,p2)andforallp,p′∈Qsuchthat(p,?m,p′)∈T,wehavethat
C′(p) = 0. Then, either C̃(p) = 0 for all p,p′ ∈ Q such that (p,?a,p′) ∈ T,
i i
or there exist some p,p′ ∈ Q such that (p,?m,p′)∈T and C̃(p)>0. In the
i
first case, since C̃ i(p1)≥0 by induction hypothesis, C̃ i+1 =C̃ i−Hp1I+Hp2I,
andC i+1 =C i−Hp1I+Hp2I.ThenitisobviousthatC̃ i+1(q)≥C̃ 0(q)+C i+1(q)
for all q ∈ Q
A
∖{q in}, C̃ i+1(q) ≥ C i+1(q) for all q ∈ Q W, and C̃ i+1(q in) ≥
(M −1).N1+C i+1(q in). In the second case, C̃ i+1 =C̃ i−Hp1,pI+Hp2,p′I. Let
q ∈ Q A. If q = p1, then if q ≠ q in, C̃ i+1(q) = C̃ i(q)−1 ≥ C̃ 0(q)+C i(q)−1 =
C̃ 0(q)+C i+1(q), and if q=p1=q in, then C̃ i+1(q)=C̃ i(q)−1≥(M −1).N1+
C i(q)−1= (M −1).N1+C i+1(q). If q =p2, if q ≠q in, C̃ i+1(q)=C̃ i(q)+1 ≥
C̃ 0(q)+C i(q)+1=C̃ 0(q)+C i+1(q), and if q=p2=q in, C̃ i+1(q)=C̃ i(q)+1≥
(M−1).N1+C i(q)+1=(M−1).N1+C i+1(q).Ifq=p′,andq≠q in,C̃ i+1(q)=
C̃ i(q)+1≥C̃ 0(q)+C i(q)+1>C̃ 0(q)+C i+1(q) since C i+1(p′)=C i(p′)+1. If
q=p′ =q in,C̃ i+1(q)=C̃ i(q)+1≥(M−1).N1+C i(q)+1=(M−1).N1+C i+1(q).
Otherwise, C̃ i+1(q)=C̃ i(q)≥C̃ 0(q)+C i(q)=C̃ 0(q)+C i+1(q) if q≠q in, and
C̃ i+1(q)=C̃ i(q)≥(M −1).N1+C i(q)=(M −1).N1+C i+1(q) if q=q in.
Finally,letq∈Q W.If p=q,thenC̃ i+1(q)=C̃ i(q)−1≥0.However,C i+1(q)=
C i(q)=0,thenC̃ i+1(q)≥C i+1(q).Ifq=p2,thenC̃ i+1(q)=C̃ i(q)+1≥C i(q)+
1=C i+1(q). If q=p′, then C̃ i+1(q)=C̃ i(q)+1≥C i(q)+1>C i(q)=C i+1(q).
Otherwise, C̃ i+1(q)=C̃ i(q)≥C i(q)=C i+1(q).
◻
23B Proofs of Section 4.2
WegivetheformaldefinitionsoftheprotocolandtheformalproofsofSection 4.2.
We start by introducing some notations. We denote an instance of CVP: C =
(V,o,G,B,b) where V ={v1,...,v n} denotes the n input variables,o is the out-
putvariable,G={g1,...,g m}the mbooleangates,B ={b1,...,b n}the boolean
assignment such that for all 1 ≤ i ≤ n, boolean b ∈ {⊺,–} is the assignment of
i
variable v i, and b the boolean output value to test. Let V′ = V ∪{o1,...,o m}
whereo isthe outputvariableofgatej for1≤j≤m.Wlogwecanassumethat
j
o=o m. For 1≤j≤m, we denote gate g
j
by g j(◇,x1,x2,o j) with x1,x2∈V′ and
◇ ∈ {∨,∧} or by g (¬,x,o ) with x ∈ V′. As C is acyclic, one can assume that
j j
x1,x2,x∈V ∪{o1,o2,...,o j−1}.
Let some x ∈ V′, we denote bv(x) the boolean value of x with respect to
the input B. Note that if x∈ V, there exists 1≤i ≤n such that x =v and so
i
bv(x)=b .
i
Let1≤j≤m,wedescribeP =(Q ,Σ ,T )whereΣ =V′×{⊺,–}asfollows:
j j j j j
– if g j(∨,x1,x2,o j), Q
j
={q 0j,q ⊺j,q 1j,q –j}, and T
j
={(q 0j,?(x k,⊺),q ⊺j)∣k =1,2}
∪ {(q 0j,?(x1,–),q 1j), (q 1j,?(x2,–),q –j)} ∪ {(q ⊺j,!!(o j,⊺),q ⊺j),(q –j,!!(o j,–),q –j)};
– if g j(∧,x1,x2,o j), Q
j
={q 0j,q ⊺j,q 1j,q –j}, and T
j
={(q 0j,?(x k,–),q –j)∣k =1,2}
∪ {(q 0j,?(x1,⊺),q 1j), (q 1j,?(x2,⊺),q ⊺j)} ∪ {(q ⊺j,!!(o j,⊺),q ⊺j),(q –j,!!(o j,–),q –j)};
– if g (¬,x,o ), Q ={qj,qj,qj}, and T ={(qj,?(x,–),qj),(qj,?(x,⊺),qj)} ∪
j j j 0 ⊺ – j 0 ⊺ 0 –
{(qj,!!(o ,⊺),qj),(qj,!!(o ,–),qj)}.
⊺ j ⊺ – j –
WearenowreadytodefinetheprotocolassociatedtoC,P =(Q,Σ,q ,T):
C in
– Q={q in}∪⋃ 1≤j≤mQ j;
– Σ =V′×{⊺,–};
– T ={(q in,!!(v j,b j),q in)∣1≤j≤n}∪{(q in,!!τ,q 0j)∣1≤j ≤m}⋃ 1≤j≤mT j.
Observe that P is Wait-Only: q is an active state, and for all 1≤j ≤m: if
in
g is a "not" gate, qj is a waiting state, and qj,qj are active states, and if g
j 0 – ⊺ j
is an "and" gate or an "or" gate, qj,qj are active states and qj,qj are waiting
– ⊺ 0 1
states.
We show that bv(o)=b if and only if there is an initial configuration C0 ∈I
and C
f
∈C such that C0→∗ C
f
and C f(q bm)>0.
Lemma 11. Ifbv(o)=b,thenthereexistsC0∈I andC
f
∈C suchthatC0→∗ C
f
and C (qm)>0.
f b
Proof. Assume that bv(o) = b, and take C0 = H(m+1).q inI. There exists an
te hx eec iu nt pio un
t
bC o0 ol→ ea∗ nC vf aluw ei sth BC ff or= 1H ≤q in j, ≤q y1 m1, .q y2 B2, y.. d. eq fiym
nm
iI tiow nh ,e yre y =j b= v(b ov )(o =j) b.w Ti hth
e
m
aex lle 0cu ≤ti jon <i ms: .C B0 et→ w+ eeC n1 C→ j+ a. n. d.→ C+ j+C 1,m thw eh se er qe uC ej nc= eH oq fin t, rq ay1 n1 s, i. t. i. oq nyj sj, isq :in,...,q inI for
24– if g j+1(∨,x1,x2,o j+1) with bv(x k)=⊺ for some k∈{1,2},then bv(o j+1)=⊺.
Either x = v (and b = ⊺) for some 1 ≤ i ≤ n, or x = o (and y = ⊺) for
k i i k i i
some 1 ≤i ≤j. In the first case, as C (q )≥2, then consider the sequence
j in
C
j
Ð( ÐqinÐ, Ð!!τ Ð,q Ð0j+ Ð1 →) C j′ Ð( ÐqiÐn, Ð!!( ÐviÐ,⊺ Ð) Ð,q Ðin→) C j+1. It holds that C j′ =C j−Hq inI+Hq 0j+1 I
and C j+1 =C j′ −Hq 0j+1 I+Hq ⊺j+1 I. Hence C j+1 =Hq in,q y1 1,...q yj j,q yj+ j+1 1,...,q inI.
In the second case, C (qi) > 0 as i ≤ j and ⊺ = bv(o ), and C (q ) >
j ⊺ i j in
0. Consider the sequence C
j
Ð( ÐqinÐ, Ð!!τ Ð,q Ð0j+ Ð1 →)
C j′
Ð( Ðq⊺i Ð,!! Ð(o Ði, Ð⊺ Ð),q Ð⊺i →)
C j+1. It holds
that C j′ = C j −Hq inI+Hq 0j+1 I and C j+1 =C j′ −Hq 0j+1 I+Hq ⊺j+1 I. Hence C j+1 =
Hq ,q1 ,...qj ,qj+1,...,q I.
in y1 yj yj+1 in
– if g j+1(∧,x1,x2,o j+1) with bv(x k) = – for some k = 1,2, then bv(o j+1) =
–=y j+1. The sequence of transitions is built in an analogous way than the
previous case, however this time the broadcast messages are τ and (x ,–)
k
and the reached state is
qj+1
.
–
– if g j+1(∨,x1,x2,o j+1) with bv(x1) = bv(x2) = –, then bv(o j+1) = –. Either
x1=v
i
(andb i=–) forsome1≤i≤n,orx1=o
i
(andy i=–)for some1≤i≤
j.Inthefirstcase,asC (q )≥2,thenconsiderthesequenceC
Ð( ÐqinÐ, Ð!!τ Ð,q Ð0j+ Ð1 →)
j in j
C j,1 Ð( ÐqiÐn, Ð!!( ÐviÐ,– Ð) Ð,qiÐn→) C j,2. It holds that C j,1 = C j −Hq inI+Hq 0j+1 I and C j,2 =
C j,1−Hq 0j+1 I+Hq 1j+1 I.
If x1 =o
i
for some i≤j, C j(q –i)>0 as i≤j and –=bv(o i), and C j(q in)>0.
Consider the sequence C j
Ð( ÐqinÐ, Ð!!τ Ð,q Ð0j+ Ð1 →)
C j,1
Ð(q Ð–i Ð,!! Ð(o Ði, Ð–) Ð,q Ð–i →)
C j,2. It holds that
C j,1=C j−Hq inI+Hq 0j+1 I and C j,2=C j,1−Hq 0j+1 I+Hq 1j+1 I.
In both cases, C j,2=Hq in,q y1 1,...q yj j,q 1j+1 ,...,q inI.
WemakethesamecasesdistinctionsinordertobuildtheconfigurationC j+1
suchthatC
j,2Ð(q Ð,! Ð!( Ðx2Ð,– Ð) Ð,q →)
C j+1 whereq=q in ifx2∈V,andotherwisex2=o i
for some i≤j and q=qi.
–
It holdsthatC j+1 =C j,2−Hq 1j+1 I+Hq –j+1 I,hence C j+1 =Hq in,q y1 1,...q yj j,q yj+ j+1 1,
...,q I.
in
– if g j+1(∧,x1,x2,o j+1) with bv(x1) = bv(x2) = ⊺, then bv(o j+1) = ⊺. The
sequence of transitions is built in an analogous way than the previous case,
however this time the broadcastmessages are τ, (x1,⊺) and (x2,⊺) and the
reached state is
qj+1
.
⊺
– ifg j+1(¬,x,o j+1)withbv(x)=⊺(resp.–),thenbv(o j+1)=–(resp.⊺).Either
x=v forsome1≤i≤n,andasC (q )≥2,webuildthefollowingsequence:
i j in
C
j
Ð( ÐqinÐ, Ð!!τ Ð,q Ð0j+ Ð1 →) ,C j′ Ð(q ÐinÐ,( ÐviÐ,b Ði) Ð,q Ðin→) C j+1. It holds that C j′ =C j−Hq inI+Hq 0j+1 I
and C j+1 =C j′ −Hq 0j+1 I+Hq ¯ bj i+1 I where¯ b i=– (resp.¯ b i=⊺).
Otherwise, x = o for some i ≤ j, and so C (qi) > 0 (resp. C (qi) > 0) and
i j ⊺ j –
C (q ) > 0. Hence, we can build the following sequence: C
Ð( ÐqinÐ, Ð!!τ Ð,q Ð0j+ Ð1 →)
j in j
,C j′ Ð( ÐqiÐn, Ð(o Ði, Ðbv Ð(o Ði) Ð) Ð,qiÐn→) C j+1. It holds that C j′ =C j−Hq inI+Hq 0j+1 I and C j+1 =
C′ −Hqj+1 I+Hqj+1 I where y¯ =– (resp. y¯ =⊺).
j 0 y¯ i i i
25In both cases, C j+1 =Hq in,q y1 1,...q yj j,q yj+ j+1 1,...,q inI.
Hence, C0→+C
m
where C m(q ym m)>0, and so if b=y m, C m(q bm)>0. ⊓⊔
Lemma 12. IfthereexistsC0∈I andC
f
∈C suchthatC0→∗C
f
andC f(q bm)>
0, then bv(o)=b.
Proof. Let C0∈I and C
f
∈C such that C0→∗ C
f
and C f(q bm)>0.
First we show that all broadcast messages (x,b )∈V′×{⊺,–} are such that
x
b = bv(x). We start by proving it for x ∈ V, and then proceed to prove it for
x
x∈{o1,...,o m} by induction on m.
Let(x,b )abroadcastmessagesuchthatx∈V,wenotex=v with1≤i≤n.
x i
By construction of the protocol P, the only broadcast transition labelled with
first element v is the transition(q ,!!(v ,b ),q ) where b is the input boolean
i in i i in i
value for variable v , i.e. bv(v )=b . Hence, all broadcast messages (x,b ) with
i i i x
x∈V, are such that b =bv(x).
x
We prove now than for all (x,b x)∈{o1,...,o m}×{⊺,–}, b
x
=bv(x) and we
do so by induction on m. For m = 1, we have that x = o1. Note that tuples
containing o1 can only be broadcast from q –1 or q ⊺1 . Denote g1(◇,x1,x2,o1) or
g1(¬,x3,o1) with ◇∈{∨,∧} and x1,x2,x3 ∈V by acyclicity.
– if◇=∨,thenaprocessreachingq ⊺1 hasnecessarilyreceived(x1,⊺)or(x2,⊺),
and a process reaching q –1 has necessarily received (x1,–) and (x2,–). As
we proved, all broadcast messages containing x1 (resp. x2) are of the form
(x1,bv(x1))(resp.(x2,bv(x2))). Hence,only one state between q ⊺1 andq –1 is
reachable.Ifitisq ⊺1 (resp.q –1 ),theonlymessagescontainingo1 whichcanbe
broadcast are (o1,⊺) (resp. (o1,–)) and it holds that ⊺=bv(x1)∨bv(x2)=
bv(o1) (resp. –) as the process on q ⊺1 (resp. q –1 ) received either (x1,⊺) or
(x2,⊺) (resp. (x1,–) and (x2,–));
– if ◇=∧, the argument is analogous to the previous case;
– if ◇ = ¬, then a process reaching q ⊺1 has necessarily received (x3,–) and
a process reaching q –1 has necessarily received (x3,⊺). As we proved, all
broadcast messages containing x3 are of the form (x3,bv(x3)). Hence, only
one state between
q1
and
q1
is reachable. If it is
q1
(resp.
q1
), the only
⊺ – ⊺ –
messages containing o1 which can be broadcast are (o1,⊺) (resp. (o1,–))
and it holds that ⊺=¬bv(x3)=bv(o1) (resp. –) as the process on q ⊺1 (resp.
q –1 ) received (x3,–) (resp. (x3,⊺)).
Assume the property true for m gates, and let (o m+1,b m+1) a broadcast mes-
sage and note g m+1(◇,x1,x2,o m+1) with ◇ ∈ {∧,∨}, or g m+1(¬,x3,o m+1) with
x1,x2,x3 ∈ V ∪{o1,...,o m}. By induction hypothesis, the only broadcast mes-
sages containing x1, x2 or x3 are (x1,bv(x1)), (x2,bv(x2)), and (x3,bv(x3)).
The arguments are then the same than in the case m=1. ⊓⊔
Hence, we provedwith the two previous lemmas that bv(o)=b if and only if
qm is coverable and we get the following theorem.
b
Theorem 5. StateCover for Wait-Only protocols is P-hard.
26Remark 4. If we transform the Wait-Only protocol presented here into a Wait-
Only NB-Rendez-vous protocol (by transforming all the broadcast transitions
intosendingtransitionsonthe samemessage),the reductionremainssoundand
complete. Indeed, in the execution of P built in Lemma 11, all the broadcasts
C
arereceivedbyonlyoneprocess.Hence,thesameexecutionispossiblebyreplac-
ing broadcaststransitionsby sending transitions.The proofofLemma 12works
exactly the same way if the broadcasts transitions become sending transitions.
Hence,theStateCoverandConfCoverproblemsforWait-OnlyNB-Rendez-
vous are P-hard, closing a lower bound open in [GSS23].
C Proofs of Section 5
C.1 Proofs of Section 5.3
ProofofLemma 7.WepresentherethetwomissingcasesintheproofofLemma 7.
(i) if α=!!a, then by definition of →, C =Hq1,...,q n,qI and C′ =Hq 1′,...,q n′,q′I
such that for all 1≤i≤n, either (q ,?a,q′)∈T or a∉R(q ) and q =q′. We
i i i i i
get the two following disjoint cases:
– M′(q′) = 0. In this case, M′ = Hq′ ,q′ ,...q′ I where 1 ≤ i ≤ n for all
1 ≤ j ≤ K and i ≠ i if j ≠ ℓ.
Lei t1 Mi2
=
HqiK
,q ,...q I.
Nj
ote that we
j ℓ i1 i2 iK
have M ⪯C, hence C ∈J(M,S)K. Using the definition of →, we have as
well M +HqI → M′+Hq′I. Furthermore since C(q) > 0, we have q ∈ S
t
by definition of S. Applying the definition of ⇒ we have (M,S)Ô⇒
ext
ext
(M′,S′).
– M′(q′) > 0. In this case, M′ = Hq′ ,q′ ,...q′ ,q′I where 1 ≤ i ≤ n
for all 1 ≤ j < K and i ≠ i if
ji1
≠
i ℓ2
.
LetiK M−1
= Hq ,q ,...q
j
,qI.
j ℓ i1 i2 iK−1
Note that we have M ⪯ C, hence C ∈ J(M,S)K. Using the definition of
→, we have as well M → M′. Applying the definition of ⇒ , we get
step
t
(M,S)Ô⇒ (M′,S′).
step
(ii) if α =!a and the message is not received (i.e. it is a non blocking sending),
then using the definition of →, we have C′ =C−HqI+Hq′I and a∉R(p) for
all p ∈ Q such that (C −HqI)(p) > 0. We obtain the two following disjoint
cases:
– M′(q′) = 0. Since C′(q′) > 0 and M′ ⪯ C′, we deduce that C′ = M′+
Hq′I+M2 for some multiset M2. By definition of C′, we have as well
C = C′+HqI−Hq′I, hence C = M′+HqI+M2. We deduce that M′ ⪯ C
and hence C ∈ J(M′,S)K. Furthermore we have M′ +HqI → M′ +Hq′I
as a ∉ R(q) for all states q ∈ Q such that M′(q) > 0. Consequently,
t
(M′,S)Ô⇒ (M′,S′).
ext
– M′(q′) > 0. Since M′ ⪯ C′, we have C′ = M′ +M2 for some multiset
M2. Let M =M′+HqI−Hq′I. We have hence C =C′+HqI−Hq′I=M′+
HqI−Hq′I+M2=M +M2. Hence M ⪯C and C ∈J(M,S)K. Furthermore
we have that a ∉ R(p) for all p ∈ Q such that (M −HqI)(p) > 0). We
27hence deduce that M Ð→t M′. Applying the definition of ⇒ , we get
step
t
(M,S)Ô⇒ (M′,S′).
step
◻
Proof of Lemma 8. Suppose we have C0
Ðt→1
C1
Ðt→2
...
Ðt→n
C
n
with C0 =C
in
and C =C. We show by induction on 0≤i≤n that for all M ∈C such that
n i =K
M ⪯C there exists S ⊆Q such that C ∈J(M ,S )K and γ ⇒∗(M ,S ).
i i i i i i in i i
For i=0, we have C =H∣∣C∣∣⋅q I and HK⋅q I is the unique configuration
in in in
of size K smaller than C . Since γ =(HK⋅q I,{q }), we have C ∈Jγ K.
in in in in in in
Assume now that the property holds for 0≤i<n. Let M i+1∈C
=K
such that
M i+1 ⪯ C i+1. Since C i
ÐtiÐ+→1
C i+1, by applying Lemma 7, there exists M i ∈ C =K,
S i+1 ⊆ Q such that (M i,S i) ⇒ (M i+1,S i+1) where S i = {q ∈ Q ∣ C i(q) > 0},
C i ∈ J(M i,S i)K and C i+1 ∈J(M i+1,S i+1)K. By induction hypothesis, there exists
S′ ⊆Q such that C ∈J(M ,S′)K and γ ⇒∗ (M ,S′). But since C ∈J(M ,S′)K
i i i i in i i i i i
and S = {q ∈ Q ∣ C (q) > 0}, we have S ⊆ S′. Using Lemma 6.2, we deduce
i i i i
that there exists S i′ +1 such that S i+1 ⊆S i′ +1 and (M i,S i′)⇒(M i+1,S i′ +1). Hence
γ in ⇒∗(M i+1,S i′ +1) and thanks to Lemma 6.1, C i+1 ∈J(M i+1,S i′ +1)K. ◻
C.2 Proofs of Section 5.6
Assume that there exists a wordw=a1...a
k
∈⋂ 1≤i≤nL(A i),i.e., q if =∆∗(q i0,a1
...a ) for all 1 ≤ i ≤ n. Then take C = H(n+1).q I. There exists an execu-
k in
tion C →∗ C′ with C′ = Hq ,qf,...,qfI ⪰ C . This execution is C Ð( ÐqiÐn, Ð!!τ Ð,q Ðs→)
s 1 n f
C˜
1
Ð( ÐqiÐn, Ð!!τ Ð,q Ð1→) C˜
2...
Ð( ÐqinÐ, Ð!!τ Ð,q Ðn→) C˜
0
Ð( ÐqsÐ,!! Ðgo Ð,q Ðs→)
C0
Ð(q ÐsÐ,!! Ða1Ð,q Ðs→)
C1
Ð( ÐqsÐ,!! Ða2Ð,q Ðs→)
C2...
Ð(q ÐsÐ,!! ÐakÐ,q Ðs→)
C′.
One can check that C0(q i0 )= 1 for all 1 ≤ i ≤ n, and hence, by definition of
(T i)1≤i≤n, C k(q if)=1 for all 1≤i≤n. Hence C′=Hq s,q 1f,...,q nfI⪰C f.
Reciprocally, assume that there exists an initial configuration C and an ex-
ecution C →∗ C′ with C′ ⪰ C . We first make easy observations about the
f
executions of this protocol.
Observation 1 Let C1,C2 ∈C P.WewriteC1Ð→τ ∗C2 ifthereexistsasequenceof
k transitions C1Ðt →1 ...Ðt →k C2 such that t i∈{(q in,!!τ,q)∣q∈{q s,q1,...,q n}} for
all 1≤i ≤k. Then C2(q)≥ C1(q) for all q ∈ {q s,q1,...,q n}, C2(q in)≤C1(q in),
and C2(q)=C1(q) for all other q∈Q.
Observation 2 LetC1,C2∈C
P
suchthatC1→∗ C2 withnotransition(q s,!!go,q s).
If there is some 1 ≤ i ≤ n with C1(q) = 0 for all q ∈ Q i, then C2(q) = 0 for all
q∈Q .
i
Observation 3 Let C1,C2 ∈ C
P
such that C1
Ð( ÐqsÐ,!! Ðgo Ð,q Ðs→)
C2. Then, C2(q s) =
C1(q s)>0, and C2(q)=0 for all q∈⋃ 1≤i≤n(Q i∖{q i0 }).
28We can deduce from these observations that the execution C →∗ C′ can be
decomposed in C →∗ Cˆ Ð( ÐqsÐ,!! Ðgo Ð,q Ðs→) C0 →∗ C′. Indeed, since C(q) = 0 for all
q∈⋃ 1≤i≤nQ i, if no transition(q s,!!go,q s) appearsin the execution,Observation
2 allows to conclude that C′(qf) = 0 for all 1 ≤ i ≤ n, which contradicts the
i
fact that C′ ⪰C . Assume now that this transition is the last transition where
f
action go is sent, i.e., C0 →∗ C′ has no transition (q s,!!go,q s). By Observation
3, C0(q s)>0 and C0(q)=0 for all q ∈⋃ 1≤i≤n(Q i∖{q i0 }). By Observation 2, we
also deduce that C0(q i0 )>0 for all 1≤i≤n. Otherwise, if there exists 1≤j ≤n
such that C0(q j0 )=0, then C′(q jf)=0 which is a contradiction with C′⪰C f.
Now the execution C 0′ →∗ C′ is of the form C0 Ð→τ ∗C 0′ Ð( ÐqsÐ,!! Ða1Ð,q Ðs→) C1 Ð→τ
∗C 1′ Ð( ÐqsÐ,!! Ða2Ð,q Ðs→) C2... Ð(q ÐsÐ,!! ÐakÐ,q Ðs→) C
k
Ð→τ ∗C′. Using Observation 1, we can obtain
a new execution C0
Ð( ÐqsÐ,!! Ða1Ð,q Ðs→) C˜
1
Ð( ÐqsÐ,!! Ða2Ð,q Ðs→) C˜
2...
Ð(q ÐsÐ,!! ÐakÐ,q Ðs→) C˜
k such that
for all 1 ≤ j ≤ k, we let C˜ j(q s) = C0(q s), C˜ j(q i) = C0(q i) for all 1 ≤ i ≤ n,
C˜ j(q in)=C0(q in)andC˜ j(q)=C j(q)forallotherq.Moreover,C˜ k(q if)=C k(q fi)=
C′(qi)⪰C .
f f
We can show now that the word a1...a
k
belongs to ⋂ 1≤i≤nL(A i). Let 1 ≤
i ≤ n. It is easy to see that for all 1 ≤j ≤k, there exists a unique qj ∈ Q such
i i
that C˜ (qj)> 0 and C˜ (q)= 0 for all q ∈ Q ∖{qj}. Moreover, for all 1 ≤j ≤k,
j i j i i
q ij =∆∗ i(q i0,a1...a j). As C˜ k(q if)=C′(q if)>0, we get that q if =∆∗ i(q i0,a1...a k),
and hence a1...a
k
∈L(A i).
29